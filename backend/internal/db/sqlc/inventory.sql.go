// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inventory.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const adjustStock = `-- name: AdjustStock :one
UPDATE inventory_items
SET stock_qty = stock_qty + $1::INT,
    last_restocked_at = CASE WHEN $1::INT > 0 THEN NOW() ELSE last_restocked_at END
WHERE id = $2 AND tenant_id = $3
  AND stock_qty + $1::INT >= 0
RETURNING id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at
`

type AdjustStockParams struct {
	QtyChange int32     `json:"qty_change"`
	ID        uuid.UUID `json:"id"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

func (q *Queries) AdjustStock(ctx context.Context, arg AdjustStockParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, adjustStock, arg.QtyChange, arg.ID, arg.TenantID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RestaurantID,
		&i.TenantID,
		&i.StockQty,
		&i.ReservedQty,
		&i.CostPrice,
		&i.ReorderThreshold,
		&i.LastRestockedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const consumeReservedStock = `-- name: ConsumeReservedStock :one
UPDATE inventory_items
SET stock_qty = stock_qty - $1::INT,
    reserved_qty = reserved_qty - $1::INT
WHERE product_id = $2 AND restaurant_id = $3
  AND tenant_id = $4
  AND reserved_qty >= $1::INT
  AND stock_qty >= $1::INT
RETURNING id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at
`

type ConsumeReservedStockParams struct {
	Qty          int32     `json:"qty"`
	ProductID    uuid.UUID `json:"product_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ConsumeReservedStock(ctx context.Context, arg ConsumeReservedStockParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, consumeReservedStock,
		arg.Qty,
		arg.ProductID,
		arg.RestaurantID,
		arg.TenantID,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RestaurantID,
		&i.TenantID,
		&i.StockQty,
		&i.ReservedQty,
		&i.CostPrice,
		&i.ReorderThreshold,
		&i.LastRestockedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countInventoryByRestaurant = `-- name: CountInventoryByRestaurant :one
SELECT COUNT(*) FROM inventory_items
WHERE restaurant_id = $1 AND tenant_id = $2
`

type CountInventoryByRestaurantParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
}

func (q *Queries) CountInventoryByRestaurant(ctx context.Context, arg CountInventoryByRestaurantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInventoryByRestaurant, arg.RestaurantID, arg.TenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLowStock = `-- name: CountLowStock :one
SELECT COUNT(*) FROM inventory_items
WHERE tenant_id = $1 AND restaurant_id = $2
  AND stock_qty - reserved_qty <= reorder_threshold
`

type CountLowStockParams struct {
	TenantID     uuid.UUID `json:"tenant_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
}

func (q *Queries) CountLowStock(ctx context.Context, arg CountLowStockParams) (int64, error) {
	row := q.db.QueryRow(ctx, countLowStock, arg.TenantID, arg.RestaurantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInventoryAdjustment = `-- name: CreateInventoryAdjustment :one
INSERT INTO inventory_adjustments (
    inventory_item_id, tenant_id, restaurant_id, order_id,
    adjustment_type, qty_before, qty_change, qty_after,
    cost_price, note, adjusted_by
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, inventory_item_id, tenant_id, restaurant_id, order_id, adjustment_type, qty_before, qty_change, qty_after, cost_price, note, adjusted_by, created_at
`

type CreateInventoryAdjustmentParams struct {
	InventoryItemID uuid.UUID                 `json:"inventory_item_id"`
	TenantID        uuid.UUID                 `json:"tenant_id"`
	RestaurantID    uuid.UUID                 `json:"restaurant_id"`
	OrderID         pgtype.UUID               `json:"order_id"`
	AdjustmentType  InventoryAdjustmentReason `json:"adjustment_type"`
	QtyBefore       int32                     `json:"qty_before"`
	QtyChange       int32                     `json:"qty_change"`
	QtyAfter        int32                     `json:"qty_after"`
	CostPrice       pgtype.Numeric            `json:"cost_price"`
	Note            sql.NullString            `json:"note"`
	AdjustedBy      pgtype.UUID               `json:"adjusted_by"`
}

func (q *Queries) CreateInventoryAdjustment(ctx context.Context, arg CreateInventoryAdjustmentParams) (InventoryAdjustment, error) {
	row := q.db.QueryRow(ctx, createInventoryAdjustment,
		arg.InventoryItemID,
		arg.TenantID,
		arg.RestaurantID,
		arg.OrderID,
		arg.AdjustmentType,
		arg.QtyBefore,
		arg.QtyChange,
		arg.QtyAfter,
		arg.CostPrice,
		arg.Note,
		arg.AdjustedBy,
	)
	var i InventoryAdjustment
	err := row.Scan(
		&i.ID,
		&i.InventoryItemID,
		&i.TenantID,
		&i.RestaurantID,
		&i.OrderID,
		&i.AdjustmentType,
		&i.QtyBefore,
		&i.QtyChange,
		&i.QtyAfter,
		&i.CostPrice,
		&i.Note,
		&i.AdjustedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createInventoryItem = `-- name: CreateInventoryItem :one
INSERT INTO inventory_items (
    product_id, restaurant_id, tenant_id, stock_qty,
    reserved_qty, cost_price, reorder_threshold
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at
`

type CreateInventoryItemParams struct {
	ProductID        uuid.UUID      `json:"product_id"`
	RestaurantID     uuid.UUID      `json:"restaurant_id"`
	TenantID         uuid.UUID      `json:"tenant_id"`
	StockQty         int32          `json:"stock_qty"`
	ReservedQty      int32          `json:"reserved_qty"`
	CostPrice        pgtype.Numeric `json:"cost_price"`
	ReorderThreshold int32          `json:"reorder_threshold"`
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, createInventoryItem,
		arg.ProductID,
		arg.RestaurantID,
		arg.TenantID,
		arg.StockQty,
		arg.ReservedQty,
		arg.CostPrice,
		arg.ReorderThreshold,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RestaurantID,
		&i.TenantID,
		&i.StockQty,
		&i.ReservedQty,
		&i.CostPrice,
		&i.ReorderThreshold,
		&i.LastRestockedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryByProductAndRestaurant = `-- name: GetInventoryByProductAndRestaurant :one
SELECT id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at FROM inventory_items
WHERE product_id = $1 AND restaurant_id = $2 AND tenant_id = $3
`

type GetInventoryByProductAndRestaurantParams struct {
	ProductID    uuid.UUID `json:"product_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetInventoryByProductAndRestaurant(ctx context.Context, arg GetInventoryByProductAndRestaurantParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, getInventoryByProductAndRestaurant, arg.ProductID, arg.RestaurantID, arg.TenantID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RestaurantID,
		&i.TenantID,
		&i.StockQty,
		&i.ReservedQty,
		&i.CostPrice,
		&i.ReorderThreshold,
		&i.LastRestockedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryForUpdate = `-- name: GetInventoryForUpdate :one
SELECT id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at FROM inventory_items
WHERE product_id = $1 AND restaurant_id = $2
FOR UPDATE
`

type GetInventoryForUpdateParams struct {
	ProductID    uuid.UUID `json:"product_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
}

func (q *Queries) GetInventoryForUpdate(ctx context.Context, arg GetInventoryForUpdateParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, getInventoryForUpdate, arg.ProductID, arg.RestaurantID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RestaurantID,
		&i.TenantID,
		&i.StockQty,
		&i.ReservedQty,
		&i.CostPrice,
		&i.ReorderThreshold,
		&i.LastRestockedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInventoryItem = `-- name: GetInventoryItem :one

SELECT id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at FROM inventory_items
WHERE id = $1 AND tenant_id = $2
`

type GetInventoryItemParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

// ============================================================
// Inventory SQLC Queries
// ============================================================
func (q *Queries) GetInventoryItem(ctx context.Context, arg GetInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, getInventoryItem, arg.ID, arg.TenantID)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RestaurantID,
		&i.TenantID,
		&i.StockQty,
		&i.ReservedQty,
		&i.CostPrice,
		&i.ReorderThreshold,
		&i.LastRestockedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listInventoryAdjustments = `-- name: ListInventoryAdjustments :many
SELECT id, inventory_item_id, tenant_id, restaurant_id, order_id, adjustment_type, qty_before, qty_change, qty_after, cost_price, note, adjusted_by, created_at FROM inventory_adjustments
WHERE inventory_item_id = $1 AND tenant_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListInventoryAdjustmentsParams struct {
	InventoryItemID uuid.UUID `json:"inventory_item_id"`
	TenantID        uuid.UUID `json:"tenant_id"`
	Limit           int32     `json:"limit"`
	Offset          int32     `json:"offset"`
}

func (q *Queries) ListInventoryAdjustments(ctx context.Context, arg ListInventoryAdjustmentsParams) ([]InventoryAdjustment, error) {
	rows, err := q.db.Query(ctx, listInventoryAdjustments,
		arg.InventoryItemID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryAdjustment{}
	for rows.Next() {
		var i InventoryAdjustment
		if err := rows.Scan(
			&i.ID,
			&i.InventoryItemID,
			&i.TenantID,
			&i.RestaurantID,
			&i.OrderID,
			&i.AdjustmentType,
			&i.QtyBefore,
			&i.QtyChange,
			&i.QtyAfter,
			&i.CostPrice,
			&i.Note,
			&i.AdjustedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryByRestaurant = `-- name: ListInventoryByRestaurant :many
SELECT id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at FROM inventory_items
WHERE restaurant_id = $1 AND tenant_id = $2
ORDER BY updated_at DESC
LIMIT $3 OFFSET $4
`

type ListInventoryByRestaurantParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListInventoryByRestaurant(ctx context.Context, arg ListInventoryByRestaurantParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, listInventoryByRestaurant,
		arg.RestaurantID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryItem{}
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.RestaurantID,
			&i.TenantID,
			&i.StockQty,
			&i.ReservedQty,
			&i.CostPrice,
			&i.ReorderThreshold,
			&i.LastRestockedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLowStock = `-- name: ListLowStock :many
SELECT id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at FROM inventory_items
WHERE tenant_id = $1 AND restaurant_id = $2
  AND stock_qty - reserved_qty <= reorder_threshold
ORDER BY (stock_qty - reserved_qty) ASC
LIMIT $3 OFFSET $4
`

type ListLowStockParams struct {
	TenantID     uuid.UUID `json:"tenant_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListLowStock(ctx context.Context, arg ListLowStockParams) ([]InventoryItem, error) {
	rows, err := q.db.Query(ctx, listLowStock,
		arg.TenantID,
		arg.RestaurantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryItem{}
	for rows.Next() {
		var i InventoryItem
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.RestaurantID,
			&i.TenantID,
			&i.StockQty,
			&i.ReservedQty,
			&i.CostPrice,
			&i.ReorderThreshold,
			&i.LastRestockedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const releaseStock = `-- name: ReleaseStock :one
UPDATE inventory_items
SET reserved_qty = reserved_qty - $1::INT
WHERE product_id = $2 AND restaurant_id = $3
  AND tenant_id = $4
  AND reserved_qty >= $1::INT
RETURNING id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at
`

type ReleaseStockParams struct {
	Qty          int32     `json:"qty"`
	ProductID    uuid.UUID `json:"product_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ReleaseStock(ctx context.Context, arg ReleaseStockParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, releaseStock,
		arg.Qty,
		arg.ProductID,
		arg.RestaurantID,
		arg.TenantID,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RestaurantID,
		&i.TenantID,
		&i.StockQty,
		&i.ReservedQty,
		&i.CostPrice,
		&i.ReorderThreshold,
		&i.LastRestockedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const reserveStock = `-- name: ReserveStock :one
UPDATE inventory_items
SET reserved_qty = reserved_qty + $1::INT
WHERE product_id = $2 AND restaurant_id = $3
  AND tenant_id = $4
  AND stock_qty - reserved_qty >= $1::INT
RETURNING id, product_id, restaurant_id, tenant_id, stock_qty, reserved_qty, cost_price, reorder_threshold, last_restocked_at, updated_at
`

type ReserveStockParams struct {
	Qty          int32     `json:"qty"`
	ProductID    uuid.UUID `json:"product_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ReserveStock(ctx context.Context, arg ReserveStockParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, reserveStock,
		arg.Qty,
		arg.ProductID,
		arg.RestaurantID,
		arg.TenantID,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.RestaurantID,
		&i.TenantID,
		&i.StockQty,
		&i.ReservedQty,
		&i.CostPrice,
		&i.ReorderThreshold,
		&i.LastRestockedAt,
		&i.UpdatedAt,
	)
	return i, err
}
