// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: refunds.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const approveRefund = `-- name: ApproveRefund :one
UPDATE refunds SET
    status = 'approved',
    approved_by = $3,
    approved_at = $4
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, order_id, transaction_id, issue_id, amount, reason, status, gateway_refund_id, approved_by, approved_at, processed_at, created_at, updated_at
`

type ApproveRefundParams struct {
	ID         uuid.UUID          `json:"id"`
	TenantID   uuid.UUID          `json:"tenant_id"`
	ApprovedBy pgtype.UUID        `json:"approved_by"`
	ApprovedAt pgtype.Timestamptz `json:"approved_at"`
}

func (q *Queries) ApproveRefund(ctx context.Context, arg ApproveRefundParams) (Refund, error) {
	row := q.db.QueryRow(ctx, approveRefund,
		arg.ID,
		arg.TenantID,
		arg.ApprovedBy,
		arg.ApprovedAt,
	)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.TransactionID,
		&i.IssueID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.GatewayRefundID,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRefund = `-- name: CreateRefund :one
INSERT INTO refunds (
    tenant_id, order_id, transaction_id, issue_id, amount, reason, status,
    gateway_refund_id, approved_by, approved_at, processed_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, tenant_id, order_id, transaction_id, issue_id, amount, reason, status, gateway_refund_id, approved_by, approved_at, processed_at, created_at, updated_at
`

type CreateRefundParams struct {
	TenantID        uuid.UUID          `json:"tenant_id"`
	OrderID         uuid.UUID          `json:"order_id"`
	TransactionID   uuid.UUID          `json:"transaction_id"`
	IssueID         pgtype.UUID        `json:"issue_id"`
	Amount          pgtype.Numeric     `json:"amount"`
	Reason          string             `json:"reason"`
	Status          RefundStatus       `json:"status"`
	GatewayRefundID sql.NullString     `json:"gateway_refund_id"`
	ApprovedBy      pgtype.UUID        `json:"approved_by"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	ProcessedAt     pgtype.Timestamptz `json:"processed_at"`
}

func (q *Queries) CreateRefund(ctx context.Context, arg CreateRefundParams) (Refund, error) {
	row := q.db.QueryRow(ctx, createRefund,
		arg.TenantID,
		arg.OrderID,
		arg.TransactionID,
		arg.IssueID,
		arg.Amount,
		arg.Reason,
		arg.Status,
		arg.GatewayRefundID,
		arg.ApprovedBy,
		arg.ApprovedAt,
		arg.ProcessedAt,
	)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.TransactionID,
		&i.IssueID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.GatewayRefundID,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRefundByID = `-- name: GetRefundByID :one
SELECT id, tenant_id, order_id, transaction_id, issue_id, amount, reason, status, gateway_refund_id, approved_by, approved_at, processed_at, created_at, updated_at FROM refunds
WHERE id = $1 AND tenant_id = $2
LIMIT 1
`

type GetRefundByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetRefundByID(ctx context.Context, arg GetRefundByIDParams) (Refund, error) {
	row := q.db.QueryRow(ctx, getRefundByID, arg.ID, arg.TenantID)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.TransactionID,
		&i.IssueID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.GatewayRefundID,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRefundsByOrder = `-- name: ListRefundsByOrder :many
SELECT id, tenant_id, order_id, transaction_id, issue_id, amount, reason, status, gateway_refund_id, approved_by, approved_at, processed_at, created_at, updated_at FROM refunds
WHERE order_id = $1 AND tenant_id = $2
ORDER BY created_at DESC
`

type ListRefundsByOrderParams struct {
	OrderID  uuid.UUID `json:"order_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ListRefundsByOrder(ctx context.Context, arg ListRefundsByOrderParams) ([]Refund, error) {
	rows, err := q.db.Query(ctx, listRefundsByOrder, arg.OrderID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Refund{}
	for rows.Next() {
		var i Refund
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderID,
			&i.TransactionID,
			&i.IssueID,
			&i.Amount,
			&i.Reason,
			&i.Status,
			&i.GatewayRefundID,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.ProcessedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRefundStatus = `-- name: UpdateRefundStatus :one
UPDATE refunds SET
    status = COALESCE($3, status),
    gateway_refund_id = COALESCE($4, gateway_refund_id),
    processed_at = COALESCE($5, processed_at)
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, order_id, transaction_id, issue_id, amount, reason, status, gateway_refund_id, approved_by, approved_at, processed_at, created_at, updated_at
`

type UpdateRefundStatusParams struct {
	ID              uuid.UUID          `json:"id"`
	TenantID        uuid.UUID          `json:"tenant_id"`
	Status          NullRefundStatus   `json:"status"`
	GatewayRefundID sql.NullString     `json:"gateway_refund_id"`
	ProcessedAt     pgtype.Timestamptz `json:"processed_at"`
}

func (q *Queries) UpdateRefundStatus(ctx context.Context, arg UpdateRefundStatusParams) (Refund, error) {
	row := q.db.QueryRow(ctx, updateRefundStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.GatewayRefundID,
		arg.ProcessedAt,
	)
	var i Refund
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.TransactionID,
		&i.IssueID,
		&i.Amount,
		&i.Reason,
		&i.Status,
		&i.GatewayRefundID,
		&i.ApprovedBy,
		&i.ApprovedAt,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
