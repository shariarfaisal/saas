// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: restaurants.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRestaurantsByTenant = `-- name: CountRestaurantsByTenant :one
SELECT COUNT(*) FROM restaurants WHERE tenant_id = $1 AND is_active = true
`

func (q *Queries) CountRestaurantsByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countRestaurantsByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRestaurant = `-- name: CreateRestaurant :one
INSERT INTO restaurants (tenant_id, hub_id, owner_id, name, slug, type, description, short_description, banner_image_url, logo_url, gallery_urls, phone, email, address_line1, address_line2, area, city, cuisines, tags, commission_rate, vat_rate, is_vat_inclusive, min_order_amount, avg_prep_time_minutes, max_concurrent_orders, auto_accept_orders, order_prefix, is_available, is_featured, is_active, sort_order)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31)
RETURNING id, tenant_id, hub_id, owner_id, name, slug, type, description, short_description, banner_image_url, logo_url, gallery_urls, phone, email, address_line1, address_line2, area, city, geo_lat, geo_lng, cuisines, tags, commission_rate, vat_rate, is_vat_inclusive, min_order_amount, avg_prep_time_minutes, max_concurrent_orders, auto_accept_orders, order_prefix, order_sequence, is_available, is_featured, is_active, sort_order, meta_title, meta_description, meta_keywords, rating_avg, rating_count, total_order_count, created_at, updated_at
`

type CreateRestaurantParams struct {
	TenantID            uuid.UUID      `json:"tenant_id"`
	HubID               pgtype.UUID    `json:"hub_id"`
	OwnerID             pgtype.UUID    `json:"owner_id"`
	Name                string         `json:"name"`
	Slug                string         `json:"slug"`
	Type                RestaurantType `json:"type"`
	Description         sql.NullString `json:"description"`
	ShortDescription    sql.NullString `json:"short_description"`
	BannerImageUrl      sql.NullString `json:"banner_image_url"`
	LogoUrl             sql.NullString `json:"logo_url"`
	GalleryUrls         []string       `json:"gallery_urls"`
	Phone               sql.NullString `json:"phone"`
	Email               sql.NullString `json:"email"`
	AddressLine1        sql.NullString `json:"address_line1"`
	AddressLine2        sql.NullString `json:"address_line2"`
	Area                sql.NullString `json:"area"`
	City                string         `json:"city"`
	Cuisines            []string       `json:"cuisines"`
	Tags                []string       `json:"tags"`
	CommissionRate      pgtype.Numeric `json:"commission_rate"`
	VatRate             pgtype.Numeric `json:"vat_rate"`
	IsVatInclusive      bool           `json:"is_vat_inclusive"`
	MinOrderAmount      pgtype.Numeric `json:"min_order_amount"`
	AvgPrepTimeMinutes  int32          `json:"avg_prep_time_minutes"`
	MaxConcurrentOrders int32          `json:"max_concurrent_orders"`
	AutoAcceptOrders    bool           `json:"auto_accept_orders"`
	OrderPrefix         sql.NullString `json:"order_prefix"`
	IsAvailable         bool           `json:"is_available"`
	IsFeatured          bool           `json:"is_featured"`
	IsActive            bool           `json:"is_active"`
	SortOrder           int32          `json:"sort_order"`
}

func (q *Queries) CreateRestaurant(ctx context.Context, arg CreateRestaurantParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, createRestaurant,
		arg.TenantID,
		arg.HubID,
		arg.OwnerID,
		arg.Name,
		arg.Slug,
		arg.Type,
		arg.Description,
		arg.ShortDescription,
		arg.BannerImageUrl,
		arg.LogoUrl,
		arg.GalleryUrls,
		arg.Phone,
		arg.Email,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.Area,
		arg.City,
		arg.Cuisines,
		arg.Tags,
		arg.CommissionRate,
		arg.VatRate,
		arg.IsVatInclusive,
		arg.MinOrderAmount,
		arg.AvgPrepTimeMinutes,
		arg.MaxConcurrentOrders,
		arg.AutoAcceptOrders,
		arg.OrderPrefix,
		arg.IsAvailable,
		arg.IsFeatured,
		arg.IsActive,
		arg.SortOrder,
	)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.HubID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.Description,
		&i.ShortDescription,
		&i.BannerImageUrl,
		&i.LogoUrl,
		&i.GalleryUrls,
		&i.Phone,
		&i.Email,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Area,
		&i.City,
		&i.GeoLat,
		&i.GeoLng,
		&i.Cuisines,
		&i.Tags,
		&i.CommissionRate,
		&i.VatRate,
		&i.IsVatInclusive,
		&i.MinOrderAmount,
		&i.AvgPrepTimeMinutes,
		&i.MaxConcurrentOrders,
		&i.AutoAcceptOrders,
		&i.OrderPrefix,
		&i.OrderSequence,
		&i.IsAvailable,
		&i.IsFeatured,
		&i.IsActive,
		&i.SortOrder,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.RatingAvg,
		&i.RatingCount,
		&i.TotalOrderCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOperatingHours = `-- name: DeleteOperatingHours :exec
DELETE FROM restaurant_operating_hours WHERE restaurant_id = $1
`

func (q *Queries) DeleteOperatingHours(ctx context.Context, restaurantID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOperatingHours, restaurantID)
	return err
}

const deleteRestaurant = `-- name: DeleteRestaurant :exec
UPDATE restaurants SET is_active = false WHERE id = $1 AND tenant_id = $2
`

type DeleteRestaurantParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteRestaurant(ctx context.Context, arg DeleteRestaurantParams) error {
	_, err := q.db.Exec(ctx, deleteRestaurant, arg.ID, arg.TenantID)
	return err
}

const getRestaurantByID = `-- name: GetRestaurantByID :one
SELECT id, tenant_id, hub_id, owner_id, name, slug, type, description, short_description, banner_image_url, logo_url, gallery_urls, phone, email, address_line1, address_line2, area, city, geo_lat, geo_lng, cuisines, tags, commission_rate, vat_rate, is_vat_inclusive, min_order_amount, avg_prep_time_minutes, max_concurrent_orders, auto_accept_orders, order_prefix, order_sequence, is_available, is_featured, is_active, sort_order, meta_title, meta_description, meta_keywords, rating_avg, rating_count, total_order_count, created_at, updated_at FROM restaurants WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetRestaurantByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetRestaurantByID(ctx context.Context, arg GetRestaurantByIDParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, getRestaurantByID, arg.ID, arg.TenantID)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.HubID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.Description,
		&i.ShortDescription,
		&i.BannerImageUrl,
		&i.LogoUrl,
		&i.GalleryUrls,
		&i.Phone,
		&i.Email,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Area,
		&i.City,
		&i.GeoLat,
		&i.GeoLng,
		&i.Cuisines,
		&i.Tags,
		&i.CommissionRate,
		&i.VatRate,
		&i.IsVatInclusive,
		&i.MinOrderAmount,
		&i.AvgPrepTimeMinutes,
		&i.MaxConcurrentOrders,
		&i.AutoAcceptOrders,
		&i.OrderPrefix,
		&i.OrderSequence,
		&i.IsAvailable,
		&i.IsFeatured,
		&i.IsActive,
		&i.SortOrder,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.RatingAvg,
		&i.RatingCount,
		&i.TotalOrderCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRestaurantBySlug = `-- name: GetRestaurantBySlug :one
SELECT id, tenant_id, hub_id, owner_id, name, slug, type, description, short_description, banner_image_url, logo_url, gallery_urls, phone, email, address_line1, address_line2, area, city, geo_lat, geo_lng, cuisines, tags, commission_rate, vat_rate, is_vat_inclusive, min_order_amount, avg_prep_time_minutes, max_concurrent_orders, auto_accept_orders, order_prefix, order_sequence, is_available, is_featured, is_active, sort_order, meta_title, meta_description, meta_keywords, rating_avg, rating_count, total_order_count, created_at, updated_at FROM restaurants WHERE tenant_id = $1 AND slug = $2 LIMIT 1
`

type GetRestaurantBySlugParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Slug     string    `json:"slug"`
}

func (q *Queries) GetRestaurantBySlug(ctx context.Context, arg GetRestaurantBySlugParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, getRestaurantBySlug, arg.TenantID, arg.Slug)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.HubID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.Description,
		&i.ShortDescription,
		&i.BannerImageUrl,
		&i.LogoUrl,
		&i.GalleryUrls,
		&i.Phone,
		&i.Email,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Area,
		&i.City,
		&i.GeoLat,
		&i.GeoLng,
		&i.Cuisines,
		&i.Tags,
		&i.CommissionRate,
		&i.VatRate,
		&i.IsVatInclusive,
		&i.MinOrderAmount,
		&i.AvgPrepTimeMinutes,
		&i.MaxConcurrentOrders,
		&i.AutoAcceptOrders,
		&i.OrderPrefix,
		&i.OrderSequence,
		&i.IsAvailable,
		&i.IsFeatured,
		&i.IsActive,
		&i.SortOrder,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.RatingAvg,
		&i.RatingCount,
		&i.TotalOrderCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAvailableByHubAndArea = `-- name: ListAvailableByHubAndArea :many
SELECT r.id, r.tenant_id, r.hub_id, r.owner_id, r.name, r.slug, r.type, r.description, r.short_description, r.banner_image_url, r.logo_url, r.gallery_urls, r.phone, r.email, r.address_line1, r.address_line2, r.area, r.city, r.geo_lat, r.geo_lng, r.cuisines, r.tags, r.commission_rate, r.vat_rate, r.is_vat_inclusive, r.min_order_amount, r.avg_prep_time_minutes, r.max_concurrent_orders, r.auto_accept_orders, r.order_prefix, r.order_sequence, r.is_available, r.is_featured, r.is_active, r.sort_order, r.meta_title, r.meta_description, r.meta_keywords, r.rating_avg, r.rating_count, r.total_order_count, r.created_at, r.updated_at FROM restaurants r
JOIN hub_coverage_areas hca ON hca.hub_id = r.hub_id AND hca.slug = $2 AND hca.is_active = true
WHERE r.tenant_id = $1 AND r.is_available = true AND r.is_active = true
ORDER BY r.is_featured DESC, r.sort_order, r.name
LIMIT $3 OFFSET $4
`

type ListAvailableByHubAndAreaParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Slug     string    `json:"slug"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListAvailableByHubAndArea(ctx context.Context, arg ListAvailableByHubAndAreaParams) ([]Restaurant, error) {
	rows, err := q.db.Query(ctx, listAvailableByHubAndArea,
		arg.TenantID,
		arg.Slug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Restaurant{}
	for rows.Next() {
		var i Restaurant
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.HubID,
			&i.OwnerID,
			&i.Name,
			&i.Slug,
			&i.Type,
			&i.Description,
			&i.ShortDescription,
			&i.BannerImageUrl,
			&i.LogoUrl,
			&i.GalleryUrls,
			&i.Phone,
			&i.Email,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.Area,
			&i.City,
			&i.GeoLat,
			&i.GeoLng,
			&i.Cuisines,
			&i.Tags,
			&i.CommissionRate,
			&i.VatRate,
			&i.IsVatInclusive,
			&i.MinOrderAmount,
			&i.AvgPrepTimeMinutes,
			&i.MaxConcurrentOrders,
			&i.AutoAcceptOrders,
			&i.OrderPrefix,
			&i.OrderSequence,
			&i.IsAvailable,
			&i.IsFeatured,
			&i.IsActive,
			&i.SortOrder,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.RatingAvg,
			&i.RatingCount,
			&i.TotalOrderCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOperatingHours = `-- name: ListOperatingHours :many
SELECT id, restaurant_id, tenant_id, day_of_week, open_time, close_time, is_closed FROM restaurant_operating_hours WHERE restaurant_id = $1 ORDER BY day_of_week
`

func (q *Queries) ListOperatingHours(ctx context.Context, restaurantID uuid.UUID) ([]RestaurantOperatingHour, error) {
	rows, err := q.db.Query(ctx, listOperatingHours, restaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RestaurantOperatingHour{}
	for rows.Next() {
		var i RestaurantOperatingHour
		if err := rows.Scan(
			&i.ID,
			&i.RestaurantID,
			&i.TenantID,
			&i.DayOfWeek,
			&i.OpenTime,
			&i.CloseTime,
			&i.IsClosed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRestaurantsByTenant = `-- name: ListRestaurantsByTenant :many
SELECT id, tenant_id, hub_id, owner_id, name, slug, type, description, short_description, banner_image_url, logo_url, gallery_urls, phone, email, address_line1, address_line2, area, city, geo_lat, geo_lng, cuisines, tags, commission_rate, vat_rate, is_vat_inclusive, min_order_amount, avg_prep_time_minutes, max_concurrent_orders, auto_accept_orders, order_prefix, order_sequence, is_available, is_featured, is_active, sort_order, meta_title, meta_description, meta_keywords, rating_avg, rating_count, total_order_count, created_at, updated_at FROM restaurants WHERE tenant_id = $1 AND is_active = true ORDER BY sort_order, name LIMIT $2 OFFSET $3
`

type ListRestaurantsByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListRestaurantsByTenant(ctx context.Context, arg ListRestaurantsByTenantParams) ([]Restaurant, error) {
	rows, err := q.db.Query(ctx, listRestaurantsByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Restaurant{}
	for rows.Next() {
		var i Restaurant
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.HubID,
			&i.OwnerID,
			&i.Name,
			&i.Slug,
			&i.Type,
			&i.Description,
			&i.ShortDescription,
			&i.BannerImageUrl,
			&i.LogoUrl,
			&i.GalleryUrls,
			&i.Phone,
			&i.Email,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.Area,
			&i.City,
			&i.GeoLat,
			&i.GeoLng,
			&i.Cuisines,
			&i.Tags,
			&i.CommissionRate,
			&i.VatRate,
			&i.IsVatInclusive,
			&i.MinOrderAmount,
			&i.AvgPrepTimeMinutes,
			&i.MaxConcurrentOrders,
			&i.AutoAcceptOrders,
			&i.OrderPrefix,
			&i.OrderSequence,
			&i.IsAvailable,
			&i.IsFeatured,
			&i.IsActive,
			&i.SortOrder,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.RatingAvg,
			&i.RatingCount,
			&i.TotalOrderCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRestaurant = `-- name: UpdateRestaurant :one
UPDATE restaurants SET
  name = COALESCE($1, name),
  description = COALESCE($2, description),
  short_description = COALESCE($3, short_description),
  banner_image_url = COALESCE($4, banner_image_url),
  logo_url = COALESCE($5, logo_url),
  phone = COALESCE($6, phone),
  email = COALESCE($7, email),
  address_line1 = COALESCE($8, address_line1),
  area = COALESCE($9, area),
  city = COALESCE($10, city),
  cuisines = COALESCE($11, cuisines),
  tags = COALESCE($12, tags),
  min_order_amount = COALESCE($13, min_order_amount),
  avg_prep_time_minutes = COALESCE($14, avg_prep_time_minutes),
  auto_accept_orders = COALESCE($15, auto_accept_orders),
  is_featured = COALESCE($16, is_featured),
  sort_order = COALESCE($17, sort_order)
WHERE id = $18 AND tenant_id = $19
RETURNING id, tenant_id, hub_id, owner_id, name, slug, type, description, short_description, banner_image_url, logo_url, gallery_urls, phone, email, address_line1, address_line2, area, city, geo_lat, geo_lng, cuisines, tags, commission_rate, vat_rate, is_vat_inclusive, min_order_amount, avg_prep_time_minutes, max_concurrent_orders, auto_accept_orders, order_prefix, order_sequence, is_available, is_featured, is_active, sort_order, meta_title, meta_description, meta_keywords, rating_avg, rating_count, total_order_count, created_at, updated_at
`

type UpdateRestaurantParams struct {
	Name               sql.NullString `json:"name"`
	Description        sql.NullString `json:"description"`
	ShortDescription   sql.NullString `json:"short_description"`
	BannerImageUrl     sql.NullString `json:"banner_image_url"`
	LogoUrl            sql.NullString `json:"logo_url"`
	Phone              sql.NullString `json:"phone"`
	Email              sql.NullString `json:"email"`
	AddressLine1       sql.NullString `json:"address_line1"`
	Area               sql.NullString `json:"area"`
	City               sql.NullString `json:"city"`
	Cuisines           []string       `json:"cuisines"`
	Tags               []string       `json:"tags"`
	MinOrderAmount     pgtype.Numeric `json:"min_order_amount"`
	AvgPrepTimeMinutes *int32         `json:"avg_prep_time_minutes"`
	AutoAcceptOrders   *bool          `json:"auto_accept_orders"`
	IsFeatured         *bool          `json:"is_featured"`
	SortOrder          *int32         `json:"sort_order"`
	ID                 uuid.UUID      `json:"id"`
	TenantID           uuid.UUID      `json:"tenant_id"`
}

func (q *Queries) UpdateRestaurant(ctx context.Context, arg UpdateRestaurantParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, updateRestaurant,
		arg.Name,
		arg.Description,
		arg.ShortDescription,
		arg.BannerImageUrl,
		arg.LogoUrl,
		arg.Phone,
		arg.Email,
		arg.AddressLine1,
		arg.Area,
		arg.City,
		arg.Cuisines,
		arg.Tags,
		arg.MinOrderAmount,
		arg.AvgPrepTimeMinutes,
		arg.AutoAcceptOrders,
		arg.IsFeatured,
		arg.SortOrder,
		arg.ID,
		arg.TenantID,
	)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.HubID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.Description,
		&i.ShortDescription,
		&i.BannerImageUrl,
		&i.LogoUrl,
		&i.GalleryUrls,
		&i.Phone,
		&i.Email,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Area,
		&i.City,
		&i.GeoLat,
		&i.GeoLng,
		&i.Cuisines,
		&i.Tags,
		&i.CommissionRate,
		&i.VatRate,
		&i.IsVatInclusive,
		&i.MinOrderAmount,
		&i.AvgPrepTimeMinutes,
		&i.MaxConcurrentOrders,
		&i.AutoAcceptOrders,
		&i.OrderPrefix,
		&i.OrderSequence,
		&i.IsAvailable,
		&i.IsFeatured,
		&i.IsActive,
		&i.SortOrder,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.RatingAvg,
		&i.RatingCount,
		&i.TotalOrderCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRestaurantAvailability = `-- name: UpdateRestaurantAvailability :one
UPDATE restaurants SET is_available = $2 WHERE id = $1 AND tenant_id = $3 RETURNING id, tenant_id, hub_id, owner_id, name, slug, type, description, short_description, banner_image_url, logo_url, gallery_urls, phone, email, address_line1, address_line2, area, city, geo_lat, geo_lng, cuisines, tags, commission_rate, vat_rate, is_vat_inclusive, min_order_amount, avg_prep_time_minutes, max_concurrent_orders, auto_accept_orders, order_prefix, order_sequence, is_available, is_featured, is_active, sort_order, meta_title, meta_description, meta_keywords, rating_avg, rating_count, total_order_count, created_at, updated_at
`

type UpdateRestaurantAvailabilityParams struct {
	ID          uuid.UUID `json:"id"`
	IsAvailable bool      `json:"is_available"`
	TenantID    uuid.UUID `json:"tenant_id"`
}

func (q *Queries) UpdateRestaurantAvailability(ctx context.Context, arg UpdateRestaurantAvailabilityParams) (Restaurant, error) {
	row := q.db.QueryRow(ctx, updateRestaurantAvailability, arg.ID, arg.IsAvailable, arg.TenantID)
	var i Restaurant
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.HubID,
		&i.OwnerID,
		&i.Name,
		&i.Slug,
		&i.Type,
		&i.Description,
		&i.ShortDescription,
		&i.BannerImageUrl,
		&i.LogoUrl,
		&i.GalleryUrls,
		&i.Phone,
		&i.Email,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Area,
		&i.City,
		&i.GeoLat,
		&i.GeoLng,
		&i.Cuisines,
		&i.Tags,
		&i.CommissionRate,
		&i.VatRate,
		&i.IsVatInclusive,
		&i.MinOrderAmount,
		&i.AvgPrepTimeMinutes,
		&i.MaxConcurrentOrders,
		&i.AutoAcceptOrders,
		&i.OrderPrefix,
		&i.OrderSequence,
		&i.IsAvailable,
		&i.IsFeatured,
		&i.IsActive,
		&i.SortOrder,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.RatingAvg,
		&i.RatingCount,
		&i.TotalOrderCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertOperatingHour = `-- name: UpsertOperatingHour :one
INSERT INTO restaurant_operating_hours (restaurant_id, tenant_id, day_of_week, open_time, close_time, is_closed)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (restaurant_id, day_of_week) DO UPDATE SET
  open_time = EXCLUDED.open_time,
  close_time = EXCLUDED.close_time,
  is_closed = EXCLUDED.is_closed
RETURNING id, restaurant_id, tenant_id, day_of_week, open_time, close_time, is_closed
`

type UpsertOperatingHourParams struct {
	RestaurantID uuid.UUID   `json:"restaurant_id"`
	TenantID     uuid.UUID   `json:"tenant_id"`
	DayOfWeek    int16       `json:"day_of_week"`
	OpenTime     pgtype.Time `json:"open_time"`
	CloseTime    pgtype.Time `json:"close_time"`
	IsClosed     bool        `json:"is_closed"`
}

func (q *Queries) UpsertOperatingHour(ctx context.Context, arg UpsertOperatingHourParams) (RestaurantOperatingHour, error) {
	row := q.db.QueryRow(ctx, upsertOperatingHour,
		arg.RestaurantID,
		arg.TenantID,
		arg.DayOfWeek,
		arg.OpenTime,
		arg.CloseTime,
		arg.IsClosed,
	)
	var i RestaurantOperatingHour
	err := row.Scan(
		&i.ID,
		&i.RestaurantID,
		&i.TenantID,
		&i.DayOfWeek,
		&i.OpenTime,
		&i.CloseTime,
		&i.IsClosed,
	)
	return i, err
}
