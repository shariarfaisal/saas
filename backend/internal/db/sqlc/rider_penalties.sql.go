// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rider_penalties.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const appealPenalty = `-- name: AppealPenalty :one
UPDATE rider_penalties SET
  status = 'appealed',
  appeal_note = $3,
  appealed_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, rider_id, tenant_id, order_id, issue_id, reason, amount, status, appeal_note, appealed_at, cleared_at, cleared_by, created_at, updated_at
`

type AppealPenaltyParams struct {
	ID         uuid.UUID      `json:"id"`
	TenantID   uuid.UUID      `json:"tenant_id"`
	AppealNote sql.NullString `json:"appeal_note"`
}

func (q *Queries) AppealPenalty(ctx context.Context, arg AppealPenaltyParams) (RiderPenalty, error) {
	row := q.db.QueryRow(ctx, appealPenalty, arg.ID, arg.TenantID, arg.AppealNote)
	var i RiderPenalty
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.TenantID,
		&i.OrderID,
		&i.IssueID,
		&i.Reason,
		&i.Amount,
		&i.Status,
		&i.AppealNote,
		&i.AppealedAt,
		&i.ClearedAt,
		&i.ClearedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRiderPenalty = `-- name: CreateRiderPenalty :one
INSERT INTO rider_penalties (rider_id, tenant_id, order_id, issue_id, reason, amount)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, rider_id, tenant_id, order_id, issue_id, reason, amount, status, appeal_note, appealed_at, cleared_at, cleared_by, created_at, updated_at
`

type CreateRiderPenaltyParams struct {
	RiderID  uuid.UUID      `json:"rider_id"`
	TenantID uuid.UUID      `json:"tenant_id"`
	OrderID  pgtype.UUID    `json:"order_id"`
	IssueID  pgtype.UUID    `json:"issue_id"`
	Reason   string         `json:"reason"`
	Amount   pgtype.Numeric `json:"amount"`
}

func (q *Queries) CreateRiderPenalty(ctx context.Context, arg CreateRiderPenaltyParams) (RiderPenalty, error) {
	row := q.db.QueryRow(ctx, createRiderPenalty,
		arg.RiderID,
		arg.TenantID,
		arg.OrderID,
		arg.IssueID,
		arg.Reason,
		arg.Amount,
	)
	var i RiderPenalty
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.TenantID,
		&i.OrderID,
		&i.IssueID,
		&i.Reason,
		&i.Amount,
		&i.Status,
		&i.AppealNote,
		&i.AppealedAt,
		&i.ClearedAt,
		&i.ClearedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPenaltyByID = `-- name: GetPenaltyByID :one
SELECT id, rider_id, tenant_id, order_id, issue_id, reason, amount, status, appeal_note, appealed_at, cleared_at, cleared_by, created_at, updated_at FROM rider_penalties WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetPenaltyByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetPenaltyByID(ctx context.Context, arg GetPenaltyByIDParams) (RiderPenalty, error) {
	row := q.db.QueryRow(ctx, getPenaltyByID, arg.ID, arg.TenantID)
	var i RiderPenalty
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.TenantID,
		&i.OrderID,
		&i.IssueID,
		&i.Reason,
		&i.Amount,
		&i.Status,
		&i.AppealNote,
		&i.AppealedAt,
		&i.ClearedAt,
		&i.ClearedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPenaltiesByRider = `-- name: ListPenaltiesByRider :many
SELECT id, rider_id, tenant_id, order_id, issue_id, reason, amount, status, appeal_note, appealed_at, cleared_at, cleared_by, created_at, updated_at FROM rider_penalties
WHERE rider_id = $1 AND tenant_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListPenaltiesByRiderParams struct {
	RiderID  uuid.UUID `json:"rider_id"`
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListPenaltiesByRider(ctx context.Context, arg ListPenaltiesByRiderParams) ([]RiderPenalty, error) {
	rows, err := q.db.Query(ctx, listPenaltiesByRider,
		arg.RiderID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiderPenalty{}
	for rows.Next() {
		var i RiderPenalty
		if err := rows.Scan(
			&i.ID,
			&i.RiderID,
			&i.TenantID,
			&i.OrderID,
			&i.IssueID,
			&i.Reason,
			&i.Amount,
			&i.Status,
			&i.AppealNote,
			&i.AppealedAt,
			&i.ClearedAt,
			&i.ClearedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePenaltyStatus = `-- name: UpdatePenaltyStatus :one
UPDATE rider_penalties SET
  status = $1,
  cleared_at = COALESCE($2, cleared_at),
  cleared_by = COALESCE($3, cleared_by)
WHERE id = $4 AND tenant_id = $5
RETURNING id, rider_id, tenant_id, order_id, issue_id, reason, amount, status, appeal_note, appealed_at, cleared_at, cleared_by, created_at, updated_at
`

type UpdatePenaltyStatusParams struct {
	Status    PenaltyStatus      `json:"status"`
	ClearedAt pgtype.Timestamptz `json:"cleared_at"`
	ClearedBy pgtype.UUID        `json:"cleared_by"`
	ID        uuid.UUID          `json:"id"`
	TenantID  uuid.UUID          `json:"tenant_id"`
}

func (q *Queries) UpdatePenaltyStatus(ctx context.Context, arg UpdatePenaltyStatusParams) (RiderPenalty, error) {
	row := q.db.QueryRow(ctx, updatePenaltyStatus,
		arg.Status,
		arg.ClearedAt,
		arg.ClearedBy,
		arg.ID,
		arg.TenantID,
	)
	var i RiderPenalty
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.TenantID,
		&i.OrderID,
		&i.IssueID,
		&i.Reason,
		&i.Amount,
		&i.Status,
		&i.AppealNote,
		&i.AppealedAt,
		&i.ClearedAt,
		&i.ClearedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
