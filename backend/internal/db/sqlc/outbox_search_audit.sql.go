// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox_search_audit.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearUserPushToken = `-- name: ClearUserPushToken :exec
UPDATE users SET device_push_token = NULL WHERE id = $1
`

func (q *Queries) ClearUserPushToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, clearUserPushToken, id)
	return err
}

const countOrderIssuesByTenant = `-- name: CountOrderIssuesByTenant :one
SELECT COUNT(*) FROM order_issues WHERE tenant_id = $1
`

func (q *Queries) CountOrderIssuesByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOrderIssuesByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
    tenant_id, actor_id, actor_type, action, resource_type, resource_id, changes, reason, ip_address
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, actor_id, actor_type, action, resource_type, resource_id, changes, reason, ip_address, created_at
`

type CreateAuditLogParams struct {
	TenantID     pgtype.UUID     `json:"tenant_id"`
	ActorID      pgtype.UUID     `json:"actor_id"`
	ActorType    ActorType       `json:"actor_type"`
	Action       string          `json:"action"`
	ResourceType string          `json:"resource_type"`
	ResourceID   pgtype.UUID     `json:"resource_id"`
	Changes      json.RawMessage `json:"changes"`
	Reason       sql.NullString  `json:"reason"`
	IpAddress    *netip.Addr     `json:"ip_address"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.TenantID,
		arg.ActorID,
		arg.ActorType,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.Changes,
		arg.Reason,
		arg.IpAddress,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ActorID,
		&i.ActorType,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Changes,
		&i.Reason,
		&i.IpAddress,
		&i.CreatedAt,
	)
	return i, err
}

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (
    tenant_id, user_id, channel, title, body, image_url,
    action_type, action_payload, status
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, user_id, channel, title, body, image_url, action_type, action_payload, status, sent_at, delivered_at, read_at, failed_reason, gateway_message_id, created_at
`

type CreateNotificationParams struct {
	TenantID      pgtype.UUID         `json:"tenant_id"`
	UserID        uuid.UUID           `json:"user_id"`
	Channel       NotificationChannel `json:"channel"`
	Title         string              `json:"title"`
	Body          string              `json:"body"`
	ImageUrl      sql.NullString      `json:"image_url"`
	ActionType    sql.NullString      `json:"action_type"`
	ActionPayload []byte              `json:"action_payload"`
	Status        NotificationStatus  `json:"status"`
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notification, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.TenantID,
		arg.UserID,
		arg.Channel,
		arg.Title,
		arg.Body,
		arg.ImageUrl,
		arg.ActionType,
		arg.ActionPayload,
		arg.Status,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Channel,
		&i.Title,
		&i.Body,
		&i.ImageUrl,
		&i.ActionType,
		&i.ActionPayload,
		&i.Status,
		&i.SentAt,
		&i.DeliveredAt,
		&i.ReadAt,
		&i.FailedReason,
		&i.GatewayMessageID,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderIssueMessage = `-- name: CreateOrderIssueMessage :one
INSERT INTO order_issue_messages (issue_id, tenant_id, sender_id, message, attachments)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, issue_id, tenant_id, sender_id, message, attachments, created_at
`

type CreateOrderIssueMessageParams struct {
	IssueID     uuid.UUID `json:"issue_id"`
	TenantID    uuid.UUID `json:"tenant_id"`
	SenderID    uuid.UUID `json:"sender_id"`
	Message     string    `json:"message"`
	Attachments []string  `json:"attachments"`
}

func (q *Queries) CreateOrderIssueMessage(ctx context.Context, arg CreateOrderIssueMessageParams) (OrderIssueMessage, error) {
	row := q.db.QueryRow(ctx, createOrderIssueMessage,
		arg.IssueID,
		arg.TenantID,
		arg.SenderID,
		arg.Message,
		arg.Attachments,
	)
	var i OrderIssueMessage
	err := row.Scan(
		&i.ID,
		&i.IssueID,
		&i.TenantID,
		&i.SenderID,
		&i.Message,
		&i.Attachments,
		&i.CreatedAt,
	)
	return i, err
}

const createOutboxEvent = `-- name: CreateOutboxEvent :one
INSERT INTO outbox_events (
    tenant_id, aggregate_type, aggregate_id, event_type, payload
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, tenant_id, aggregate_type, aggregate_id, event_type, payload, status, attempts, max_attempts, next_retry_at, last_error, processed_at, created_at
`

type CreateOutboxEventParams struct {
	TenantID      pgtype.UUID     `json:"tenant_id"`
	AggregateType string          `json:"aggregate_type"`
	AggregateID   uuid.UUID       `json:"aggregate_id"`
	EventType     string          `json:"event_type"`
	Payload       json.RawMessage `json:"payload"`
}

func (q *Queries) CreateOutboxEvent(ctx context.Context, arg CreateOutboxEventParams) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, createOutboxEvent,
		arg.TenantID,
		arg.AggregateType,
		arg.AggregateID,
		arg.EventType,
		arg.Payload,
	)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.NextRetryAt,
		&i.LastError,
		&i.ProcessedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createSearchLog = `-- name: CreateSearchLog :one
INSERT INTO search_logs (
    tenant_id, user_id, query, search_type, result_count, filters
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, tenant_id, user_id, query, search_type, result_count, filters, created_at
`

type CreateSearchLogParams struct {
	TenantID    uuid.UUID       `json:"tenant_id"`
	UserID      pgtype.UUID     `json:"user_id"`
	Query       string          `json:"query"`
	SearchType  string          `json:"search_type"`
	ResultCount int32           `json:"result_count"`
	Filters     json.RawMessage `json:"filters"`
}

func (q *Queries) CreateSearchLog(ctx context.Context, arg CreateSearchLogParams) (SearchLog, error) {
	row := q.db.QueryRow(ctx, createSearchLog,
		arg.TenantID,
		arg.UserID,
		arg.Query,
		arg.SearchType,
		arg.ResultCount,
		arg.Filters,
	)
	var i SearchLog
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.Query,
		&i.SearchType,
		&i.ResultCount,
		&i.Filters,
		&i.CreatedAt,
	)
	return i, err
}

const debitUserWallet = `-- name: DebitUserWallet :exec
UPDATE users SET wallet_balance = wallet_balance - $2
WHERE id = $1 AND deleted_at IS NULL AND wallet_balance >= $2
`

type DebitUserWalletParams struct {
	ID     uuid.UUID      `json:"id"`
	Amount pgtype.Numeric `json:"amount"`
}

func (q *Queries) DebitUserWallet(ctx context.Context, arg DebitUserWalletParams) error {
	_, err := q.db.Exec(ctx, debitUserWallet, arg.ID, arg.Amount)
	return err
}

const getNotificationPreferences = `-- name: GetNotificationPreferences :one
SELECT id, user_id, tenant_id, push_enabled, sms_enabled, email_enabled, order_updates, promotions, system_alerts, invoice_alerts, created_at, updated_at FROM notification_preferences WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetNotificationPreferences(ctx context.Context, userID uuid.UUID) (NotificationPreference, error) {
	row := q.db.QueryRow(ctx, getNotificationPreferences, userID)
	var i NotificationPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TenantID,
		&i.PushEnabled,
		&i.SmsEnabled,
		&i.EmailEnabled,
		&i.OrderUpdates,
		&i.Promotions,
		&i.SystemAlerts,
		&i.InvoiceAlerts,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopSearchTerms = `-- name: GetTopSearchTerms :many
SELECT query, COUNT(*)::INT AS search_count
FROM search_logs
WHERE tenant_id = $1 AND created_at >= $3::timestamptz
GROUP BY query
ORDER BY search_count DESC
LIMIT $2
`

type GetTopSearchTermsParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Since    time.Time `json:"since"`
}

type GetTopSearchTermsRow struct {
	Query       string `json:"query"`
	SearchCount int32  `json:"search_count"`
}

func (q *Queries) GetTopSearchTerms(ctx context.Context, arg GetTopSearchTermsParams) ([]GetTopSearchTermsRow, error) {
	rows, err := q.db.Query(ctx, getTopSearchTerms, arg.TenantID, arg.Limit, arg.Since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopSearchTermsRow{}
	for rows.Next() {
		var i GetTopSearchTermsRow
		if err := rows.Scan(&i.Query, &i.SearchCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDevicePushToken = `-- name: GetUserDevicePushToken :one
SELECT device_push_token FROM users WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserDevicePushToken(ctx context.Context, id uuid.UUID) (sql.NullString, error) {
	row := q.db.QueryRow(ctx, getUserDevicePushToken, id)
	var device_push_token sql.NullString
	err := row.Scan(&device_push_token)
	return device_push_token, err
}

const getUserWalletBalance = `-- name: GetUserWalletBalance :one
SELECT wallet_balance FROM users WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserWalletBalance(ctx context.Context, id uuid.UUID) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getUserWalletBalance, id)
	var wallet_balance pgtype.Numeric
	err := row.Scan(&wallet_balance)
	return wallet_balance, err
}

const listAuditLogsByResource = `-- name: ListAuditLogsByResource :many
SELECT id, tenant_id, actor_id, actor_type, action, resource_type, resource_id, changes, reason, ip_address, created_at FROM audit_logs
WHERE resource_type = $1 AND resource_id = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsByResourceParams struct {
	ResourceType string      `json:"resource_type"`
	ResourceID   pgtype.UUID `json:"resource_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

func (q *Queries) ListAuditLogsByResource(ctx context.Context, arg ListAuditLogsByResourceParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByResource,
		arg.ResourceType,
		arg.ResourceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ActorID,
			&i.ActorType,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Changes,
			&i.Reason,
			&i.IpAddress,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCreatedOrdersPastTimeout = `-- name: ListCreatedOrdersPastTimeout :many
SELECT id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE status = 'created'
  AND auto_confirm_at IS NOT NULL
  AND auto_confirm_at < NOW()
  AND deleted_at IS NULL
LIMIT $1
`

func (q *Queries) ListCreatedOrdersPastTimeout(ctx context.Context, limit int32) ([]Order, error) {
	rows, err := q.db.Query(ctx, listCreatedOrdersPastTimeout, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.RiderID,
			&i.HubID,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Platform,
			&i.DeliveryAddressID,
			&i.DeliveryAddress,
			&i.DeliveryRecipientName,
			&i.DeliveryRecipientPhone,
			&i.DeliveryArea,
			&i.DeliveryGeoLat,
			&i.DeliveryGeoLng,
			&i.Subtotal,
			&i.ItemDiscountTotal,
			&i.PromoDiscountTotal,
			&i.VatTotal,
			&i.DeliveryCharge,
			&i.ServiceFee,
			&i.TotalAmount,
			&i.PromoID,
			&i.PromoCode,
			&i.PromoSnapshot,
			&i.IsPriority,
			&i.IsReorder,
			&i.CustomerNote,
			&i.RiderNote,
			&i.InternalNote,
			&i.CancellationReason,
			&i.CancelledBy,
			&i.RejectionReason,
			&i.RejectedBy,
			&i.AutoConfirmAt,
			&i.EstimatedDeliveryMinutes,
			&i.ConfirmedAt,
			&i.PreparingAt,
			&i.ReadyAt,
			&i.PickedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderIssueMessages = `-- name: ListOrderIssueMessages :many
SELECT id, issue_id, tenant_id, sender_id, message, attachments, created_at FROM order_issue_messages
WHERE issue_id = $1 AND tenant_id = $2
ORDER BY created_at ASC
`

type ListOrderIssueMessagesParams struct {
	IssueID  uuid.UUID `json:"issue_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ListOrderIssueMessages(ctx context.Context, arg ListOrderIssueMessagesParams) ([]OrderIssueMessage, error) {
	rows, err := q.db.Query(ctx, listOrderIssueMessages, arg.IssueID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderIssueMessage{}
	for rows.Next() {
		var i OrderIssueMessage
		if err := rows.Scan(
			&i.ID,
			&i.IssueID,
			&i.TenantID,
			&i.SenderID,
			&i.Message,
			&i.Attachments,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderIssuesByOrder = `-- name: ListOrderIssuesByOrder :many
SELECT id, order_id, tenant_id, issue_type, reported_by_id, details, evidence_urls, accountable_party, refund_items, refund_amount, refund_status, restaurant_penalty_amount, rider_penalty_amount, status, resolution_note, resolved_by_id, resolved_at, created_at, updated_at FROM order_issues
WHERE order_id = $1 AND tenant_id = $2
ORDER BY created_at DESC
`

type ListOrderIssuesByOrderParams struct {
	OrderID  uuid.UUID `json:"order_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ListOrderIssuesByOrder(ctx context.Context, arg ListOrderIssuesByOrderParams) ([]OrderIssue, error) {
	rows, err := q.db.Query(ctx, listOrderIssuesByOrder, arg.OrderID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderIssue{}
	for rows.Next() {
		var i OrderIssue
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.TenantID,
			&i.IssueType,
			&i.ReportedByID,
			&i.Details,
			&i.EvidenceUrls,
			&i.AccountableParty,
			&i.RefundItems,
			&i.RefundAmount,
			&i.RefundStatus,
			&i.RestaurantPenaltyAmount,
			&i.RiderPenaltyAmount,
			&i.Status,
			&i.ResolutionNote,
			&i.ResolvedByID,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderIssuesByTenant = `-- name: ListOrderIssuesByTenant :many
SELECT id, order_id, tenant_id, issue_type, reported_by_id, details, evidence_urls, accountable_party, refund_items, refund_amount, refund_status, restaurant_penalty_amount, rider_penalty_amount, status, resolution_note, resolved_by_id, resolved_at, created_at, updated_at FROM order_issues
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrderIssuesByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListOrderIssuesByTenant(ctx context.Context, arg ListOrderIssuesByTenantParams) ([]OrderIssue, error) {
	rows, err := q.db.Query(ctx, listOrderIssuesByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderIssue{}
	for rows.Next() {
		var i OrderIssue
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.TenantID,
			&i.IssueType,
			&i.ReportedByID,
			&i.Details,
			&i.EvidenceUrls,
			&i.AccountableParty,
			&i.RefundItems,
			&i.RefundAmount,
			&i.RefundStatus,
			&i.RestaurantPenaltyAmount,
			&i.RiderPenaltyAmount,
			&i.Status,
			&i.ResolutionNote,
			&i.ResolvedByID,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByStatus = `-- name: ListOrdersByStatus :many
SELECT id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE tenant_id = $1 AND status = $4::order_status AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersByStatusParams struct {
	TenantID    uuid.UUID   `json:"tenant_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	OrderStatus OrderStatus `json:"order_status"`
}

func (q *Queries) ListOrdersByStatus(ctx context.Context, arg ListOrdersByStatusParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByStatus,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
		arg.OrderStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.RiderID,
			&i.HubID,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Platform,
			&i.DeliveryAddressID,
			&i.DeliveryAddress,
			&i.DeliveryRecipientName,
			&i.DeliveryRecipientPhone,
			&i.DeliveryArea,
			&i.DeliveryGeoLat,
			&i.DeliveryGeoLng,
			&i.Subtotal,
			&i.ItemDiscountTotal,
			&i.PromoDiscountTotal,
			&i.VatTotal,
			&i.DeliveryCharge,
			&i.ServiceFee,
			&i.TotalAmount,
			&i.PromoID,
			&i.PromoCode,
			&i.PromoSnapshot,
			&i.IsPriority,
			&i.IsReorder,
			&i.CustomerNote,
			&i.RiderNote,
			&i.InternalNote,
			&i.CancellationReason,
			&i.CancelledBy,
			&i.RejectionReason,
			&i.RejectedBy,
			&i.AutoConfirmAt,
			&i.EstimatedDeliveryMinutes,
			&i.ConfirmedAt,
			&i.PreparingAt,
			&i.ReadyAt,
			&i.PickedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingOrdersPastTimeout = `-- name: ListPendingOrdersPastTimeout :many
SELECT id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE status = 'pending'
  AND created_at < $2::timestamptz
  AND deleted_at IS NULL
LIMIT $1
`

type ListPendingOrdersPastTimeoutParams struct {
	Limit     int32     `json:"limit"`
	OlderThan time.Time `json:"older_than"`
}

func (q *Queries) ListPendingOrdersPastTimeout(ctx context.Context, arg ListPendingOrdersPastTimeoutParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listPendingOrdersPastTimeout, arg.Limit, arg.OlderThan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.RiderID,
			&i.HubID,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Platform,
			&i.DeliveryAddressID,
			&i.DeliveryAddress,
			&i.DeliveryRecipientName,
			&i.DeliveryRecipientPhone,
			&i.DeliveryArea,
			&i.DeliveryGeoLat,
			&i.DeliveryGeoLng,
			&i.Subtotal,
			&i.ItemDiscountTotal,
			&i.PromoDiscountTotal,
			&i.VatTotal,
			&i.DeliveryCharge,
			&i.ServiceFee,
			&i.TotalAmount,
			&i.PromoID,
			&i.PromoCode,
			&i.PromoSnapshot,
			&i.IsPriority,
			&i.IsReorder,
			&i.CustomerNote,
			&i.RiderNote,
			&i.InternalNote,
			&i.CancellationReason,
			&i.CancelledBy,
			&i.RejectionReason,
			&i.RejectedBy,
			&i.AutoConfirmAt,
			&i.EstimatedDeliveryMinutes,
			&i.ConfirmedAt,
			&i.PreparingAt,
			&i.ReadyAt,
			&i.PickedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingOutboxEvents = `-- name: ListPendingOutboxEvents :many
SELECT id, tenant_id, aggregate_type, aggregate_id, event_type, payload, status, attempts, max_attempts, next_retry_at, last_error, processed_at, created_at FROM outbox_events
WHERE status IN ('pending', 'failed')
  AND (next_retry_at IS NULL OR next_retry_at <= NOW())
  AND attempts < max_attempts
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) ListPendingOutboxEvents(ctx context.Context, limit int32) ([]OutboxEvent, error) {
	rows, err := q.db.Query(ctx, listPendingOutboxEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OutboxEvent{}
	for rows.Next() {
		var i OutboxEvent
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.AggregateType,
			&i.AggregateID,
			&i.EventType,
			&i.Payload,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.NextRetryAt,
			&i.LastError,
			&i.ProcessedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOutboxEventFailed = `-- name: MarkOutboxEventFailed :exec
UPDATE outbox_events SET
    status = CASE WHEN attempts + 1 >= max_attempts THEN 'dead_letter'::outbox_event_status ELSE 'failed'::outbox_event_status END,
    attempts = attempts + 1,
    last_error = $2,
    next_retry_at = NOW() + (POWER(2, attempts + 1) || ' minutes')::interval
WHERE id = $1
`

type MarkOutboxEventFailedParams struct {
	ID        uuid.UUID      `json:"id"`
	LastError sql.NullString `json:"last_error"`
}

func (q *Queries) MarkOutboxEventFailed(ctx context.Context, arg MarkOutboxEventFailedParams) error {
	_, err := q.db.Exec(ctx, markOutboxEventFailed, arg.ID, arg.LastError)
	return err
}

const markOutboxEventProcessed = `-- name: MarkOutboxEventProcessed :exec
UPDATE outbox_events SET status = 'processed', processed_at = NOW(), attempts = attempts + 1
WHERE id = $1
`

func (q *Queries) MarkOutboxEventProcessed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markOutboxEventProcessed, id)
	return err
}

const purgeOldAuditLogs = `-- name: PurgeOldAuditLogs :exec
DELETE FROM audit_logs WHERE created_at < $1::timestamptz
`

func (q *Queries) PurgeOldAuditLogs(ctx context.Context, before time.Time) error {
	_, err := q.db.Exec(ctx, purgeOldAuditLogs, before)
	return err
}

const purgeOldNotifications = `-- name: PurgeOldNotifications :exec
DELETE FROM notifications WHERE created_at < $1::timestamptz
`

func (q *Queries) PurgeOldNotifications(ctx context.Context, before time.Time) error {
	_, err := q.db.Exec(ctx, purgeOldNotifications, before)
	return err
}

const purgeOldOrderTimeline = `-- name: PurgeOldOrderTimeline :exec
DELETE FROM order_timeline_events WHERE created_at < $1::timestamptz
`

func (q *Queries) PurgeOldOrderTimeline(ctx context.Context, before time.Time) error {
	_, err := q.db.Exec(ctx, purgeOldOrderTimeline, before)
	return err
}

const purgeOldSearchLogs = `-- name: PurgeOldSearchLogs :exec
DELETE FROM search_logs WHERE created_at < $1::timestamptz
`

func (q *Queries) PurgeOldSearchLogs(ctx context.Context, before time.Time) error {
	_, err := q.db.Exec(ctx, purgeOldSearchLogs, before)
	return err
}

const searchProducts = `-- name: SearchProducts :many
SELECT p.id, p.tenant_id, p.restaurant_id, p.category_id, p.name, p.slug, p.description, p.base_price, p.vat_rate, p.has_modifiers, p.availability, p.images, p.tags, p.is_featured, p.is_inv_tracked, p.sort_order, p.meta_title, p.meta_description, p.rating_avg, p.rating_count, p.order_count, p.created_at, p.updated_at FROM products p
JOIN restaurants r ON p.restaurant_id = r.id
WHERE p.tenant_id = $1
  AND p.deleted_at IS NULL
  AND p.availability = 'available'
  AND r.is_active = true
  AND r.deleted_at IS NULL
  AND (p.name ILIKE '%' || $3::text || '%' OR p.description ILIKE '%' || $3::text || '%')
ORDER BY p.name ASC
LIMIT $2
`

type SearchProductsParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Query    string    `json:"query"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, searchProducts, arg.TenantID, arg.Limit, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RestaurantID,
			&i.CategoryID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.BasePrice,
			&i.VatRate,
			&i.HasModifiers,
			&i.Availability,
			&i.Images,
			&i.Tags,
			&i.IsFeatured,
			&i.IsInvTracked,
			&i.SortOrder,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.RatingAvg,
			&i.RatingCount,
			&i.OrderCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRestaurants = `-- name: SearchRestaurants :many
SELECT id, tenant_id, hub_id, owner_id, name, slug, type, description, short_description, banner_image_url, logo_url, gallery_urls, phone, email, address_line1, address_line2, area, city, geo_lat, geo_lng, cuisines, tags, commission_rate, vat_rate, is_vat_inclusive, min_order_amount, avg_prep_time_minutes, max_concurrent_orders, auto_accept_orders, order_prefix, order_sequence, is_available, is_featured, is_active, sort_order, meta_title, meta_description, meta_keywords, rating_avg, rating_count, total_order_count, created_at, updated_at FROM restaurants
WHERE tenant_id = $1
  AND deleted_at IS NULL
  AND is_active = true
  AND (name ILIKE '%' || $3::text || '%' OR description ILIKE '%' || $3::text || '%')
ORDER BY name ASC
LIMIT $2
`

type SearchRestaurantsParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Query    string    `json:"query"`
}

func (q *Queries) SearchRestaurants(ctx context.Context, arg SearchRestaurantsParams) ([]Restaurant, error) {
	rows, err := q.db.Query(ctx, searchRestaurants, arg.TenantID, arg.Limit, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Restaurant{}
	for rows.Next() {
		var i Restaurant
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.HubID,
			&i.OwnerID,
			&i.Name,
			&i.Slug,
			&i.Type,
			&i.Description,
			&i.ShortDescription,
			&i.BannerImageUrl,
			&i.LogoUrl,
			&i.GalleryUrls,
			&i.Phone,
			&i.Email,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.Area,
			&i.City,
			&i.GeoLat,
			&i.GeoLng,
			&i.Cuisines,
			&i.Tags,
			&i.CommissionRate,
			&i.VatRate,
			&i.IsVatInclusive,
			&i.MinOrderAmount,
			&i.AvgPrepTimeMinutes,
			&i.MaxConcurrentOrders,
			&i.AutoAcceptOrders,
			&i.OrderPrefix,
			&i.OrderSequence,
			&i.IsAvailable,
			&i.IsFeatured,
			&i.IsActive,
			&i.SortOrder,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.RatingAvg,
			&i.RatingCount,
			&i.TotalOrderCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderIssueRefund = `-- name: UpdateOrderIssueRefund :one
UPDATE order_issues SET refund_status = $3, refund_amount = $4
WHERE id = $1 AND tenant_id = $2
RETURNING id, order_id, tenant_id, issue_type, reported_by_id, details, evidence_urls, accountable_party, refund_items, refund_amount, refund_status, restaurant_penalty_amount, rider_penalty_amount, status, resolution_note, resolved_by_id, resolved_at, created_at, updated_at
`

type UpdateOrderIssueRefundParams struct {
	ID           uuid.UUID      `json:"id"`
	TenantID     uuid.UUID      `json:"tenant_id"`
	RefundStatus RefundStatus   `json:"refund_status"`
	RefundAmount pgtype.Numeric `json:"refund_amount"`
}

func (q *Queries) UpdateOrderIssueRefund(ctx context.Context, arg UpdateOrderIssueRefundParams) (OrderIssue, error) {
	row := q.db.QueryRow(ctx, updateOrderIssueRefund,
		arg.ID,
		arg.TenantID,
		arg.RefundStatus,
		arg.RefundAmount,
	)
	var i OrderIssue
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.TenantID,
		&i.IssueType,
		&i.ReportedByID,
		&i.Details,
		&i.EvidenceUrls,
		&i.AccountableParty,
		&i.RefundItems,
		&i.RefundAmount,
		&i.RefundStatus,
		&i.RestaurantPenaltyAmount,
		&i.RiderPenaltyAmount,
		&i.Status,
		&i.ResolutionNote,
		&i.ResolvedByID,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrderIssueStatus = `-- name: UpdateOrderIssueStatus :one
UPDATE order_issues SET status = $3, resolution_note = $4, resolved_by_id = $5, resolved_at = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, order_id, tenant_id, issue_type, reported_by_id, details, evidence_urls, accountable_party, refund_items, refund_amount, refund_status, restaurant_penalty_amount, rider_penalty_amount, status, resolution_note, resolved_by_id, resolved_at, created_at, updated_at
`

type UpdateOrderIssueStatusParams struct {
	ID             uuid.UUID      `json:"id"`
	TenantID       uuid.UUID      `json:"tenant_id"`
	Status         IssueStatus    `json:"status"`
	ResolutionNote sql.NullString `json:"resolution_note"`
	ResolvedByID   pgtype.UUID    `json:"resolved_by_id"`
}

func (q *Queries) UpdateOrderIssueStatus(ctx context.Context, arg UpdateOrderIssueStatusParams) (OrderIssue, error) {
	row := q.db.QueryRow(ctx, updateOrderIssueStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.ResolutionNote,
		arg.ResolvedByID,
	)
	var i OrderIssue
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.TenantID,
		&i.IssueType,
		&i.ReportedByID,
		&i.Details,
		&i.EvidenceUrls,
		&i.AccountableParty,
		&i.RefundItems,
		&i.RefundAmount,
		&i.RefundStatus,
		&i.RestaurantPenaltyAmount,
		&i.RiderPenaltyAmount,
		&i.Status,
		&i.ResolutionNote,
		&i.ResolvedByID,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
