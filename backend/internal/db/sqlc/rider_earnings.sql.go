// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rider_earnings.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createRiderEarning = `-- name: CreateRiderEarning :one
INSERT INTO rider_earnings (rider_id, tenant_id, order_id, base_earning, distance_bonus, peak_bonus, tip_amount, total_earning)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, rider_id, tenant_id, order_id, base_earning, distance_bonus, peak_bonus, tip_amount, total_earning, is_paid_out, payout_id, created_at
`

type CreateRiderEarningParams struct {
	RiderID       uuid.UUID      `json:"rider_id"`
	TenantID      uuid.UUID      `json:"tenant_id"`
	OrderID       uuid.UUID      `json:"order_id"`
	BaseEarning   pgtype.Numeric `json:"base_earning"`
	DistanceBonus pgtype.Numeric `json:"distance_bonus"`
	PeakBonus     pgtype.Numeric `json:"peak_bonus"`
	TipAmount     pgtype.Numeric `json:"tip_amount"`
	TotalEarning  pgtype.Numeric `json:"total_earning"`
}

func (q *Queries) CreateRiderEarning(ctx context.Context, arg CreateRiderEarningParams) (RiderEarning, error) {
	row := q.db.QueryRow(ctx, createRiderEarning,
		arg.RiderID,
		arg.TenantID,
		arg.OrderID,
		arg.BaseEarning,
		arg.DistanceBonus,
		arg.PeakBonus,
		arg.TipAmount,
		arg.TotalEarning,
	)
	var i RiderEarning
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.TenantID,
		&i.OrderID,
		&i.BaseEarning,
		&i.DistanceBonus,
		&i.PeakBonus,
		&i.TipAmount,
		&i.TotalEarning,
		&i.IsPaidOut,
		&i.PayoutID,
		&i.CreatedAt,
	)
	return i, err
}

const getTotalEarningsByRider = `-- name: GetTotalEarningsByRider :one
SELECT COALESCE(SUM(total_earning), 0)::NUMERIC(10,2) AS total
FROM rider_earnings
WHERE rider_id = $1 AND is_paid_out = false
`

func (q *Queries) GetTotalEarningsByRider(ctx context.Context, riderID uuid.UUID) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getTotalEarningsByRider, riderID)
	var total pgtype.Numeric
	err := row.Scan(&total)
	return total, err
}

const listEarningsByOrder = `-- name: ListEarningsByOrder :many
SELECT id, rider_id, tenant_id, order_id, base_earning, distance_bonus, peak_bonus, tip_amount, total_earning, is_paid_out, payout_id, created_at FROM rider_earnings WHERE order_id = $1 AND tenant_id = $2
`

type ListEarningsByOrderParams struct {
	OrderID  uuid.UUID `json:"order_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ListEarningsByOrder(ctx context.Context, arg ListEarningsByOrderParams) ([]RiderEarning, error) {
	rows, err := q.db.Query(ctx, listEarningsByOrder, arg.OrderID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiderEarning{}
	for rows.Next() {
		var i RiderEarning
		if err := rows.Scan(
			&i.ID,
			&i.RiderID,
			&i.TenantID,
			&i.OrderID,
			&i.BaseEarning,
			&i.DistanceBonus,
			&i.PeakBonus,
			&i.TipAmount,
			&i.TotalEarning,
			&i.IsPaidOut,
			&i.PayoutID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEarningsByRider = `-- name: ListEarningsByRider :many
SELECT id, rider_id, tenant_id, order_id, base_earning, distance_bonus, peak_bonus, tip_amount, total_earning, is_paid_out, payout_id, created_at FROM rider_earnings
WHERE rider_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListEarningsByRiderParams struct {
	RiderID uuid.UUID `json:"rider_id"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) ListEarningsByRider(ctx context.Context, arg ListEarningsByRiderParams) ([]RiderEarning, error) {
	rows, err := q.db.Query(ctx, listEarningsByRider, arg.RiderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiderEarning{}
	for rows.Next() {
		var i RiderEarning
		if err := rows.Scan(
			&i.ID,
			&i.RiderID,
			&i.TenantID,
			&i.OrderID,
			&i.BaseEarning,
			&i.DistanceBonus,
			&i.PeakBonus,
			&i.TipAmount,
			&i.TotalEarning,
			&i.IsPaidOut,
			&i.PayoutID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
