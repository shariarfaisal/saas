// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addTimelineEvent = `-- name: AddTimelineEvent :one
INSERT INTO order_timeline_events (
    order_id, tenant_id, event_type, previous_status,
    new_status, description, actor_id, actor_type, metadata
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, order_id, tenant_id, event_type, previous_status, new_status, description, actor_id, actor_type, metadata, created_at
`

type AddTimelineEventParams struct {
	OrderID        uuid.UUID       `json:"order_id"`
	TenantID       uuid.UUID       `json:"tenant_id"`
	EventType      string          `json:"event_type"`
	PreviousStatus NullOrderStatus `json:"previous_status"`
	NewStatus      NullOrderStatus `json:"new_status"`
	Description    string          `json:"description"`
	ActorID        pgtype.UUID     `json:"actor_id"`
	ActorType      ActorType       `json:"actor_type"`
	Metadata       json.RawMessage `json:"metadata"`
}

func (q *Queries) AddTimelineEvent(ctx context.Context, arg AddTimelineEventParams) (OrderTimelineEvent, error) {
	row := q.db.QueryRow(ctx, addTimelineEvent,
		arg.OrderID,
		arg.TenantID,
		arg.EventType,
		arg.PreviousStatus,
		arg.NewStatus,
		arg.Description,
		arg.ActorID,
		arg.ActorType,
		arg.Metadata,
	)
	var i OrderTimelineEvent
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.TenantID,
		&i.EventType,
		&i.PreviousStatus,
		&i.NewStatus,
		&i.Description,
		&i.ActorID,
		&i.ActorType,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const checkAllPickupsInStatus = `-- name: CheckAllPickupsInStatus :one
SELECT COUNT(*) = 0 AS all_in_status
FROM order_pickups
WHERE order_id = $1
  AND status != $2
`

type CheckAllPickupsInStatusParams struct {
	OrderID        uuid.UUID    `json:"order_id"`
	ExpectedStatus PickupStatus `json:"expected_status"`
}

func (q *Queries) CheckAllPickupsInStatus(ctx context.Context, arg CheckAllPickupsInStatusParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAllPickupsInStatus, arg.OrderID, arg.ExpectedStatus)
	var all_in_status bool
	err := row.Scan(&all_in_status)
	return all_in_status, err
}

const countOrdersByCustomer = `-- name: CountOrdersByCustomer :one
SELECT COUNT(*) FROM orders
WHERE customer_id = $1 AND tenant_id = $2 AND deleted_at IS NULL
`

type CountOrdersByCustomerParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
}

func (q *Queries) CountOrdersByCustomer(ctx context.Context, arg CountOrdersByCustomerParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByCustomer, arg.CustomerID, arg.TenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByRestaurant = `-- name: CountOrdersByRestaurant :one
SELECT COUNT(DISTINCT o.id) FROM orders o
JOIN order_pickups op ON o.id = op.order_id
WHERE op.restaurant_id = $1 AND o.tenant_id = $2 AND o.deleted_at IS NULL
`

type CountOrdersByRestaurantParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
}

func (q *Queries) CountOrdersByRestaurant(ctx context.Context, arg CountOrdersByRestaurantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByRestaurant, arg.RestaurantID, arg.TenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByTenant = `-- name: CountOrdersByTenant :one
SELECT COUNT(*) FROM orders
WHERE tenant_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountOrdersByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countOrdersByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one

INSERT INTO orders (
    tenant_id, order_number, customer_id, status, payment_status,
    payment_method, platform, delivery_address_id, delivery_address,
    delivery_recipient_name, delivery_recipient_phone, delivery_area,
    delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total,
    promo_discount_total, vat_total, delivery_charge, service_fee,
    total_amount, promo_id, promo_code, promo_snapshot,
    is_priority, is_reorder, customer_note, auto_confirm_at,
    estimated_delivery_minutes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
    $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29
)
RETURNING id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at
`

type CreateOrderParams struct {
	TenantID                 uuid.UUID          `json:"tenant_id"`
	OrderNumber              string             `json:"order_number"`
	CustomerID               uuid.UUID          `json:"customer_id"`
	Status                   OrderStatus        `json:"status"`
	PaymentStatus            PaymentStatus      `json:"payment_status"`
	PaymentMethod            PaymentMethod      `json:"payment_method"`
	Platform                 PlatformSource     `json:"platform"`
	DeliveryAddressID        pgtype.UUID        `json:"delivery_address_id"`
	DeliveryAddress          json.RawMessage    `json:"delivery_address"`
	DeliveryRecipientName    string             `json:"delivery_recipient_name"`
	DeliveryRecipientPhone   string             `json:"delivery_recipient_phone"`
	DeliveryArea             string             `json:"delivery_area"`
	DeliveryGeoLat           pgtype.Numeric     `json:"delivery_geo_lat"`
	DeliveryGeoLng           pgtype.Numeric     `json:"delivery_geo_lng"`
	Subtotal                 pgtype.Numeric     `json:"subtotal"`
	ItemDiscountTotal        pgtype.Numeric     `json:"item_discount_total"`
	PromoDiscountTotal       pgtype.Numeric     `json:"promo_discount_total"`
	VatTotal                 pgtype.Numeric     `json:"vat_total"`
	DeliveryCharge           pgtype.Numeric     `json:"delivery_charge"`
	ServiceFee               pgtype.Numeric     `json:"service_fee"`
	TotalAmount              pgtype.Numeric     `json:"total_amount"`
	PromoID                  pgtype.UUID        `json:"promo_id"`
	PromoCode                sql.NullString     `json:"promo_code"`
	PromoSnapshot            []byte             `json:"promo_snapshot"`
	IsPriority               bool               `json:"is_priority"`
	IsReorder                bool               `json:"is_reorder"`
	CustomerNote             sql.NullString     `json:"customer_note"`
	AutoConfirmAt            pgtype.Timestamptz `json:"auto_confirm_at"`
	EstimatedDeliveryMinutes *int32             `json:"estimated_delivery_minutes"`
}

// ============================================================
// Orders SQLC Queries
// ============================================================
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.TenantID,
		arg.OrderNumber,
		arg.CustomerID,
		arg.Status,
		arg.PaymentStatus,
		arg.PaymentMethod,
		arg.Platform,
		arg.DeliveryAddressID,
		arg.DeliveryAddress,
		arg.DeliveryRecipientName,
		arg.DeliveryRecipientPhone,
		arg.DeliveryArea,
		arg.DeliveryGeoLat,
		arg.DeliveryGeoLng,
		arg.Subtotal,
		arg.ItemDiscountTotal,
		arg.PromoDiscountTotal,
		arg.VatTotal,
		arg.DeliveryCharge,
		arg.ServiceFee,
		arg.TotalAmount,
		arg.PromoID,
		arg.PromoCode,
		arg.PromoSnapshot,
		arg.IsPriority,
		arg.IsReorder,
		arg.CustomerNote,
		arg.AutoConfirmAt,
		arg.EstimatedDeliveryMinutes,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.RiderID,
		&i.HubID,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Platform,
		&i.DeliveryAddressID,
		&i.DeliveryAddress,
		&i.DeliveryRecipientName,
		&i.DeliveryRecipientPhone,
		&i.DeliveryArea,
		&i.DeliveryGeoLat,
		&i.DeliveryGeoLng,
		&i.Subtotal,
		&i.ItemDiscountTotal,
		&i.PromoDiscountTotal,
		&i.VatTotal,
		&i.DeliveryCharge,
		&i.ServiceFee,
		&i.TotalAmount,
		&i.PromoID,
		&i.PromoCode,
		&i.PromoSnapshot,
		&i.IsPriority,
		&i.IsReorder,
		&i.CustomerNote,
		&i.RiderNote,
		&i.InternalNote,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.RejectionReason,
		&i.RejectedBy,
		&i.AutoConfirmAt,
		&i.EstimatedDeliveryMinutes,
		&i.ConfirmedAt,
		&i.PreparingAt,
		&i.ReadyAt,
		&i.PickedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (
    order_id, restaurant_id, product_id, tenant_id, product_name,
    product_snapshot, quantity, unit_price, modifier_price,
    item_subtotal, item_discount, item_vat, promo_discount,
    item_total, selected_modifiers, special_instructions
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, order_id, restaurant_id, product_id, tenant_id, product_name, product_snapshot, quantity, unit_price, modifier_price, item_subtotal, item_discount, item_vat, promo_discount, item_total, selected_modifiers, special_instructions, created_at
`

type CreateOrderItemParams struct {
	OrderID             uuid.UUID       `json:"order_id"`
	RestaurantID        uuid.UUID       `json:"restaurant_id"`
	ProductID           uuid.UUID       `json:"product_id"`
	TenantID            uuid.UUID       `json:"tenant_id"`
	ProductName         string          `json:"product_name"`
	ProductSnapshot     json.RawMessage `json:"product_snapshot"`
	Quantity            int32           `json:"quantity"`
	UnitPrice           pgtype.Numeric  `json:"unit_price"`
	ModifierPrice       pgtype.Numeric  `json:"modifier_price"`
	ItemSubtotal        pgtype.Numeric  `json:"item_subtotal"`
	ItemDiscount        pgtype.Numeric  `json:"item_discount"`
	ItemVat             pgtype.Numeric  `json:"item_vat"`
	PromoDiscount       pgtype.Numeric  `json:"promo_discount"`
	ItemTotal           pgtype.Numeric  `json:"item_total"`
	SelectedModifiers   json.RawMessage `json:"selected_modifiers"`
	SpecialInstructions sql.NullString  `json:"special_instructions"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.RestaurantID,
		arg.ProductID,
		arg.TenantID,
		arg.ProductName,
		arg.ProductSnapshot,
		arg.Quantity,
		arg.UnitPrice,
		arg.ModifierPrice,
		arg.ItemSubtotal,
		arg.ItemDiscount,
		arg.ItemVat,
		arg.PromoDiscount,
		arg.ItemTotal,
		arg.SelectedModifiers,
		arg.SpecialInstructions,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.RestaurantID,
		&i.ProductID,
		&i.TenantID,
		&i.ProductName,
		&i.ProductSnapshot,
		&i.Quantity,
		&i.UnitPrice,
		&i.ModifierPrice,
		&i.ItemSubtotal,
		&i.ItemDiscount,
		&i.ItemVat,
		&i.PromoDiscount,
		&i.ItemTotal,
		&i.SelectedModifiers,
		&i.SpecialInstructions,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderPickup = `-- name: CreateOrderPickup :one
INSERT INTO order_pickups (
    order_id, restaurant_id, tenant_id, pickup_number, status,
    items_subtotal, items_discount, items_vat, items_total,
    commission_rate, commission_amount
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, order_id, restaurant_id, tenant_id, pickup_number, status, items_subtotal, items_discount, items_vat, items_total, commission_rate, commission_amount, confirmed_at, preparing_at, ready_at, picked_at, rejected_at, rejection_reason, created_at, updated_at
`

type CreateOrderPickupParams struct {
	OrderID          uuid.UUID      `json:"order_id"`
	RestaurantID     uuid.UUID      `json:"restaurant_id"`
	TenantID         uuid.UUID      `json:"tenant_id"`
	PickupNumber     string         `json:"pickup_number"`
	Status           PickupStatus   `json:"status"`
	ItemsSubtotal    pgtype.Numeric `json:"items_subtotal"`
	ItemsDiscount    pgtype.Numeric `json:"items_discount"`
	ItemsVat         pgtype.Numeric `json:"items_vat"`
	ItemsTotal       pgtype.Numeric `json:"items_total"`
	CommissionRate   pgtype.Numeric `json:"commission_rate"`
	CommissionAmount pgtype.Numeric `json:"commission_amount"`
}

func (q *Queries) CreateOrderPickup(ctx context.Context, arg CreateOrderPickupParams) (OrderPickup, error) {
	row := q.db.QueryRow(ctx, createOrderPickup,
		arg.OrderID,
		arg.RestaurantID,
		arg.TenantID,
		arg.PickupNumber,
		arg.Status,
		arg.ItemsSubtotal,
		arg.ItemsDiscount,
		arg.ItemsVat,
		arg.ItemsTotal,
		arg.CommissionRate,
		arg.CommissionAmount,
	)
	var i OrderPickup
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.RestaurantID,
		&i.TenantID,
		&i.PickupNumber,
		&i.Status,
		&i.ItemsSubtotal,
		&i.ItemsDiscount,
		&i.ItemsVat,
		&i.ItemsTotal,
		&i.CommissionRate,
		&i.CommissionAmount,
		&i.ConfirmedAt,
		&i.PreparingAt,
		&i.ReadyAt,
		&i.PickedAt,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOutboxEvent = `-- name: CreateOutboxEvent :one
INSERT INTO outbox_events (
    tenant_id, aggregate_type, aggregate_id, event_type,
    payload, status, max_attempts
) VALUES ($1, $2, $3, $4, $5, 'pending', $6)
RETURNING id, tenant_id, aggregate_type, aggregate_id, event_type, payload, status, attempts, max_attempts, next_retry_at, last_error, processed_at, created_at
`

type CreateOutboxEventParams struct {
	TenantID      pgtype.UUID     `json:"tenant_id"`
	AggregateType string          `json:"aggregate_type"`
	AggregateID   uuid.UUID       `json:"aggregate_id"`
	EventType     string          `json:"event_type"`
	Payload       json.RawMessage `json:"payload"`
	MaxAttempts   int32           `json:"max_attempts"`
}

func (q *Queries) CreateOutboxEvent(ctx context.Context, arg CreateOutboxEventParams) (OutboxEvent, error) {
	row := q.db.QueryRow(ctx, createOutboxEvent,
		arg.TenantID,
		arg.AggregateType,
		arg.AggregateID,
		arg.EventType,
		arg.Payload,
		arg.MaxAttempts,
	)
	var i OutboxEvent
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.AggregateType,
		&i.AggregateID,
		&i.EventType,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.NextRetryAt,
		&i.LastError,
		&i.ProcessedAt,
		&i.CreatedAt,
	)
	return i, err
}

const generateOrderNumber = `-- name: GenerateOrderNumber :one
SELECT CONCAT(
    $1::TEXT, '-',
    LPAD((COALESCE(
        (SELECT COUNT(*) + 1 FROM orders WHERE tenant_id = $2),
        1
    ))::TEXT, 6, '0')
) AS order_number
`

type GenerateOrderNumberParams struct {
	Prefix   string    `json:"prefix"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GenerateOrderNumber(ctx context.Context, arg GenerateOrderNumberParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, generateOrderNumber, arg.Prefix, arg.TenantID)
	var order_number interface{}
	err := row.Scan(&order_number)
	return order_number, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE id = $1 AND tenant_id = $2 AND deleted_at IS NULL
`

type GetOrderByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetOrderByID(ctx context.Context, arg GetOrderByIDParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, arg.ID, arg.TenantID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.RiderID,
		&i.HubID,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Platform,
		&i.DeliveryAddressID,
		&i.DeliveryAddress,
		&i.DeliveryRecipientName,
		&i.DeliveryRecipientPhone,
		&i.DeliveryArea,
		&i.DeliveryGeoLat,
		&i.DeliveryGeoLng,
		&i.Subtotal,
		&i.ItemDiscountTotal,
		&i.PromoDiscountTotal,
		&i.VatTotal,
		&i.DeliveryCharge,
		&i.ServiceFee,
		&i.TotalAmount,
		&i.PromoID,
		&i.PromoCode,
		&i.PromoSnapshot,
		&i.IsPriority,
		&i.IsReorder,
		&i.CustomerNote,
		&i.RiderNote,
		&i.InternalNote,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.RejectionReason,
		&i.RejectedBy,
		&i.AutoConfirmAt,
		&i.EstimatedDeliveryMinutes,
		&i.ConfirmedAt,
		&i.PreparingAt,
		&i.ReadyAt,
		&i.PickedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrderByNumber = `-- name: GetOrderByNumber :one
SELECT id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE order_number = $1 AND tenant_id = $2 AND deleted_at IS NULL
`

type GetOrderByNumberParams struct {
	OrderNumber string    `json:"order_number"`
	TenantID    uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetOrderByNumber(ctx context.Context, arg GetOrderByNumberParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByNumber, arg.OrderNumber, arg.TenantID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.RiderID,
		&i.HubID,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Platform,
		&i.DeliveryAddressID,
		&i.DeliveryAddress,
		&i.DeliveryRecipientName,
		&i.DeliveryRecipientPhone,
		&i.DeliveryArea,
		&i.DeliveryGeoLat,
		&i.DeliveryGeoLng,
		&i.Subtotal,
		&i.ItemDiscountTotal,
		&i.PromoDiscountTotal,
		&i.VatTotal,
		&i.DeliveryCharge,
		&i.ServiceFee,
		&i.TotalAmount,
		&i.PromoID,
		&i.PromoCode,
		&i.PromoSnapshot,
		&i.IsPriority,
		&i.IsReorder,
		&i.CustomerNote,
		&i.RiderNote,
		&i.InternalNote,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.RejectionReason,
		&i.RejectedBy,
		&i.AutoConfirmAt,
		&i.EstimatedDeliveryMinutes,
		&i.ConfirmedAt,
		&i.PreparingAt,
		&i.ReadyAt,
		&i.PickedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrderForUpdate = `-- name: GetOrderForUpdate :one
SELECT id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE id = $1 AND tenant_id = $2 AND deleted_at IS NULL
FOR UPDATE
`

type GetOrderForUpdateParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetOrderForUpdate(ctx context.Context, arg GetOrderForUpdateParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderForUpdate, arg.ID, arg.TenantID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.RiderID,
		&i.HubID,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Platform,
		&i.DeliveryAddressID,
		&i.DeliveryAddress,
		&i.DeliveryRecipientName,
		&i.DeliveryRecipientPhone,
		&i.DeliveryArea,
		&i.DeliveryGeoLat,
		&i.DeliveryGeoLng,
		&i.Subtotal,
		&i.ItemDiscountTotal,
		&i.PromoDiscountTotal,
		&i.VatTotal,
		&i.DeliveryCharge,
		&i.ServiceFee,
		&i.TotalAmount,
		&i.PromoID,
		&i.PromoCode,
		&i.PromoSnapshot,
		&i.IsPriority,
		&i.IsReorder,
		&i.CustomerNote,
		&i.RiderNote,
		&i.InternalNote,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.RejectionReason,
		&i.RejectedBy,
		&i.AutoConfirmAt,
		&i.EstimatedDeliveryMinutes,
		&i.ConfirmedAt,
		&i.PreparingAt,
		&i.ReadyAt,
		&i.PickedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrderItemsByOrder = `-- name: GetOrderItemsByOrder :many
SELECT id, order_id, restaurant_id, product_id, tenant_id, product_name, product_snapshot, quantity, unit_price, modifier_price, item_subtotal, item_discount, item_vat, promo_discount, item_total, selected_modifiers, special_instructions, created_at FROM order_items
WHERE order_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetOrderItemsByOrder(ctx context.Context, orderID uuid.UUID) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByOrder, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.RestaurantID,
			&i.ProductID,
			&i.TenantID,
			&i.ProductName,
			&i.ProductSnapshot,
			&i.Quantity,
			&i.UnitPrice,
			&i.ModifierPrice,
			&i.ItemSubtotal,
			&i.ItemDiscount,
			&i.ItemVat,
			&i.PromoDiscount,
			&i.ItemTotal,
			&i.SelectedModifiers,
			&i.SpecialInstructions,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItemsByRestaurant = `-- name: GetOrderItemsByRestaurant :many
SELECT oi.id, oi.order_id, oi.restaurant_id, oi.product_id, oi.tenant_id, oi.product_name, oi.product_snapshot, oi.quantity, oi.unit_price, oi.modifier_price, oi.item_subtotal, oi.item_discount, oi.item_vat, oi.promo_discount, oi.item_total, oi.selected_modifiers, oi.special_instructions, oi.created_at FROM order_items oi
WHERE oi.order_id = $1 AND oi.restaurant_id = $2
ORDER BY oi.created_at ASC
`

type GetOrderItemsByRestaurantParams struct {
	OrderID      uuid.UUID `json:"order_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
}

func (q *Queries) GetOrderItemsByRestaurant(ctx context.Context, arg GetOrderItemsByRestaurantParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, getOrderItemsByRestaurant, arg.OrderID, arg.RestaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.RestaurantID,
			&i.ProductID,
			&i.TenantID,
			&i.ProductName,
			&i.ProductSnapshot,
			&i.Quantity,
			&i.UnitPrice,
			&i.ModifierPrice,
			&i.ItemSubtotal,
			&i.ItemDiscount,
			&i.ItemVat,
			&i.PromoDiscount,
			&i.ItemTotal,
			&i.SelectedModifiers,
			&i.SpecialInstructions,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderPickup = `-- name: GetOrderPickup :one
SELECT id, order_id, restaurant_id, tenant_id, pickup_number, status, items_subtotal, items_discount, items_vat, items_total, commission_rate, commission_amount, confirmed_at, preparing_at, ready_at, picked_at, rejected_at, rejection_reason, created_at, updated_at FROM order_pickups
WHERE order_id = $1 AND restaurant_id = $2
`

type GetOrderPickupParams struct {
	OrderID      uuid.UUID `json:"order_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
}

func (q *Queries) GetOrderPickup(ctx context.Context, arg GetOrderPickupParams) (OrderPickup, error) {
	row := q.db.QueryRow(ctx, getOrderPickup, arg.OrderID, arg.RestaurantID)
	var i OrderPickup
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.RestaurantID,
		&i.TenantID,
		&i.PickupNumber,
		&i.Status,
		&i.ItemsSubtotal,
		&i.ItemsDiscount,
		&i.ItemsVat,
		&i.ItemsTotal,
		&i.CommissionRate,
		&i.CommissionAmount,
		&i.ConfirmedAt,
		&i.PreparingAt,
		&i.ReadyAt,
		&i.PickedAt,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderPickupsByOrder = `-- name: GetOrderPickupsByOrder :many
SELECT id, order_id, restaurant_id, tenant_id, pickup_number, status, items_subtotal, items_discount, items_vat, items_total, commission_rate, commission_amount, confirmed_at, preparing_at, ready_at, picked_at, rejected_at, rejection_reason, created_at, updated_at FROM order_pickups
WHERE order_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetOrderPickupsByOrder(ctx context.Context, orderID uuid.UUID) ([]OrderPickup, error) {
	rows, err := q.db.Query(ctx, getOrderPickupsByOrder, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderPickup{}
	for rows.Next() {
		var i OrderPickup
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.RestaurantID,
			&i.TenantID,
			&i.PickupNumber,
			&i.Status,
			&i.ItemsSubtotal,
			&i.ItemsDiscount,
			&i.ItemsVat,
			&i.ItemsTotal,
			&i.CommissionRate,
			&i.CommissionAmount,
			&i.ConfirmedAt,
			&i.PreparingAt,
			&i.ReadyAt,
			&i.PickedAt,
			&i.RejectedAt,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPickupCountByOrder = `-- name: GetPickupCountByOrder :one
SELECT COUNT(*) FROM order_pickups
WHERE order_id = $1
`

func (q *Queries) GetPickupCountByOrder(ctx context.Context, orderID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getPickupCountByOrder, orderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listOrdersByCustomer = `-- name: ListOrdersByCustomer :many
SELECT id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE customer_id = $1 AND tenant_id = $2 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListOrdersByCustomerParams struct {
	CustomerID uuid.UUID `json:"customer_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
}

func (q *Queries) ListOrdersByCustomer(ctx context.Context, arg ListOrdersByCustomerParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByCustomer,
		arg.CustomerID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.RiderID,
			&i.HubID,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Platform,
			&i.DeliveryAddressID,
			&i.DeliveryAddress,
			&i.DeliveryRecipientName,
			&i.DeliveryRecipientPhone,
			&i.DeliveryArea,
			&i.DeliveryGeoLat,
			&i.DeliveryGeoLng,
			&i.Subtotal,
			&i.ItemDiscountTotal,
			&i.PromoDiscountTotal,
			&i.VatTotal,
			&i.DeliveryCharge,
			&i.ServiceFee,
			&i.TotalAmount,
			&i.PromoID,
			&i.PromoCode,
			&i.PromoSnapshot,
			&i.IsPriority,
			&i.IsReorder,
			&i.CustomerNote,
			&i.RiderNote,
			&i.InternalNote,
			&i.CancellationReason,
			&i.CancelledBy,
			&i.RejectionReason,
			&i.RejectedBy,
			&i.AutoConfirmAt,
			&i.EstimatedDeliveryMinutes,
			&i.ConfirmedAt,
			&i.PreparingAt,
			&i.ReadyAt,
			&i.PickedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByRestaurant = `-- name: ListOrdersByRestaurant :many
SELECT DISTINCT o.id, o.tenant_id, o.order_number, o.customer_id, o.rider_id, o.hub_id, o.status, o.payment_status, o.payment_method, o.platform, o.delivery_address_id, o.delivery_address, o.delivery_recipient_name, o.delivery_recipient_phone, o.delivery_area, o.delivery_geo_lat, o.delivery_geo_lng, o.subtotal, o.item_discount_total, o.promo_discount_total, o.vat_total, o.delivery_charge, o.service_fee, o.total_amount, o.promo_id, o.promo_code, o.promo_snapshot, o.is_priority, o.is_reorder, o.customer_note, o.rider_note, o.internal_note, o.cancellation_reason, o.cancelled_by, o.rejection_reason, o.rejected_by, o.auto_confirm_at, o.estimated_delivery_minutes, o.confirmed_at, o.preparing_at, o.ready_at, o.picked_at, o.delivered_at, o.cancelled_at, o.created_at, o.updated_at, o.deleted_at FROM orders o
JOIN order_pickups op ON o.id = op.order_id
WHERE op.restaurant_id = $1 AND o.tenant_id = $2 AND o.deleted_at IS NULL
ORDER BY o.created_at DESC
LIMIT $3 OFFSET $4
`

type ListOrdersByRestaurantParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListOrdersByRestaurant(ctx context.Context, arg ListOrdersByRestaurantParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByRestaurant,
		arg.RestaurantID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.RiderID,
			&i.HubID,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Platform,
			&i.DeliveryAddressID,
			&i.DeliveryAddress,
			&i.DeliveryRecipientName,
			&i.DeliveryRecipientPhone,
			&i.DeliveryArea,
			&i.DeliveryGeoLat,
			&i.DeliveryGeoLng,
			&i.Subtotal,
			&i.ItemDiscountTotal,
			&i.PromoDiscountTotal,
			&i.VatTotal,
			&i.DeliveryCharge,
			&i.ServiceFee,
			&i.TotalAmount,
			&i.PromoID,
			&i.PromoCode,
			&i.PromoSnapshot,
			&i.IsPriority,
			&i.IsReorder,
			&i.CustomerNote,
			&i.RiderNote,
			&i.InternalNote,
			&i.CancellationReason,
			&i.CancelledBy,
			&i.RejectionReason,
			&i.RejectedBy,
			&i.AutoConfirmAt,
			&i.EstimatedDeliveryMinutes,
			&i.ConfirmedAt,
			&i.PreparingAt,
			&i.ReadyAt,
			&i.PickedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByTenant = `-- name: ListOrdersByTenant :many
SELECT id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE tenant_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListOrdersByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListOrdersByTenant(ctx context.Context, arg ListOrdersByTenantParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrdersByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.RiderID,
			&i.HubID,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Platform,
			&i.DeliveryAddressID,
			&i.DeliveryAddress,
			&i.DeliveryRecipientName,
			&i.DeliveryRecipientPhone,
			&i.DeliveryArea,
			&i.DeliveryGeoLat,
			&i.DeliveryGeoLng,
			&i.Subtotal,
			&i.ItemDiscountTotal,
			&i.PromoDiscountTotal,
			&i.VatTotal,
			&i.DeliveryCharge,
			&i.ServiceFee,
			&i.TotalAmount,
			&i.PromoID,
			&i.PromoCode,
			&i.PromoSnapshot,
			&i.IsPriority,
			&i.IsReorder,
			&i.CustomerNote,
			&i.RiderNote,
			&i.InternalNote,
			&i.CancellationReason,
			&i.CancelledBy,
			&i.RejectionReason,
			&i.RejectedBy,
			&i.AutoConfirmAt,
			&i.EstimatedDeliveryMinutes,
			&i.ConfirmedAt,
			&i.PreparingAt,
			&i.ReadyAt,
			&i.PickedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingAutoConfirmOrders = `-- name: ListPendingAutoConfirmOrders :many
SELECT id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at FROM orders
WHERE status = 'created'
  AND auto_confirm_at IS NOT NULL
  AND auto_confirm_at <= NOW()
  AND deleted_at IS NULL
ORDER BY auto_confirm_at ASC
LIMIT $1
`

func (q *Queries) ListPendingAutoConfirmOrders(ctx context.Context, limit int32) ([]Order, error) {
	rows, err := q.db.Query(ctx, listPendingAutoConfirmOrders, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.RiderID,
			&i.HubID,
			&i.Status,
			&i.PaymentStatus,
			&i.PaymentMethod,
			&i.Platform,
			&i.DeliveryAddressID,
			&i.DeliveryAddress,
			&i.DeliveryRecipientName,
			&i.DeliveryRecipientPhone,
			&i.DeliveryArea,
			&i.DeliveryGeoLat,
			&i.DeliveryGeoLng,
			&i.Subtotal,
			&i.ItemDiscountTotal,
			&i.PromoDiscountTotal,
			&i.VatTotal,
			&i.DeliveryCharge,
			&i.ServiceFee,
			&i.TotalAmount,
			&i.PromoID,
			&i.PromoCode,
			&i.PromoSnapshot,
			&i.IsPriority,
			&i.IsReorder,
			&i.CustomerNote,
			&i.RiderNote,
			&i.InternalNote,
			&i.CancellationReason,
			&i.CancelledBy,
			&i.RejectionReason,
			&i.RejectedBy,
			&i.AutoConfirmAt,
			&i.EstimatedDeliveryMinutes,
			&i.ConfirmedAt,
			&i.PreparingAt,
			&i.ReadyAt,
			&i.PickedAt,
			&i.DeliveredAt,
			&i.CancelledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTimelineEvents = `-- name: ListTimelineEvents :many
SELECT id, order_id, tenant_id, event_type, previous_status, new_status, description, actor_id, actor_type, metadata, created_at FROM order_timeline_events
WHERE order_id = $1 AND tenant_id = $2
ORDER BY created_at ASC
`

type ListTimelineEventsParams struct {
	OrderID  uuid.UUID `json:"order_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ListTimelineEvents(ctx context.Context, arg ListTimelineEventsParams) ([]OrderTimelineEvent, error) {
	rows, err := q.db.Query(ctx, listTimelineEvents, arg.OrderID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderTimelineEvent{}
	for rows.Next() {
		var i OrderTimelineEvent
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.TenantID,
			&i.EventType,
			&i.PreviousStatus,
			&i.NewStatus,
			&i.Description,
			&i.ActorID,
			&i.ActorType,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteOrder = `-- name: SoftDeleteOrder :exec
UPDATE orders SET deleted_at = NOW()
WHERE id = $1 AND tenant_id = $2
`

type SoftDeleteOrderParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) SoftDeleteOrder(ctx context.Context, arg SoftDeleteOrderParams) error {
	_, err := q.db.Exec(ctx, softDeleteOrder, arg.ID, arg.TenantID)
	return err
}

const transitionOrderStatus = `-- name: TransitionOrderStatus :one
UPDATE orders SET
    status = $1,
    confirmed_at = CASE WHEN $1 = 'confirmed' THEN NOW() ELSE confirmed_at END,
    preparing_at = CASE WHEN $1 = 'preparing' THEN NOW() ELSE preparing_at END,
    ready_at = CASE WHEN $1 = 'ready' THEN NOW() ELSE ready_at END,
    picked_at = CASE WHEN $1 = 'picked' THEN NOW() ELSE picked_at END,
    delivered_at = CASE WHEN $1 = 'delivered' THEN NOW() ELSE delivered_at END,
    cancelled_at = CASE WHEN $1 = 'cancelled' THEN NOW() ELSE cancelled_at END,
    cancellation_reason = CASE WHEN $1 = 'cancelled' THEN $2 ELSE cancellation_reason END,
    cancelled_by = CASE WHEN $1 = 'cancelled' THEN $3 ELSE cancelled_by END,
    rejection_reason = CASE WHEN $1 = 'rejected' THEN $4 ELSE rejection_reason END,
    rejected_by = CASE WHEN $1 = 'rejected' THEN $5 ELSE rejected_by END
WHERE id = $6 AND tenant_id = $7 AND deleted_at IS NULL
RETURNING id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at
`

type TransitionOrderStatusParams struct {
	NewStatus          OrderStatus    `json:"new_status"`
	CancellationReason sql.NullString `json:"cancellation_reason"`
	CancelledBy        NullActorType  `json:"cancelled_by"`
	RejectionReason    sql.NullString `json:"rejection_reason"`
	RejectedBy         NullActorType  `json:"rejected_by"`
	ID                 uuid.UUID      `json:"id"`
	TenantID           uuid.UUID      `json:"tenant_id"`
}

func (q *Queries) TransitionOrderStatus(ctx context.Context, arg TransitionOrderStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, transitionOrderStatus,
		arg.NewStatus,
		arg.CancellationReason,
		arg.CancelledBy,
		arg.RejectionReason,
		arg.RejectedBy,
		arg.ID,
		arg.TenantID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.RiderID,
		&i.HubID,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Platform,
		&i.DeliveryAddressID,
		&i.DeliveryAddress,
		&i.DeliveryRecipientName,
		&i.DeliveryRecipientPhone,
		&i.DeliveryArea,
		&i.DeliveryGeoLat,
		&i.DeliveryGeoLng,
		&i.Subtotal,
		&i.ItemDiscountTotal,
		&i.PromoDiscountTotal,
		&i.VatTotal,
		&i.DeliveryCharge,
		&i.ServiceFee,
		&i.TotalAmount,
		&i.PromoID,
		&i.PromoCode,
		&i.PromoSnapshot,
		&i.IsPriority,
		&i.IsReorder,
		&i.CustomerNote,
		&i.RiderNote,
		&i.InternalNote,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.RejectionReason,
		&i.RejectedBy,
		&i.AutoConfirmAt,
		&i.EstimatedDeliveryMinutes,
		&i.ConfirmedAt,
		&i.PreparingAt,
		&i.ReadyAt,
		&i.PickedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const transitionPickupStatus = `-- name: TransitionPickupStatus :one
UPDATE order_pickups SET
    status = $1,
    confirmed_at = CASE WHEN $1 = 'confirmed' THEN NOW() ELSE confirmed_at END,
    preparing_at = CASE WHEN $1 = 'preparing' THEN NOW() ELSE preparing_at END,
    ready_at = CASE WHEN $1 = 'ready' THEN NOW() ELSE ready_at END,
    picked_at = CASE WHEN $1 = 'picked' THEN NOW() ELSE picked_at END,
    rejected_at = CASE WHEN $1 = 'rejected' THEN NOW() ELSE rejected_at END,
    rejection_reason = CASE WHEN $1 = 'rejected' THEN $2 ELSE rejection_reason END
WHERE order_id = $3 AND restaurant_id = $4
RETURNING id, order_id, restaurant_id, tenant_id, pickup_number, status, items_subtotal, items_discount, items_vat, items_total, commission_rate, commission_amount, confirmed_at, preparing_at, ready_at, picked_at, rejected_at, rejection_reason, created_at, updated_at
`

type TransitionPickupStatusParams struct {
	NewStatus       PickupStatus   `json:"new_status"`
	RejectionReason sql.NullString `json:"rejection_reason"`
	OrderID         uuid.UUID      `json:"order_id"`
	RestaurantID    uuid.UUID      `json:"restaurant_id"`
}

func (q *Queries) TransitionPickupStatus(ctx context.Context, arg TransitionPickupStatusParams) (OrderPickup, error) {
	row := q.db.QueryRow(ctx, transitionPickupStatus,
		arg.NewStatus,
		arg.RejectionReason,
		arg.OrderID,
		arg.RestaurantID,
	)
	var i OrderPickup
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.RestaurantID,
		&i.TenantID,
		&i.PickupNumber,
		&i.Status,
		&i.ItemsSubtotal,
		&i.ItemsDiscount,
		&i.ItemsVat,
		&i.ItemsTotal,
		&i.CommissionRate,
		&i.CommissionAmount,
		&i.ConfirmedAt,
		&i.PreparingAt,
		&i.ReadyAt,
		&i.PickedAt,
		&i.RejectedAt,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrderPaymentStatus = `-- name: UpdateOrderPaymentStatus :one
UPDATE orders SET
    payment_status = $1
WHERE id = $2 AND tenant_id = $3 AND deleted_at IS NULL
RETURNING id, tenant_id, order_number, customer_id, rider_id, hub_id, status, payment_status, payment_method, platform, delivery_address_id, delivery_address, delivery_recipient_name, delivery_recipient_phone, delivery_area, delivery_geo_lat, delivery_geo_lng, subtotal, item_discount_total, promo_discount_total, vat_total, delivery_charge, service_fee, total_amount, promo_id, promo_code, promo_snapshot, is_priority, is_reorder, customer_note, rider_note, internal_note, cancellation_reason, cancelled_by, rejection_reason, rejected_by, auto_confirm_at, estimated_delivery_minutes, confirmed_at, preparing_at, ready_at, picked_at, delivered_at, cancelled_at, created_at, updated_at, deleted_at
`

type UpdateOrderPaymentStatusParams struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	ID            uuid.UUID     `json:"id"`
	TenantID      uuid.UUID     `json:"tenant_id"`
}

func (q *Queries) UpdateOrderPaymentStatus(ctx context.Context, arg UpdateOrderPaymentStatusParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrderPaymentStatus, arg.PaymentStatus, arg.ID, arg.TenantID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.RiderID,
		&i.HubID,
		&i.Status,
		&i.PaymentStatus,
		&i.PaymentMethod,
		&i.Platform,
		&i.DeliveryAddressID,
		&i.DeliveryAddress,
		&i.DeliveryRecipientName,
		&i.DeliveryRecipientPhone,
		&i.DeliveryArea,
		&i.DeliveryGeoLat,
		&i.DeliveryGeoLng,
		&i.Subtotal,
		&i.ItemDiscountTotal,
		&i.PromoDiscountTotal,
		&i.VatTotal,
		&i.DeliveryCharge,
		&i.ServiceFee,
		&i.TotalAmount,
		&i.PromoID,
		&i.PromoCode,
		&i.PromoSnapshot,
		&i.IsPriority,
		&i.IsReorder,
		&i.CustomerNote,
		&i.RiderNote,
		&i.InternalNote,
		&i.CancellationReason,
		&i.CancelledBy,
		&i.RejectionReason,
		&i.RejectedBy,
		&i.AutoConfirmAt,
		&i.EstimatedDeliveryMinutes,
		&i.ConfirmedAt,
		&i.PreparingAt,
		&i.ReadyAt,
		&i.PickedAt,
		&i.DeliveredAt,
		&i.CancelledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
