// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type Accountable string

const (
	AccountableRestaurant Accountable = "restaurant"
	AccountableRider      Accountable = "rider"
	AccountablePlatform   Accountable = "platform"
)

func (e *Accountable) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Accountable(s)
	case string:
		*e = Accountable(s)
	default:
		return fmt.Errorf("unsupported scan type for Accountable: %T", src)
	}
	return nil
}

type NullAccountable struct {
	Accountable Accountable `json:"accountable"`
	Valid       bool        `json:"valid"` // Valid is true if Accountable is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccountable) Scan(value interface{}) error {
	if value == nil {
		ns.Accountable, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Accountable.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccountable) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Accountable), nil
}

type ActorType string

const (
	ActorTypeCustomer      ActorType = "customer"
	ActorTypeRestaurant    ActorType = "restaurant"
	ActorTypeRider         ActorType = "rider"
	ActorTypePlatformAdmin ActorType = "platform_admin"
	ActorTypeSystem        ActorType = "system"
)

func (e *ActorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ActorType(s)
	case string:
		*e = ActorType(s)
	default:
		return fmt.Errorf("unsupported scan type for ActorType: %T", src)
	}
	return nil
}

type NullActorType struct {
	ActorType ActorType `json:"actor_type"`
	Valid     bool      `json:"valid"` // Valid is true if ActorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullActorType) Scan(value interface{}) error {
	if value == nil {
		ns.ActorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ActorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullActorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ActorType), nil
}

type BillingCycle string

const (
	BillingCycleMonthly BillingCycle = "monthly"
	BillingCycleAnnual  BillingCycle = "annual"
)

func (e *BillingCycle) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BillingCycle(s)
	case string:
		*e = BillingCycle(s)
	default:
		return fmt.Errorf("unsupported scan type for BillingCycle: %T", src)
	}
	return nil
}

type NullBillingCycle struct {
	BillingCycle BillingCycle `json:"billing_cycle"`
	Valid        bool         `json:"valid"` // Valid is true if BillingCycle is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBillingCycle) Scan(value interface{}) error {
	if value == nil {
		ns.BillingCycle, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BillingCycle.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBillingCycle) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BillingCycle), nil
}

type DeliveryModel string

const (
	DeliveryModelZoneBased     DeliveryModel = "zone_based"
	DeliveryModelDistanceBased DeliveryModel = "distance_based"
)

func (e *DeliveryModel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DeliveryModel(s)
	case string:
		*e = DeliveryModel(s)
	default:
		return fmt.Errorf("unsupported scan type for DeliveryModel: %T", src)
	}
	return nil
}

type NullDeliveryModel struct {
	DeliveryModel DeliveryModel `json:"delivery_model"`
	Valid         bool          `json:"valid"` // Valid is true if DeliveryModel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDeliveryModel) Scan(value interface{}) error {
	if value == nil {
		ns.DeliveryModel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DeliveryModel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDeliveryModel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DeliveryModel), nil
}

type DiscountType string

const (
	DiscountTypeFixed   DiscountType = "fixed"
	DiscountTypePercent DiscountType = "percent"
)

func (e *DiscountType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DiscountType(s)
	case string:
		*e = DiscountType(s)
	default:
		return fmt.Errorf("unsupported scan type for DiscountType: %T", src)
	}
	return nil
}

type NullDiscountType struct {
	DiscountType DiscountType `json:"discount_type"`
	Valid        bool         `json:"valid"` // Valid is true if DiscountType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDiscountType) Scan(value interface{}) error {
	if value == nil {
		ns.DiscountType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DiscountType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDiscountType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DiscountType), nil
}

type GenderType string

const (
	GenderTypeMale           GenderType = "male"
	GenderTypeFemale         GenderType = "female"
	GenderTypeOther          GenderType = "other"
	GenderTypePreferNotToSay GenderType = "prefer_not_to_say"
)

func (e *GenderType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GenderType(s)
	case string:
		*e = GenderType(s)
	default:
		return fmt.Errorf("unsupported scan type for GenderType: %T", src)
	}
	return nil
}

type NullGenderType struct {
	GenderType GenderType `json:"gender_type"`
	Valid      bool       `json:"valid"` // Valid is true if GenderType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGenderType) Scan(value interface{}) error {
	if value == nil {
		ns.GenderType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GenderType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGenderType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GenderType), nil
}

type InventoryAdjustmentReason string

const (
	InventoryAdjustmentReasonOpeningStock     InventoryAdjustmentReason = "opening_stock"
	InventoryAdjustmentReasonPurchase         InventoryAdjustmentReason = "purchase"
	InventoryAdjustmentReasonManualAdjustment InventoryAdjustmentReason = "manual_adjustment"
	InventoryAdjustmentReasonOrderReserve     InventoryAdjustmentReason = "order_reserve"
	InventoryAdjustmentReasonOrderRelease     InventoryAdjustmentReason = "order_release"
	InventoryAdjustmentReasonOrderConsume     InventoryAdjustmentReason = "order_consume"
	InventoryAdjustmentReasonDamageLoss       InventoryAdjustmentReason = "damage_loss"
	InventoryAdjustmentReasonStockReturn      InventoryAdjustmentReason = "stock_return"
)

func (e *InventoryAdjustmentReason) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InventoryAdjustmentReason(s)
	case string:
		*e = InventoryAdjustmentReason(s)
	default:
		return fmt.Errorf("unsupported scan type for InventoryAdjustmentReason: %T", src)
	}
	return nil
}

type NullInventoryAdjustmentReason struct {
	InventoryAdjustmentReason InventoryAdjustmentReason `json:"inventory_adjustment_reason"`
	Valid                     bool                      `json:"valid"` // Valid is true if InventoryAdjustmentReason is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInventoryAdjustmentReason) Scan(value interface{}) error {
	if value == nil {
		ns.InventoryAdjustmentReason, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InventoryAdjustmentReason.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInventoryAdjustmentReason) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InventoryAdjustmentReason), nil
}

type InvoiceStatus string

const (
	InvoiceStatusDraft     InvoiceStatus = "draft"
	InvoiceStatusFinalized InvoiceStatus = "finalized"
	InvoiceStatusPaid      InvoiceStatus = "paid"
)

func (e *InvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceStatus(s)
	case string:
		*e = InvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceStatus: %T", src)
	}
	return nil
}

type NullInvoiceStatus struct {
	InvoiceStatus InvoiceStatus `json:"invoice_status"`
	Valid         bool          `json:"valid"` // Valid is true if InvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceStatus), nil
}

type IssueStatus string

const (
	IssueStatusOpen     IssueStatus = "open"
	IssueStatusResolved IssueStatus = "resolved"
	IssueStatusClosed   IssueStatus = "closed"
)

func (e *IssueStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IssueStatus(s)
	case string:
		*e = IssueStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for IssueStatus: %T", src)
	}
	return nil
}

type NullIssueStatus struct {
	IssueStatus IssueStatus `json:"issue_status"`
	Valid       bool        `json:"valid"` // Valid is true if IssueStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIssueStatus) Scan(value interface{}) error {
	if value == nil {
		ns.IssueStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IssueStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIssueStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IssueStatus), nil
}

type IssueType string

const (
	IssueTypeWrongItem    IssueType = "wrong_item"
	IssueTypeMissingItem  IssueType = "missing_item"
	IssueTypeQualityIssue IssueType = "quality_issue"
	IssueTypeLateDelivery IssueType = "late_delivery"
	IssueTypeOther        IssueType = "other"
)

func (e *IssueType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IssueType(s)
	case string:
		*e = IssueType(s)
	default:
		return fmt.Errorf("unsupported scan type for IssueType: %T", src)
	}
	return nil
}

type NullIssueType struct {
	IssueType IssueType `json:"issue_type"`
	Valid     bool      `json:"valid"` // Valid is true if IssueType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIssueType) Scan(value interface{}) error {
	if value == nil {
		ns.IssueType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IssueType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIssueType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IssueType), nil
}

type LedgerAccountType string

const (
	LedgerAccountTypeAsset     LedgerAccountType = "asset"
	LedgerAccountTypeLiability LedgerAccountType = "liability"
	LedgerAccountTypeRevenue   LedgerAccountType = "revenue"
	LedgerAccountTypeExpense   LedgerAccountType = "expense"
)

func (e *LedgerAccountType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LedgerAccountType(s)
	case string:
		*e = LedgerAccountType(s)
	default:
		return fmt.Errorf("unsupported scan type for LedgerAccountType: %T", src)
	}
	return nil
}

type NullLedgerAccountType struct {
	LedgerAccountType LedgerAccountType `json:"ledger_account_type"`
	Valid             bool              `json:"valid"` // Valid is true if LedgerAccountType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLedgerAccountType) Scan(value interface{}) error {
	if value == nil {
		ns.LedgerAccountType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LedgerAccountType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLedgerAccountType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LedgerAccountType), nil
}

type LedgerEntryType string

const (
	LedgerEntryTypeOrderRevenue LedgerEntryType = "order_revenue"
	LedgerEntryTypeCommission   LedgerEntryType = "commission"
	LedgerEntryTypeRefund       LedgerEntryType = "refund"
	LedgerEntryTypeWalletCredit LedgerEntryType = "wallet_credit"
	LedgerEntryTypeWalletDebit  LedgerEntryType = "wallet_debit"
	LedgerEntryTypeVendorPayout LedgerEntryType = "vendor_payout"
	LedgerEntryTypeDeliveryFee  LedgerEntryType = "delivery_fee"
	LedgerEntryTypePenalty      LedgerEntryType = "penalty"
	LedgerEntryTypeAdjustment   LedgerEntryType = "adjustment"
)

func (e *LedgerEntryType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LedgerEntryType(s)
	case string:
		*e = LedgerEntryType(s)
	default:
		return fmt.Errorf("unsupported scan type for LedgerEntryType: %T", src)
	}
	return nil
}

type NullLedgerEntryType struct {
	LedgerEntryType LedgerEntryType `json:"ledger_entry_type"`
	Valid           bool            `json:"valid"` // Valid is true if LedgerEntryType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLedgerEntryType) Scan(value interface{}) error {
	if value == nil {
		ns.LedgerEntryType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LedgerEntryType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLedgerEntryType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LedgerEntryType), nil
}

type LinkTargetType string

const (
	LinkTargetTypeRestaurant LinkTargetType = "restaurant"
	LinkTargetTypeProduct    LinkTargetType = "product"
	LinkTargetTypeCategory   LinkTargetType = "category"
	LinkTargetTypeUrl        LinkTargetType = "url"
	LinkTargetTypePromo      LinkTargetType = "promo"
)

func (e *LinkTargetType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LinkTargetType(s)
	case string:
		*e = LinkTargetType(s)
	default:
		return fmt.Errorf("unsupported scan type for LinkTargetType: %T", src)
	}
	return nil
}

type NullLinkTargetType struct {
	LinkTargetType LinkTargetType `json:"link_target_type"`
	Valid          bool           `json:"valid"` // Valid is true if LinkTargetType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLinkTargetType) Scan(value interface{}) error {
	if value == nil {
		ns.LinkTargetType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LinkTargetType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLinkTargetType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LinkTargetType), nil
}

type MediaType string

const (
	MediaTypeImage MediaType = "image"
	MediaTypeVideo MediaType = "video"
)

func (e *MediaType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MediaType(s)
	case string:
		*e = MediaType(s)
	default:
		return fmt.Errorf("unsupported scan type for MediaType: %T", src)
	}
	return nil
}

type NullMediaType struct {
	MediaType MediaType `json:"media_type"`
	Valid     bool      `json:"valid"` // Valid is true if MediaType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMediaType) Scan(value interface{}) error {
	if value == nil {
		ns.MediaType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MediaType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMediaType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MediaType), nil
}

type NotificationChannel string

const (
	NotificationChannelPush  NotificationChannel = "push"
	NotificationChannelSms   NotificationChannel = "sms"
	NotificationChannelEmail NotificationChannel = "email"
	NotificationChannelInApp NotificationChannel = "in_app"
)

func (e *NotificationChannel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NotificationChannel(s)
	case string:
		*e = NotificationChannel(s)
	default:
		return fmt.Errorf("unsupported scan type for NotificationChannel: %T", src)
	}
	return nil
}

type NullNotificationChannel struct {
	NotificationChannel NotificationChannel `json:"notification_channel"`
	Valid               bool                `json:"valid"` // Valid is true if NotificationChannel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNotificationChannel) Scan(value interface{}) error {
	if value == nil {
		ns.NotificationChannel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NotificationChannel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNotificationChannel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NotificationChannel), nil
}

type NotificationStatus string

const (
	NotificationStatusPending   NotificationStatus = "pending"
	NotificationStatusSent      NotificationStatus = "sent"
	NotificationStatusDelivered NotificationStatus = "delivered"
	NotificationStatusFailed    NotificationStatus = "failed"
	NotificationStatusRead      NotificationStatus = "read"
)

func (e *NotificationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NotificationStatus(s)
	case string:
		*e = NotificationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for NotificationStatus: %T", src)
	}
	return nil
}

type NullNotificationStatus struct {
	NotificationStatus NotificationStatus `json:"notification_status"`
	Valid              bool               `json:"valid"` // Valid is true if NotificationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNotificationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.NotificationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NotificationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNotificationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NotificationStatus), nil
}

type OrderStatus string

const (
	OrderStatusPending   OrderStatus = "pending"
	OrderStatusCreated   OrderStatus = "created"
	OrderStatusConfirmed OrderStatus = "confirmed"
	OrderStatusPreparing OrderStatus = "preparing"
	OrderStatusReady     OrderStatus = "ready"
	OrderStatusPicked    OrderStatus = "picked"
	OrderStatusDelivered OrderStatus = "delivered"
	OrderStatusCancelled OrderStatus = "cancelled"
	OrderStatusRejected  OrderStatus = "rejected"
)

func (e *OrderStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrderStatus(s)
	case string:
		*e = OrderStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for OrderStatus: %T", src)
	}
	return nil
}

type NullOrderStatus struct {
	OrderStatus OrderStatus `json:"order_status"`
	Valid       bool        `json:"valid"` // Valid is true if OrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderStatus) Scan(value interface{}) error {
	if value == nil {
		ns.OrderStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrderStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrderStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrderStatus), nil
}

type OutboxEventStatus string

const (
	OutboxEventStatusPending    OutboxEventStatus = "pending"
	OutboxEventStatusProcessing OutboxEventStatus = "processing"
	OutboxEventStatusProcessed  OutboxEventStatus = "processed"
	OutboxEventStatusFailed     OutboxEventStatus = "failed"
	OutboxEventStatusDeadLetter OutboxEventStatus = "dead_letter"
)

func (e *OutboxEventStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OutboxEventStatus(s)
	case string:
		*e = OutboxEventStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for OutboxEventStatus: %T", src)
	}
	return nil
}

type NullOutboxEventStatus struct {
	OutboxEventStatus OutboxEventStatus `json:"outbox_event_status"`
	Valid             bool              `json:"valid"` // Valid is true if OutboxEventStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOutboxEventStatus) Scan(value interface{}) error {
	if value == nil {
		ns.OutboxEventStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OutboxEventStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOutboxEventStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OutboxEventStatus), nil
}

type PaymentMethod string

const (
	PaymentMethodCod        PaymentMethod = "cod"
	PaymentMethodBkash      PaymentMethod = "bkash"
	PaymentMethodAamarpay   PaymentMethod = "aamarpay"
	PaymentMethodSslcommerz PaymentMethod = "sslcommerz"
	PaymentMethodWallet     PaymentMethod = "wallet"
	PaymentMethodCard       PaymentMethod = "card"
)

func (e *PaymentMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentMethod(s)
	case string:
		*e = PaymentMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentMethod: %T", src)
	}
	return nil
}

type NullPaymentMethod struct {
	PaymentMethod PaymentMethod `json:"payment_method"`
	Valid         bool          `json:"valid"` // Valid is true if PaymentMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentMethod) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentMethod), nil
}

type PaymentStatus string

const (
	PaymentStatusUnpaid            PaymentStatus = "unpaid"
	PaymentStatusPaid              PaymentStatus = "paid"
	PaymentStatusRefunded          PaymentStatus = "refunded"
	PaymentStatusPartiallyRefunded PaymentStatus = "partially_refunded"
)

func (e *PaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PaymentStatus(s)
	case string:
		*e = PaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PaymentStatus: %T", src)
	}
	return nil
}

type NullPaymentStatus struct {
	PaymentStatus PaymentStatus `json:"payment_status"`
	Valid         bool          `json:"valid"` // Valid is true if PaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PaymentStatus), nil
}

type PayoutStatus string

const (
	PayoutStatusPending    PayoutStatus = "pending"
	PayoutStatusProcessing PayoutStatus = "processing"
	PayoutStatusCompleted  PayoutStatus = "completed"
	PayoutStatusFailed     PayoutStatus = "failed"
)

func (e *PayoutStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PayoutStatus(s)
	case string:
		*e = PayoutStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PayoutStatus: %T", src)
	}
	return nil
}

type NullPayoutStatus struct {
	PayoutStatus PayoutStatus `json:"payout_status"`
	Valid        bool         `json:"valid"` // Valid is true if PayoutStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPayoutStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PayoutStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PayoutStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPayoutStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PayoutStatus), nil
}

type PenaltyStatus string

const (
	PenaltyStatusPending  PenaltyStatus = "pending"
	PenaltyStatusCleared  PenaltyStatus = "cleared"
	PenaltyStatusAppealed PenaltyStatus = "appealed"
)

func (e *PenaltyStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PenaltyStatus(s)
	case string:
		*e = PenaltyStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PenaltyStatus: %T", src)
	}
	return nil
}

type NullPenaltyStatus struct {
	PenaltyStatus PenaltyStatus `json:"penalty_status"`
	Valid         bool          `json:"valid"` // Valid is true if PenaltyStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPenaltyStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PenaltyStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PenaltyStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPenaltyStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PenaltyStatus), nil
}

type PickupStatus string

const (
	PickupStatusNew       PickupStatus = "new"
	PickupStatusConfirmed PickupStatus = "confirmed"
	PickupStatusPreparing PickupStatus = "preparing"
	PickupStatusReady     PickupStatus = "ready"
	PickupStatusPicked    PickupStatus = "picked"
	PickupStatusRejected  PickupStatus = "rejected"
)

func (e *PickupStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PickupStatus(s)
	case string:
		*e = PickupStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for PickupStatus: %T", src)
	}
	return nil
}

type NullPickupStatus struct {
	PickupStatus PickupStatus `json:"pickup_status"`
	Valid        bool         `json:"valid"` // Valid is true if PickupStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPickupStatus) Scan(value interface{}) error {
	if value == nil {
		ns.PickupStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PickupStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPickupStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PickupStatus), nil
}

type PlatformSource string

const (
	PlatformSourceWeb     PlatformSource = "web"
	PlatformSourceIos     PlatformSource = "ios"
	PlatformSourceAndroid PlatformSource = "android"
	PlatformSourcePos     PlatformSource = "pos"
)

func (e *PlatformSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PlatformSource(s)
	case string:
		*e = PlatformSource(s)
	default:
		return fmt.Errorf("unsupported scan type for PlatformSource: %T", src)
	}
	return nil
}

type NullPlatformSource struct {
	PlatformSource PlatformSource `json:"platform_source"`
	Valid          bool           `json:"valid"` // Valid is true if PlatformSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlatformSource) Scan(value interface{}) error {
	if value == nil {
		ns.PlatformSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PlatformSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlatformSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PlatformSource), nil
}

type PriceType string

const (
	PriceTypeFlat    PriceType = "flat"
	PriceTypeVariant PriceType = "variant"
)

func (e *PriceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PriceType(s)
	case string:
		*e = PriceType(s)
	default:
		return fmt.Errorf("unsupported scan type for PriceType: %T", src)
	}
	return nil
}

type NullPriceType struct {
	PriceType PriceType `json:"price_type"`
	Valid     bool      `json:"valid"` // Valid is true if PriceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPriceType) Scan(value interface{}) error {
	if value == nil {
		ns.PriceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PriceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPriceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PriceType), nil
}

type ProductAvail string

const (
	ProductAvailAvailable   ProductAvail = "available"
	ProductAvailUnavailable ProductAvail = "unavailable"
	ProductAvailOutOfStock  ProductAvail = "out_of_stock"
)

func (e *ProductAvail) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProductAvail(s)
	case string:
		*e = ProductAvail(s)
	default:
		return fmt.Errorf("unsupported scan type for ProductAvail: %T", src)
	}
	return nil
}

type NullProductAvail struct {
	ProductAvail ProductAvail `json:"product_avail"`
	Valid        bool         `json:"valid"` // Valid is true if ProductAvail is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProductAvail) Scan(value interface{}) error {
	if value == nil {
		ns.ProductAvail, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProductAvail.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProductAvail) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProductAvail), nil
}

type PromoApplyOn string

const (
	PromoApplyOnAllItems           PromoApplyOn = "all_items"
	PromoApplyOnCategory           PromoApplyOn = "category"
	PromoApplyOnSpecificRestaurant PromoApplyOn = "specific_restaurant"
	PromoApplyOnDeliveryCharge     PromoApplyOn = "delivery_charge"
)

func (e *PromoApplyOn) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PromoApplyOn(s)
	case string:
		*e = PromoApplyOn(s)
	default:
		return fmt.Errorf("unsupported scan type for PromoApplyOn: %T", src)
	}
	return nil
}

type NullPromoApplyOn struct {
	PromoApplyOn PromoApplyOn `json:"promo_apply_on"`
	Valid        bool         `json:"valid"` // Valid is true if PromoApplyOn is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPromoApplyOn) Scan(value interface{}) error {
	if value == nil {
		ns.PromoApplyOn, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PromoApplyOn.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPromoApplyOn) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PromoApplyOn), nil
}

type PromoFunder string

const (
	PromoFunderVendor     PromoFunder = "vendor"
	PromoFunderPlatform   PromoFunder = "platform"
	PromoFunderRestaurant PromoFunder = "restaurant"
)

func (e *PromoFunder) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PromoFunder(s)
	case string:
		*e = PromoFunder(s)
	default:
		return fmt.Errorf("unsupported scan type for PromoFunder: %T", src)
	}
	return nil
}

type NullPromoFunder struct {
	PromoFunder PromoFunder `json:"promo_funder"`
	Valid       bool        `json:"valid"` // Valid is true if PromoFunder is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPromoFunder) Scan(value interface{}) error {
	if value == nil {
		ns.PromoFunder, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PromoFunder.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPromoFunder) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PromoFunder), nil
}

type PromoType string

const (
	PromoTypeFixed   PromoType = "fixed"
	PromoTypePercent PromoType = "percent"
)

func (e *PromoType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PromoType(s)
	case string:
		*e = PromoType(s)
	default:
		return fmt.Errorf("unsupported scan type for PromoType: %T", src)
	}
	return nil
}

type NullPromoType struct {
	PromoType PromoType `json:"promo_type"`
	Valid     bool      `json:"valid"` // Valid is true if PromoType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPromoType) Scan(value interface{}) error {
	if value == nil {
		ns.PromoType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PromoType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPromoType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PromoType), nil
}

type RefundStatus string

const (
	RefundStatusPending   RefundStatus = "pending"
	RefundStatusApproved  RefundStatus = "approved"
	RefundStatusRejected  RefundStatus = "rejected"
	RefundStatusProcessed RefundStatus = "processed"
)

func (e *RefundStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RefundStatus(s)
	case string:
		*e = RefundStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for RefundStatus: %T", src)
	}
	return nil
}

type NullRefundStatus struct {
	RefundStatus RefundStatus `json:"refund_status"`
	Valid        bool         `json:"valid"` // Valid is true if RefundStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRefundStatus) Scan(value interface{}) error {
	if value == nil {
		ns.RefundStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RefundStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRefundStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RefundStatus), nil
}

type RestaurantType string

const (
	RestaurantTypeRestaurant   RestaurantType = "restaurant"
	RestaurantTypeCloudKitchen RestaurantType = "cloud_kitchen"
	RestaurantTypeStore        RestaurantType = "store"
	RestaurantTypeDarkStore    RestaurantType = "dark_store"
)

func (e *RestaurantType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RestaurantType(s)
	case string:
		*e = RestaurantType(s)
	default:
		return fmt.Errorf("unsupported scan type for RestaurantType: %T", src)
	}
	return nil
}

type NullRestaurantType struct {
	RestaurantType RestaurantType `json:"restaurant_type"`
	Valid          bool           `json:"valid"` // Valid is true if RestaurantType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRestaurantType) Scan(value interface{}) error {
	if value == nil {
		ns.RestaurantType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RestaurantType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRestaurantType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RestaurantType), nil
}

type RiderSubject string

const (
	RiderSubjectAttendanceIn   RiderSubject = "attendance_in"
	RiderSubjectAttendanceOut  RiderSubject = "attendance_out"
	RiderSubjectPicked         RiderSubject = "picked"
	RiderSubjectDelivered      RiderSubject = "delivered"
	RiderSubjectInHub          RiderSubject = "in_hub"
	RiderSubjectLocationUpdate RiderSubject = "location_update"
)

func (e *RiderSubject) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RiderSubject(s)
	case string:
		*e = RiderSubject(s)
	default:
		return fmt.Errorf("unsupported scan type for RiderSubject: %T", src)
	}
	return nil
}

type NullRiderSubject struct {
	RiderSubject RiderSubject `json:"rider_subject"`
	Valid        bool         `json:"valid"` // Valid is true if RiderSubject is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRiderSubject) Scan(value interface{}) error {
	if value == nil {
		ns.RiderSubject, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RiderSubject.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRiderSubject) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RiderSubject), nil
}

type SubscriptionStatus string

const (
	SubscriptionStatusTrialing  SubscriptionStatus = "trialing"
	SubscriptionStatusActive    SubscriptionStatus = "active"
	SubscriptionStatusPastDue   SubscriptionStatus = "past_due"
	SubscriptionStatusCancelled SubscriptionStatus = "cancelled"
)

func (e *SubscriptionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubscriptionStatus(s)
	case string:
		*e = SubscriptionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SubscriptionStatus: %T", src)
	}
	return nil
}

type NullSubscriptionStatus struct {
	SubscriptionStatus SubscriptionStatus `json:"subscription_status"`
	Valid              bool               `json:"valid"` // Valid is true if SubscriptionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubscriptionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SubscriptionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubscriptionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubscriptionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubscriptionStatus), nil
}

type TenantPlan string

const (
	TenantPlanStarter    TenantPlan = "starter"
	TenantPlanGrowth     TenantPlan = "growth"
	TenantPlanEnterprise TenantPlan = "enterprise"
)

func (e *TenantPlan) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TenantPlan(s)
	case string:
		*e = TenantPlan(s)
	default:
		return fmt.Errorf("unsupported scan type for TenantPlan: %T", src)
	}
	return nil
}

type NullTenantPlan struct {
	TenantPlan TenantPlan `json:"tenant_plan"`
	Valid      bool       `json:"valid"` // Valid is true if TenantPlan is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTenantPlan) Scan(value interface{}) error {
	if value == nil {
		ns.TenantPlan, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TenantPlan.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTenantPlan) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TenantPlan), nil
}

type TenantStatus string

const (
	TenantStatusPending   TenantStatus = "pending"
	TenantStatusActive    TenantStatus = "active"
	TenantStatusSuspended TenantStatus = "suspended"
	TenantStatusCancelled TenantStatus = "cancelled"
)

func (e *TenantStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TenantStatus(s)
	case string:
		*e = TenantStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TenantStatus: %T", src)
	}
	return nil
}

type NullTenantStatus struct {
	TenantStatus TenantStatus `json:"tenant_status"`
	Valid        bool         `json:"valid"` // Valid is true if TenantStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTenantStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TenantStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TenantStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTenantStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TenantStatus), nil
}

type TxnStatus string

const (
	TxnStatusPending   TxnStatus = "pending"
	TxnStatusSuccess   TxnStatus = "success"
	TxnStatusFailed    TxnStatus = "failed"
	TxnStatusRefunded  TxnStatus = "refunded"
	TxnStatusCancelled TxnStatus = "cancelled"
)

func (e *TxnStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TxnStatus(s)
	case string:
		*e = TxnStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TxnStatus: %T", src)
	}
	return nil
}

type NullTxnStatus struct {
	TxnStatus TxnStatus `json:"txn_status"`
	Valid     bool      `json:"valid"` // Valid is true if TxnStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTxnStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TxnStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TxnStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTxnStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TxnStatus), nil
}

type UserRole string

const (
	UserRoleCustomer          UserRole = "customer"
	UserRoleTenantOwner       UserRole = "tenant_owner"
	UserRoleTenantAdmin       UserRole = "tenant_admin"
	UserRoleRestaurantManager UserRole = "restaurant_manager"
	UserRoleRestaurantStaff   UserRole = "restaurant_staff"
	UserRoleRider             UserRole = "rider"
	UserRolePlatformAdmin     UserRole = "platform_admin"
	UserRolePlatformSupport   UserRole = "platform_support"
	UserRolePlatformFinance   UserRole = "platform_finance"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type UserStatus string

const (
	UserStatusActive    UserStatus = "active"
	UserStatusSuspended UserStatus = "suspended"
	UserStatusDeleted   UserStatus = "deleted"
)

func (e *UserStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserStatus(s)
	case string:
		*e = UserStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserStatus: %T", src)
	}
	return nil
}

type NullUserStatus struct {
	UserStatus UserStatus `json:"user_status"`
	Valid      bool       `json:"valid"` // Valid is true if UserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserStatus), nil
}

type VehicleType string

const (
	VehicleTypeBicycle    VehicleType = "bicycle"
	VehicleTypeMotorcycle VehicleType = "motorcycle"
	VehicleTypeCar        VehicleType = "car"
)

func (e *VehicleType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VehicleType(s)
	case string:
		*e = VehicleType(s)
	default:
		return fmt.Errorf("unsupported scan type for VehicleType: %T", src)
	}
	return nil
}

type NullVehicleType struct {
	VehicleType VehicleType `json:"vehicle_type"`
	Valid       bool        `json:"valid"` // Valid is true if VehicleType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVehicleType) Scan(value interface{}) error {
	if value == nil {
		ns.VehicleType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VehicleType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVehicleType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VehicleType), nil
}

type WalletSource string

const (
	WalletSourceCashback        WalletSource = "cashback"
	WalletSourceReferral        WalletSource = "referral"
	WalletSourceWelcome         WalletSource = "welcome"
	WalletSourceRefund          WalletSource = "refund"
	WalletSourceOrderPayment    WalletSource = "order_payment"
	WalletSourceAdminAdjustment WalletSource = "admin_adjustment"
)

func (e *WalletSource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WalletSource(s)
	case string:
		*e = WalletSource(s)
	default:
		return fmt.Errorf("unsupported scan type for WalletSource: %T", src)
	}
	return nil
}

type NullWalletSource struct {
	WalletSource WalletSource `json:"wallet_source"`
	Valid        bool         `json:"valid"` // Valid is true if WalletSource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWalletSource) Scan(value interface{}) error {
	if value == nil {
		ns.WalletSource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WalletSource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWalletSource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WalletSource), nil
}

type WalletType string

const (
	WalletTypeCredit WalletType = "credit"
	WalletTypeDebit  WalletType = "debit"
)

func (e *WalletType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WalletType(s)
	case string:
		*e = WalletType(s)
	default:
		return fmt.Errorf("unsupported scan type for WalletType: %T", src)
	}
	return nil
}

type NullWalletType struct {
	WalletType WalletType `json:"wallet_type"`
	Valid      bool       `json:"valid"` // Valid is true if WalletType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWalletType) Scan(value interface{}) error {
	if value == nil {
		ns.WalletType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WalletType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWalletType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WalletType), nil
}

type AuditLog struct {
	ID           uuid.UUID       `json:"id"`
	TenantID     pgtype.UUID     `json:"tenant_id"`
	ActorID      pgtype.UUID     `json:"actor_id"`
	ActorType    ActorType       `json:"actor_type"`
	Action       string          `json:"action"`
	ResourceType string          `json:"resource_type"`
	ResourceID   pgtype.UUID     `json:"resource_id"`
	Changes      json.RawMessage `json:"changes"`
	Reason       sql.NullString  `json:"reason"`
	IpAddress    *netip.Addr     `json:"ip_address"`
	CreatedAt    time.Time       `json:"created_at"`
}

type Banner struct {
	ID             uuid.UUID          `json:"id"`
	TenantID       uuid.UUID          `json:"tenant_id"`
	Title          string             `json:"title"`
	Subtitle       sql.NullString     `json:"subtitle"`
	ImageUrl       string             `json:"image_url"`
	MobileImageUrl sql.NullString     `json:"mobile_image_url"`
	LinkType       NullLinkTargetType `json:"link_type"`
	LinkValue      sql.NullString     `json:"link_value"`
	Platform       string             `json:"platform"`
	SortOrder      int32              `json:"sort_order"`
	IsActive       bool               `json:"is_active"`
	HubIds         []uuid.UUID        `json:"hub_ids"`
	StartsAt       pgtype.Timestamptz `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

type Category struct {
	ID                   uuid.UUID      `json:"id"`
	TenantID             uuid.UUID      `json:"tenant_id"`
	RestaurantID         pgtype.UUID    `json:"restaurant_id"`
	ParentID             pgtype.UUID    `json:"parent_id"`
	Name                 string         `json:"name"`
	Slug                 string         `json:"slug"`
	Description          sql.NullString `json:"description"`
	ImageUrl             sql.NullString `json:"image_url"`
	IconUrl              sql.NullString `json:"icon_url"`
	ExtraPrepTimeMinutes int32          `json:"extra_prep_time_minutes"`
	IsTobacco            bool           `json:"is_tobacco"`
	IsActive             bool           `json:"is_active"`
	SortOrder            int32          `json:"sort_order"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
}

type DeliveryZoneConfig struct {
	ID                    uuid.UUID       `json:"id"`
	TenantID              uuid.UUID       `json:"tenant_id"`
	Model                 DeliveryModel   `json:"model"`
	DistanceTiers         json.RawMessage `json:"distance_tiers"`
	FreeDeliveryThreshold pgtype.Numeric  `json:"free_delivery_threshold"`
	CreatedAt             time.Time       `json:"created_at"`
	UpdatedAt             time.Time       `json:"updated_at"`
}

type HomepageSection struct {
	ID          uuid.UUID      `json:"id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
	Title       string         `json:"title"`
	Subtitle    sql.NullString `json:"subtitle"`
	ContentType string         `json:"content_type"`
	ItemIds     []uuid.UUID    `json:"item_ids"`
	FilterRule  []byte         `json:"filter_rule"`
	SortOrder   int32          `json:"sort_order"`
	IsActive    bool           `json:"is_active"`
	HubIds      []uuid.UUID    `json:"hub_ids"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

type Hub struct {
	ID           uuid.UUID      `json:"id"`
	TenantID     uuid.UUID      `json:"tenant_id"`
	Name         string         `json:"name"`
	Code         sql.NullString `json:"code"`
	ManagerID    pgtype.UUID    `json:"manager_id"`
	AddressLine1 sql.NullString `json:"address_line1"`
	AddressLine2 sql.NullString `json:"address_line2"`
	City         string         `json:"city"`
	GeoLat       pgtype.Numeric `json:"geo_lat"`
	GeoLng       pgtype.Numeric `json:"geo_lng"`
	ContactPhone sql.NullString `json:"contact_phone"`
	ContactEmail sql.NullString `json:"contact_email"`
	IsActive     bool           `json:"is_active"`
	SortOrder    int32          `json:"sort_order"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

type HubCoverageArea struct {
	ID                       uuid.UUID      `json:"id"`
	HubID                    uuid.UUID      `json:"hub_id"`
	TenantID                 uuid.UUID      `json:"tenant_id"`
	Name                     string         `json:"name"`
	Slug                     string         `json:"slug"`
	DeliveryCharge           pgtype.Numeric `json:"delivery_charge"`
	MinOrderAmount           pgtype.Numeric `json:"min_order_amount"`
	EstimatedDeliveryMinutes int32          `json:"estimated_delivery_minutes"`
	GeoPolygon               []byte         `json:"geo_polygon"`
	IsActive                 bool           `json:"is_active"`
	SortOrder                int32          `json:"sort_order"`
}

type IdempotencyKey struct {
	ID             uuid.UUID   `json:"id"`
	TenantID       pgtype.UUID `json:"tenant_id"`
	UserID         pgtype.UUID `json:"user_id"`
	Key            string      `json:"key"`
	Endpoint       string      `json:"endpoint"`
	RequestHash    string      `json:"request_hash"`
	ResponseStatus *int32      `json:"response_status"`
	ResponseBody   []byte      `json:"response_body"`
	ExpiresAt      time.Time   `json:"expires_at"`
	CreatedAt      time.Time   `json:"created_at"`
}

type InventoryAdjustment struct {
	ID              uuid.UUID                 `json:"id"`
	InventoryItemID uuid.UUID                 `json:"inventory_item_id"`
	TenantID        uuid.UUID                 `json:"tenant_id"`
	RestaurantID    uuid.UUID                 `json:"restaurant_id"`
	OrderID         pgtype.UUID               `json:"order_id"`
	AdjustmentType  InventoryAdjustmentReason `json:"adjustment_type"`
	QtyBefore       int32                     `json:"qty_before"`
	QtyChange       int32                     `json:"qty_change"`
	QtyAfter        int32                     `json:"qty_after"`
	CostPrice       pgtype.Numeric            `json:"cost_price"`
	Note            sql.NullString            `json:"note"`
	AdjustedBy      pgtype.UUID               `json:"adjusted_by"`
	CreatedAt       time.Time                 `json:"created_at"`
}

type InventoryItem struct {
	ID               uuid.UUID          `json:"id"`
	ProductID        uuid.UUID          `json:"product_id"`
	RestaurantID     uuid.UUID          `json:"restaurant_id"`
	TenantID         uuid.UUID          `json:"tenant_id"`
	StockQty         int32              `json:"stock_qty"`
	ReservedQty      int32              `json:"reserved_qty"`
	CostPrice        pgtype.Numeric     `json:"cost_price"`
	ReorderThreshold int32              `json:"reorder_threshold"`
	LastRestockedAt  pgtype.Timestamptz `json:"last_restocked_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
}

type Invoice struct {
	ID                   uuid.UUID          `json:"id"`
	TenantID             uuid.UUID          `json:"tenant_id"`
	RestaurantID         uuid.UUID          `json:"restaurant_id"`
	InvoiceNumber        string             `json:"invoice_number"`
	PeriodStart          pgtype.Date        `json:"period_start"`
	PeriodEnd            pgtype.Date        `json:"period_end"`
	GrossSales           pgtype.Numeric     `json:"gross_sales"`
	ItemDiscounts        pgtype.Numeric     `json:"item_discounts"`
	VendorPromoDiscounts pgtype.Numeric     `json:"vendor_promo_discounts"`
	NetSales             pgtype.Numeric     `json:"net_sales"`
	VatCollected         pgtype.Numeric     `json:"vat_collected"`
	CommissionRate       pgtype.Numeric     `json:"commission_rate"`
	CommissionAmount     pgtype.Numeric     `json:"commission_amount"`
	PenaltyAmount        pgtype.Numeric     `json:"penalty_amount"`
	AdjustmentAmount     pgtype.Numeric     `json:"adjustment_amount"`
	AdjustmentNote       sql.NullString     `json:"adjustment_note"`
	NetPayable           pgtype.Numeric     `json:"net_payable"`
	TotalOrders          int32              `json:"total_orders"`
	DeliveredOrders      int32              `json:"delivered_orders"`
	CancelledOrders      int32              `json:"cancelled_orders"`
	RejectedOrders       int32              `json:"rejected_orders"`
	Status               InvoiceStatus      `json:"status"`
	GeneratedBy          pgtype.UUID        `json:"generated_by"`
	FinalizedBy          pgtype.UUID        `json:"finalized_by"`
	FinalizedAt          pgtype.Timestamptz `json:"finalized_at"`
	PaidBy               pgtype.UUID        `json:"paid_by"`
	PaidAt               pgtype.Timestamptz `json:"paid_at"`
	PaymentReference     sql.NullString     `json:"payment_reference"`
	Notes                sql.NullString     `json:"notes"`
	CreatedAt            time.Time          `json:"created_at"`
	UpdatedAt            time.Time          `json:"updated_at"`
	DeliveryChargeTotal  pgtype.Numeric     `json:"delivery_charge_total"`
}

type InvoiceAdjustment struct {
	ID               uuid.UUID      `json:"id"`
	InvoiceID        uuid.UUID      `json:"invoice_id"`
	Amount           pgtype.Numeric `json:"amount"`
	Direction        string         `json:"direction"`
	Reason           string         `json:"reason"`
	CreatedByAdminID pgtype.UUID    `json:"created_by_admin_id"`
	CreatedAt        time.Time      `json:"created_at"`
}

type LedgerAccount struct {
	ID          uuid.UUID         `json:"id"`
	Code        string            `json:"code"`
	Name        string            `json:"name"`
	AccountType LedgerAccountType `json:"account_type"`
	Description sql.NullString    `json:"description"`
	IsSystem    bool              `json:"is_system"`
	CreatedAt   time.Time         `json:"created_at"`
}

type LedgerEntry struct {
	ID            uuid.UUID       `json:"id"`
	TenantID      pgtype.UUID     `json:"tenant_id"`
	AccountID     uuid.UUID       `json:"account_id"`
	EntryType     LedgerEntryType `json:"entry_type"`
	ReferenceType string          `json:"reference_type"`
	ReferenceID   uuid.UUID       `json:"reference_id"`
	Debit         pgtype.Numeric  `json:"debit"`
	Credit        pgtype.Numeric  `json:"credit"`
	BalanceAfter  pgtype.Numeric  `json:"balance_after"`
	Description   string          `json:"description"`
	Metadata      json.RawMessage `json:"metadata"`
	CreatedAt     time.Time       `json:"created_at"`
}

type Notification struct {
	ID               uuid.UUID           `json:"id"`
	TenantID         pgtype.UUID         `json:"tenant_id"`
	UserID           uuid.UUID           `json:"user_id"`
	Channel          NotificationChannel `json:"channel"`
	Title            string              `json:"title"`
	Body             string              `json:"body"`
	ImageUrl         sql.NullString      `json:"image_url"`
	ActionType       sql.NullString      `json:"action_type"`
	ActionPayload    []byte              `json:"action_payload"`
	Status           NotificationStatus  `json:"status"`
	SentAt           pgtype.Timestamptz  `json:"sent_at"`
	DeliveredAt      pgtype.Timestamptz  `json:"delivered_at"`
	ReadAt           pgtype.Timestamptz  `json:"read_at"`
	FailedReason     sql.NullString      `json:"failed_reason"`
	GatewayMessageID sql.NullString      `json:"gateway_message_id"`
	CreatedAt        time.Time           `json:"created_at"`
}

type NotificationPreference struct {
	ID            uuid.UUID   `json:"id"`
	UserID        uuid.UUID   `json:"user_id"`
	TenantID      pgtype.UUID `json:"tenant_id"`
	PushEnabled   bool        `json:"push_enabled"`
	SmsEnabled    bool        `json:"sms_enabled"`
	EmailEnabled  bool        `json:"email_enabled"`
	OrderUpdates  bool        `json:"order_updates"`
	Promotions    bool        `json:"promotions"`
	SystemAlerts  bool        `json:"system_alerts"`
	InvoiceAlerts bool        `json:"invoice_alerts"`
	CreatedAt     time.Time   `json:"created_at"`
	UpdatedAt     time.Time   `json:"updated_at"`
}

type Order struct {
	ID                       uuid.UUID          `json:"id"`
	TenantID                 uuid.UUID          `json:"tenant_id"`
	OrderNumber              string             `json:"order_number"`
	CustomerID               uuid.UUID          `json:"customer_id"`
	RiderID                  pgtype.UUID        `json:"rider_id"`
	HubID                    pgtype.UUID        `json:"hub_id"`
	Status                   OrderStatus        `json:"status"`
	PaymentStatus            PaymentStatus      `json:"payment_status"`
	PaymentMethod            PaymentMethod      `json:"payment_method"`
	Platform                 PlatformSource     `json:"platform"`
	DeliveryAddressID        pgtype.UUID        `json:"delivery_address_id"`
	DeliveryAddress          json.RawMessage    `json:"delivery_address"`
	DeliveryRecipientName    string             `json:"delivery_recipient_name"`
	DeliveryRecipientPhone   string             `json:"delivery_recipient_phone"`
	DeliveryArea             string             `json:"delivery_area"`
	DeliveryGeoLat           pgtype.Numeric     `json:"delivery_geo_lat"`
	DeliveryGeoLng           pgtype.Numeric     `json:"delivery_geo_lng"`
	Subtotal                 pgtype.Numeric     `json:"subtotal"`
	ItemDiscountTotal        pgtype.Numeric     `json:"item_discount_total"`
	PromoDiscountTotal       pgtype.Numeric     `json:"promo_discount_total"`
	VatTotal                 pgtype.Numeric     `json:"vat_total"`
	DeliveryCharge           pgtype.Numeric     `json:"delivery_charge"`
	ServiceFee               pgtype.Numeric     `json:"service_fee"`
	TotalAmount              pgtype.Numeric     `json:"total_amount"`
	PromoID                  pgtype.UUID        `json:"promo_id"`
	PromoCode                sql.NullString     `json:"promo_code"`
	PromoSnapshot            []byte             `json:"promo_snapshot"`
	IsPriority               bool               `json:"is_priority"`
	IsReorder                bool               `json:"is_reorder"`
	CustomerNote             sql.NullString     `json:"customer_note"`
	RiderNote                sql.NullString     `json:"rider_note"`
	InternalNote             sql.NullString     `json:"internal_note"`
	CancellationReason       sql.NullString     `json:"cancellation_reason"`
	CancelledBy              NullActorType      `json:"cancelled_by"`
	RejectionReason          sql.NullString     `json:"rejection_reason"`
	RejectedBy               NullActorType      `json:"rejected_by"`
	AutoConfirmAt            pgtype.Timestamptz `json:"auto_confirm_at"`
	EstimatedDeliveryMinutes *int32             `json:"estimated_delivery_minutes"`
	ConfirmedAt              pgtype.Timestamptz `json:"confirmed_at"`
	PreparingAt              pgtype.Timestamptz `json:"preparing_at"`
	ReadyAt                  pgtype.Timestamptz `json:"ready_at"`
	PickedAt                 pgtype.Timestamptz `json:"picked_at"`
	DeliveredAt              pgtype.Timestamptz `json:"delivered_at"`
	CancelledAt              pgtype.Timestamptz `json:"cancelled_at"`
	CreatedAt                time.Time          `json:"created_at"`
	UpdatedAt                time.Time          `json:"updated_at"`
	DeletedAt                pgtype.Timestamptz `json:"deleted_at"`
}

type OrderAnalytic struct {
	ID                    uuid.UUID          `json:"id"`
	TenantID              uuid.UUID          `json:"tenant_id"`
	OrderID               uuid.UUID          `json:"order_id"`
	RestaurantIds         []uuid.UUID        `json:"restaurant_ids"`
	CustomerID            uuid.UUID          `json:"customer_id"`
	RiderID               pgtype.UUID        `json:"rider_id"`
	HubID                 pgtype.UUID        `json:"hub_id"`
	DeliveryArea          sql.NullString     `json:"delivery_area"`
	PaymentMethod         string             `json:"payment_method"`
	Platform              string             `json:"platform"`
	PromoCode             sql.NullString     `json:"promo_code"`
	Subtotal              pgtype.Numeric     `json:"subtotal"`
	ItemDiscount          pgtype.Numeric     `json:"item_discount"`
	PromoDiscount         pgtype.Numeric     `json:"promo_discount"`
	DeliveryCharge        pgtype.Numeric     `json:"delivery_charge"`
	VatTotal              pgtype.Numeric     `json:"vat_total"`
	TotalAmount           pgtype.Numeric     `json:"total_amount"`
	CommissionTotal       pgtype.Numeric     `json:"commission_total"`
	ConfirmationDurationS *int32             `json:"confirmation_duration_s"`
	PreparationDurationS  *int32             `json:"preparation_duration_s"`
	PickupToDeliveryS     *int32             `json:"pickup_to_delivery_s"`
	TotalFulfillmentS     *int32             `json:"total_fulfillment_s"`
	FinalStatus           string             `json:"final_status"`
	CancellationReason    sql.NullString     `json:"cancellation_reason"`
	OrderDate             pgtype.Date        `json:"order_date"`
	OrderHour             int16              `json:"order_hour"`
	OrderDayOfWeek        int16              `json:"order_day_of_week"`
	OrderWeek             int32              `json:"order_week"`
	OrderMonth            int16              `json:"order_month"`
	OrderYear             int16              `json:"order_year"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
	CreatedAt             time.Time          `json:"created_at"`
}

type OrderIssue struct {
	ID                      uuid.UUID          `json:"id"`
	OrderID                 uuid.UUID          `json:"order_id"`
	TenantID                uuid.UUID          `json:"tenant_id"`
	IssueType               IssueType          `json:"issue_type"`
	ReportedByID            uuid.UUID          `json:"reported_by_id"`
	Details                 string             `json:"details"`
	EvidenceUrls            []string           `json:"evidence_urls"`
	AccountableParty        Accountable        `json:"accountable_party"`
	RefundItems             []byte             `json:"refund_items"`
	RefundAmount            pgtype.Numeric     `json:"refund_amount"`
	RefundStatus            RefundStatus       `json:"refund_status"`
	RestaurantPenaltyAmount pgtype.Numeric     `json:"restaurant_penalty_amount"`
	RiderPenaltyAmount      pgtype.Numeric     `json:"rider_penalty_amount"`
	Status                  IssueStatus        `json:"status"`
	ResolutionNote          sql.NullString     `json:"resolution_note"`
	ResolvedByID            pgtype.UUID        `json:"resolved_by_id"`
	ResolvedAt              pgtype.Timestamptz `json:"resolved_at"`
	CreatedAt               time.Time          `json:"created_at"`
	UpdatedAt               time.Time          `json:"updated_at"`
}

type OrderIssueMessage struct {
	ID          uuid.UUID `json:"id"`
	IssueID     uuid.UUID `json:"issue_id"`
	TenantID    uuid.UUID `json:"tenant_id"`
	SenderID    uuid.UUID `json:"sender_id"`
	Message     string    `json:"message"`
	Attachments []string  `json:"attachments"`
	CreatedAt   time.Time `json:"created_at"`
}

type OrderItem struct {
	ID                  uuid.UUID       `json:"id"`
	OrderID             uuid.UUID       `json:"order_id"`
	RestaurantID        uuid.UUID       `json:"restaurant_id"`
	ProductID           uuid.UUID       `json:"product_id"`
	TenantID            uuid.UUID       `json:"tenant_id"`
	ProductName         string          `json:"product_name"`
	ProductSnapshot     json.RawMessage `json:"product_snapshot"`
	Quantity            int32           `json:"quantity"`
	UnitPrice           pgtype.Numeric  `json:"unit_price"`
	ModifierPrice       pgtype.Numeric  `json:"modifier_price"`
	ItemSubtotal        pgtype.Numeric  `json:"item_subtotal"`
	ItemDiscount        pgtype.Numeric  `json:"item_discount"`
	ItemVat             pgtype.Numeric  `json:"item_vat"`
	PromoDiscount       pgtype.Numeric  `json:"promo_discount"`
	ItemTotal           pgtype.Numeric  `json:"item_total"`
	SelectedModifiers   json.RawMessage `json:"selected_modifiers"`
	SpecialInstructions sql.NullString  `json:"special_instructions"`
	CreatedAt           time.Time       `json:"created_at"`
}

type OrderPickup struct {
	ID               uuid.UUID          `json:"id"`
	OrderID          uuid.UUID          `json:"order_id"`
	RestaurantID     uuid.UUID          `json:"restaurant_id"`
	TenantID         uuid.UUID          `json:"tenant_id"`
	PickupNumber     string             `json:"pickup_number"`
	Status           PickupStatus       `json:"status"`
	ItemsSubtotal    pgtype.Numeric     `json:"items_subtotal"`
	ItemsDiscount    pgtype.Numeric     `json:"items_discount"`
	ItemsVat         pgtype.Numeric     `json:"items_vat"`
	ItemsTotal       pgtype.Numeric     `json:"items_total"`
	CommissionRate   pgtype.Numeric     `json:"commission_rate"`
	CommissionAmount pgtype.Numeric     `json:"commission_amount"`
	ConfirmedAt      pgtype.Timestamptz `json:"confirmed_at"`
	PreparingAt      pgtype.Timestamptz `json:"preparing_at"`
	ReadyAt          pgtype.Timestamptz `json:"ready_at"`
	PickedAt         pgtype.Timestamptz `json:"picked_at"`
	RejectedAt       pgtype.Timestamptz `json:"rejected_at"`
	RejectionReason  sql.NullString     `json:"rejection_reason"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
}

type OrderTimelineEvent struct {
	ID             uuid.UUID       `json:"id"`
	OrderID        uuid.UUID       `json:"order_id"`
	TenantID       uuid.UUID       `json:"tenant_id"`
	EventType      string          `json:"event_type"`
	PreviousStatus NullOrderStatus `json:"previous_status"`
	NewStatus      NullOrderStatus `json:"new_status"`
	Description    string          `json:"description"`
	ActorID        pgtype.UUID     `json:"actor_id"`
	ActorType      ActorType       `json:"actor_type"`
	Metadata       json.RawMessage `json:"metadata"`
	CreatedAt      time.Time       `json:"created_at"`
}

type OtpVerification struct {
	ID          uuid.UUID          `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	Phone       string             `json:"phone"`
	Purpose     string             `json:"purpose"`
	OtpHash     string             `json:"otp_hash"`
	Attempts    int32              `json:"attempts"`
	MaxAttempts int32              `json:"max_attempts"`
	ExpiresAt   time.Time          `json:"expires_at"`
	VerifiedAt  pgtype.Timestamptz `json:"verified_at"`
	CreatedAt   time.Time          `json:"created_at"`
}

type OutboxEvent struct {
	ID            uuid.UUID          `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	AggregateType string             `json:"aggregate_type"`
	AggregateID   uuid.UUID          `json:"aggregate_id"`
	EventType     string             `json:"event_type"`
	Payload       json.RawMessage    `json:"payload"`
	Status        OutboxEventStatus  `json:"status"`
	Attempts      int32              `json:"attempts"`
	MaxAttempts   int32              `json:"max_attempts"`
	NextRetryAt   pgtype.Timestamptz `json:"next_retry_at"`
	LastError     sql.NullString     `json:"last_error"`
	ProcessedAt   pgtype.Timestamptz `json:"processed_at"`
	CreatedAt     time.Time          `json:"created_at"`
}

type PaymentTransaction struct {
	ID                   uuid.UUID          `json:"id"`
	TenantID             uuid.UUID          `json:"tenant_id"`
	OrderID              uuid.UUID          `json:"order_id"`
	UserID               uuid.UUID          `json:"user_id"`
	PaymentMethod        PaymentMethod      `json:"payment_method"`
	Status               TxnStatus          `json:"status"`
	Amount               pgtype.Numeric     `json:"amount"`
	Currency             string             `json:"currency"`
	GatewayTransactionID sql.NullString     `json:"gateway_transaction_id"`
	GatewayReferenceID   sql.NullString     `json:"gateway_reference_id"`
	GatewayResponse      []byte             `json:"gateway_response"`
	GatewayFee           pgtype.Numeric     `json:"gateway_fee"`
	IpAddress            *netip.Addr        `json:"ip_address"`
	UserAgent            sql.NullString     `json:"user_agent"`
	CallbackReceivedAt   pgtype.Timestamptz `json:"callback_received_at"`
	CreatedAt            time.Time          `json:"created_at"`
	UpdatedAt            time.Time          `json:"updated_at"`
}

type PlatformConfig struct {
	ID          uuid.UUID       `json:"id"`
	Key         string          `json:"key"`
	Value       json.RawMessage `json:"value"`
	Description sql.NullString  `json:"description"`
	IsPublic    bool            `json:"is_public"`
	UpdatedBy   pgtype.UUID     `json:"updated_by"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
}

type Product struct {
	ID              uuid.UUID      `json:"id"`
	TenantID        uuid.UUID      `json:"tenant_id"`
	RestaurantID    uuid.UUID      `json:"restaurant_id"`
	CategoryID      pgtype.UUID    `json:"category_id"`
	Name            string         `json:"name"`
	Slug            string         `json:"slug"`
	Description     sql.NullString `json:"description"`
	BasePrice       pgtype.Numeric `json:"base_price"`
	VatRate         pgtype.Numeric `json:"vat_rate"`
	HasModifiers    bool           `json:"has_modifiers"`
	Availability    ProductAvail   `json:"availability"`
	Images          []string       `json:"images"`
	Tags            []string       `json:"tags"`
	IsFeatured      bool           `json:"is_featured"`
	IsInvTracked    bool           `json:"is_inv_tracked"`
	SortOrder       int32          `json:"sort_order"`
	MetaTitle       sql.NullString `json:"meta_title"`
	MetaDescription sql.NullString `json:"meta_description"`
	RatingAvg       pgtype.Numeric `json:"rating_avg"`
	RatingCount     int32          `json:"rating_count"`
	OrderCount      int32          `json:"order_count"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
}

type ProductDiscount struct {
	ID             uuid.UUID          `json:"id"`
	ProductID      uuid.UUID          `json:"product_id"`
	RestaurantID   uuid.UUID          `json:"restaurant_id"`
	TenantID       uuid.UUID          `json:"tenant_id"`
	DiscountType   DiscountType       `json:"discount_type"`
	Amount         pgtype.Numeric     `json:"amount"`
	MaxDiscountCap pgtype.Numeric     `json:"max_discount_cap"`
	StartsAt       time.Time          `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
	IsActive       bool               `json:"is_active"`
	CreatedBy      pgtype.UUID        `json:"created_by"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

type ProductModifierGroup struct {
	ID          uuid.UUID      `json:"id"`
	ProductID   uuid.UUID      `json:"product_id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	MinRequired int32          `json:"min_required"`
	MaxAllowed  int32          `json:"max_allowed"`
	SortOrder   int32          `json:"sort_order"`
}

type ProductModifierOption struct {
	ID              uuid.UUID      `json:"id"`
	ModifierGroupID uuid.UUID      `json:"modifier_group_id"`
	ProductID       uuid.UUID      `json:"product_id"`
	TenantID        uuid.UUID      `json:"tenant_id"`
	Name            string         `json:"name"`
	AdditionalPrice pgtype.Numeric `json:"additional_price"`
	IsAvailable     bool           `json:"is_available"`
	SortOrder       int32          `json:"sort_order"`
}

type Promo struct {
	ID                 uuid.UUID          `json:"id"`
	TenantID           uuid.UUID          `json:"tenant_id"`
	Code               string             `json:"code"`
	Title              string             `json:"title"`
	Description        sql.NullString     `json:"description"`
	PromoType          PromoType          `json:"promo_type"`
	DiscountAmount     pgtype.Numeric     `json:"discount_amount"`
	MaxDiscountCap     pgtype.Numeric     `json:"max_discount_cap"`
	CashbackAmount     pgtype.Numeric     `json:"cashback_amount"`
	FundedBy           PromoFunder        `json:"funded_by"`
	AppliesTo          PromoApplyOn       `json:"applies_to"`
	MinOrderAmount     pgtype.Numeric     `json:"min_order_amount"`
	MaxTotalUses       *int32             `json:"max_total_uses"`
	MaxUsesPerUser     int32              `json:"max_uses_per_user"`
	IncludeStores      bool               `json:"include_stores"`
	IsActive           bool               `json:"is_active"`
	StartsAt           time.Time          `json:"starts_at"`
	EndsAt             pgtype.Timestamptz `json:"ends_at"`
	TotalUses          int32              `json:"total_uses"`
	TotalDiscountGiven pgtype.Numeric     `json:"total_discount_given"`
	CreatedBy          pgtype.UUID        `json:"created_by"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
}

type PromoCategoryRestriction struct {
	PromoID    uuid.UUID `json:"promo_id"`
	CategoryID uuid.UUID `json:"category_id"`
}

type PromoRestaurantRestriction struct {
	PromoID      uuid.UUID `json:"promo_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
}

type PromoUsage struct {
	ID             uuid.UUID      `json:"id"`
	PromoID        uuid.UUID      `json:"promo_id"`
	UserID         uuid.UUID      `json:"user_id"`
	OrderID        uuid.UUID      `json:"order_id"`
	TenantID       uuid.UUID      `json:"tenant_id"`
	DiscountAmount pgtype.Numeric `json:"discount_amount"`
	CashbackAmount pgtype.Numeric `json:"cashback_amount"`
	CreatedAt      time.Time      `json:"created_at"`
}

type PromoUserEligibility struct {
	PromoID uuid.UUID `json:"promo_id"`
	UserID  uuid.UUID `json:"user_id"`
}

type RefreshToken struct {
	ID         uuid.UUID          `json:"id"`
	UserID     uuid.UUID          `json:"user_id"`
	TenantID   pgtype.UUID        `json:"tenant_id"`
	TokenHash  string             `json:"token_hash"`
	DeviceInfo []byte             `json:"device_info"`
	IpAddress  *netip.Addr        `json:"ip_address"`
	ExpiresAt  time.Time          `json:"expires_at"`
	RevokedAt  pgtype.Timestamptz `json:"revoked_at"`
	CreatedAt  time.Time          `json:"created_at"`
}

type Refund struct {
	ID              uuid.UUID          `json:"id"`
	TenantID        uuid.UUID          `json:"tenant_id"`
	OrderID         uuid.UUID          `json:"order_id"`
	TransactionID   uuid.UUID          `json:"transaction_id"`
	IssueID         pgtype.UUID        `json:"issue_id"`
	Amount          pgtype.Numeric     `json:"amount"`
	Reason          string             `json:"reason"`
	Status          RefundStatus       `json:"status"`
	GatewayRefundID sql.NullString     `json:"gateway_refund_id"`
	ApprovedBy      pgtype.UUID        `json:"approved_by"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	ProcessedAt     pgtype.Timestamptz `json:"processed_at"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

type Restaurant struct {
	ID                  uuid.UUID      `json:"id"`
	TenantID            uuid.UUID      `json:"tenant_id"`
	HubID               pgtype.UUID    `json:"hub_id"`
	OwnerID             pgtype.UUID    `json:"owner_id"`
	Name                string         `json:"name"`
	Slug                string         `json:"slug"`
	Type                RestaurantType `json:"type"`
	Description         sql.NullString `json:"description"`
	ShortDescription    sql.NullString `json:"short_description"`
	BannerImageUrl      sql.NullString `json:"banner_image_url"`
	LogoUrl             sql.NullString `json:"logo_url"`
	GalleryUrls         []string       `json:"gallery_urls"`
	Phone               sql.NullString `json:"phone"`
	Email               sql.NullString `json:"email"`
	AddressLine1        sql.NullString `json:"address_line1"`
	AddressLine2        sql.NullString `json:"address_line2"`
	Area                sql.NullString `json:"area"`
	City                string         `json:"city"`
	GeoLat              pgtype.Numeric `json:"geo_lat"`
	GeoLng              pgtype.Numeric `json:"geo_lng"`
	Cuisines            []string       `json:"cuisines"`
	Tags                []string       `json:"tags"`
	CommissionRate      pgtype.Numeric `json:"commission_rate"`
	VatRate             pgtype.Numeric `json:"vat_rate"`
	IsVatInclusive      bool           `json:"is_vat_inclusive"`
	MinOrderAmount      pgtype.Numeric `json:"min_order_amount"`
	AvgPrepTimeMinutes  int32          `json:"avg_prep_time_minutes"`
	MaxConcurrentOrders int32          `json:"max_concurrent_orders"`
	AutoAcceptOrders    bool           `json:"auto_accept_orders"`
	OrderPrefix         sql.NullString `json:"order_prefix"`
	OrderSequence       int64          `json:"order_sequence"`
	IsAvailable         bool           `json:"is_available"`
	IsFeatured          bool           `json:"is_featured"`
	IsActive            bool           `json:"is_active"`
	SortOrder           int32          `json:"sort_order"`
	MetaTitle           sql.NullString `json:"meta_title"`
	MetaDescription     sql.NullString `json:"meta_description"`
	MetaKeywords        []string       `json:"meta_keywords"`
	RatingAvg           pgtype.Numeric `json:"rating_avg"`
	RatingCount         int32          `json:"rating_count"`
	TotalOrderCount     int32          `json:"total_order_count"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           time.Time      `json:"updated_at"`
	DeliveryManagedBy   string         `json:"delivery_managed_by"`
}

type RestaurantOperatingHour struct {
	ID           uuid.UUID   `json:"id"`
	RestaurantID uuid.UUID   `json:"restaurant_id"`
	TenantID     uuid.UUID   `json:"tenant_id"`
	DayOfWeek    int16       `json:"day_of_week"`
	OpenTime     pgtype.Time `json:"open_time"`
	CloseTime    pgtype.Time `json:"close_time"`
	IsClosed     bool        `json:"is_closed"`
}

type RestaurantStaffAssignment struct {
	ID           uuid.UUID   `json:"id"`
	RestaurantID uuid.UUID   `json:"restaurant_id"`
	UserID       uuid.UUID   `json:"user_id"`
	TenantID     uuid.UUID   `json:"tenant_id"`
	Role         UserRole    `json:"role"`
	AssignedBy   pgtype.UUID `json:"assigned_by"`
	AssignedAt   time.Time   `json:"assigned_at"`
}

type Review struct {
	ID                uuid.UUID          `json:"id"`
	TenantID          uuid.UUID          `json:"tenant_id"`
	OrderID           uuid.UUID          `json:"order_id"`
	UserID            uuid.UUID          `json:"user_id"`
	RestaurantID      uuid.UUID          `json:"restaurant_id"`
	RestaurantRating  int16              `json:"restaurant_rating"`
	RiderRating       *int16             `json:"rider_rating"`
	Comment           sql.NullString     `json:"comment"`
	RestaurantReply   sql.NullString     `json:"restaurant_reply"`
	RestaurantReplyAt pgtype.Timestamptz `json:"restaurant_reply_at"`
	Images            []string           `json:"images"`
	IsPublished       bool               `json:"is_published"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
}

type Rider struct {
	ID                  uuid.UUID      `json:"id"`
	UserID              uuid.UUID      `json:"user_id"`
	TenantID            uuid.UUID      `json:"tenant_id"`
	HubID               pgtype.UUID    `json:"hub_id"`
	VehicleType         VehicleType    `json:"vehicle_type"`
	VehicleRegistration sql.NullString `json:"vehicle_registration"`
	LicenseNumber       sql.NullString `json:"license_number"`
	NidNumber           sql.NullString `json:"nid_number"`
	NidVerified         bool           `json:"nid_verified"`
	IsAvailable         bool           `json:"is_available"`
	IsOnDuty            bool           `json:"is_on_duty"`
	TotalOrderCount     int32          `json:"total_order_count"`
	TotalEarnings       pgtype.Numeric `json:"total_earnings"`
	PendingBalance      pgtype.Numeric `json:"pending_balance"`
	RatingAvg           pgtype.Numeric `json:"rating_avg"`
	RatingCount         int32          `json:"rating_count"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           time.Time      `json:"updated_at"`
}

type RiderAttendance struct {
	ID              uuid.UUID          `json:"id"`
	RiderID         uuid.UUID          `json:"rider_id"`
	TenantID        uuid.UUID          `json:"tenant_id"`
	WorkDate        pgtype.Date        `json:"work_date"`
	CheckedInAt     pgtype.Timestamptz `json:"checked_in_at"`
	CheckedOutAt    pgtype.Timestamptz `json:"checked_out_at"`
	TotalHours      pgtype.Numeric     `json:"total_hours"`
	TotalDistanceKm pgtype.Numeric     `json:"total_distance_km"`
	CompletedOrders int32              `json:"completed_orders"`
	CancelledOrders int32              `json:"cancelled_orders"`
	Earnings        pgtype.Numeric     `json:"earnings"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
}

type RiderEarning struct {
	ID            uuid.UUID      `json:"id"`
	RiderID       uuid.UUID      `json:"rider_id"`
	TenantID      uuid.UUID      `json:"tenant_id"`
	OrderID       uuid.UUID      `json:"order_id"`
	BaseEarning   pgtype.Numeric `json:"base_earning"`
	DistanceBonus pgtype.Numeric `json:"distance_bonus"`
	PeakBonus     pgtype.Numeric `json:"peak_bonus"`
	TipAmount     pgtype.Numeric `json:"tip_amount"`
	TotalEarning  pgtype.Numeric `json:"total_earning"`
	IsPaidOut     bool           `json:"is_paid_out"`
	PayoutID      pgtype.UUID    `json:"payout_id"`
	CreatedAt     time.Time      `json:"created_at"`
}

type RiderLocation struct {
	RiderID        uuid.UUID      `json:"rider_id"`
	TenantID       uuid.UUID      `json:"tenant_id"`
	GeoLat         pgtype.Numeric `json:"geo_lat"`
	GeoLng         pgtype.Numeric `json:"geo_lng"`
	Heading        pgtype.Numeric `json:"heading"`
	SpeedKmh       pgtype.Numeric `json:"speed_kmh"`
	AccuracyMeters pgtype.Numeric `json:"accuracy_meters"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

type RiderLocationHistory struct {
	ID                 uuid.UUID      `json:"id"`
	RiderID            uuid.UUID      `json:"rider_id"`
	TenantID           uuid.UUID      `json:"tenant_id"`
	OrderID            pgtype.UUID    `json:"order_id"`
	GeoLat             pgtype.Numeric `json:"geo_lat"`
	GeoLng             pgtype.Numeric `json:"geo_lng"`
	EventType          RiderSubject   `json:"event_type"`
	DistanceFromPrevKm pgtype.Numeric `json:"distance_from_prev_km"`
	CreatedAt          time.Time      `json:"created_at"`
}

type RiderPayout struct {
	ID               uuid.UUID          `json:"id"`
	RiderID          uuid.UUID          `json:"rider_id"`
	TenantID         uuid.UUID          `json:"tenant_id"`
	Amount           pgtype.Numeric     `json:"amount"`
	EarningsFrom     pgtype.Date        `json:"earnings_from"`
	EarningsTo       pgtype.Date        `json:"earnings_to"`
	PaymentMethod    string             `json:"payment_method"`
	PaymentReference sql.NullString     `json:"payment_reference"`
	Status           PayoutStatus       `json:"status"`
	ProcessedBy      pgtype.UUID        `json:"processed_by"`
	ProcessedAt      pgtype.Timestamptz `json:"processed_at"`
	Note             sql.NullString     `json:"note"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
}

type RiderPenalty struct {
	ID         uuid.UUID          `json:"id"`
	RiderID    uuid.UUID          `json:"rider_id"`
	TenantID   uuid.UUID          `json:"tenant_id"`
	OrderID    pgtype.UUID        `json:"order_id"`
	IssueID    pgtype.UUID        `json:"issue_id"`
	Reason     string             `json:"reason"`
	Amount     pgtype.Numeric     `json:"amount"`
	Status     PenaltyStatus      `json:"status"`
	AppealNote sql.NullString     `json:"appeal_note"`
	AppealedAt pgtype.Timestamptz `json:"appealed_at"`
	ClearedAt  pgtype.Timestamptz `json:"cleared_at"`
	ClearedBy  pgtype.UUID        `json:"cleared_by"`
	CreatedAt  time.Time          `json:"created_at"`
	UpdatedAt  time.Time          `json:"updated_at"`
}

type SearchLog struct {
	ID          uuid.UUID       `json:"id"`
	TenantID    uuid.UUID       `json:"tenant_id"`
	UserID      pgtype.UUID     `json:"user_id"`
	Query       string          `json:"query"`
	SearchType  string          `json:"search_type"`
	ResultCount int32           `json:"result_count"`
	Filters     json.RawMessage `json:"filters"`
	CreatedAt   time.Time       `json:"created_at"`
}

type Story struct {
	ID           uuid.UUID          `json:"id"`
	TenantID     uuid.UUID          `json:"tenant_id"`
	RestaurantID pgtype.UUID        `json:"restaurant_id"`
	Title        sql.NullString     `json:"title"`
	MediaUrl     string             `json:"media_url"`
	MediaType    MediaType          `json:"media_type"`
	ThumbnailUrl sql.NullString     `json:"thumbnail_url"`
	LinkType     NullLinkTargetType `json:"link_type"`
	LinkValue    sql.NullString     `json:"link_value"`
	ExpiresAt    time.Time          `json:"expires_at"`
	SortOrder    int32              `json:"sort_order"`
	ViewCount    int32              `json:"view_count"`
	IsActive     bool               `json:"is_active"`
	CreatedAt    time.Time          `json:"created_at"`
}

type SubscriptionPlan struct {
	ID             uuid.UUID       `json:"id"`
	Name           string          `json:"name"`
	Slug           string          `json:"slug"`
	Description    sql.NullString  `json:"description"`
	PriceMonthly   pgtype.Numeric  `json:"price_monthly"`
	PriceAnnual    pgtype.Numeric  `json:"price_annual"`
	MaxRestaurants *int32          `json:"max_restaurants"`
	MaxRiders      *int32          `json:"max_riders"`
	CommissionRate pgtype.Numeric  `json:"commission_rate"`
	Features       json.RawMessage `json:"features"`
	IsActive       bool            `json:"is_active"`
	SortOrder      int32           `json:"sort_order"`
	CreatedAt      time.Time       `json:"created_at"`
	UpdatedAt      time.Time       `json:"updated_at"`
}

type Tenant struct {
	ID                 uuid.UUID       `json:"id"`
	Slug               string          `json:"slug"`
	Name               string          `json:"name"`
	Status             TenantStatus    `json:"status"`
	Plan               TenantPlan      `json:"plan"`
	SubscriptionPlanID pgtype.UUID     `json:"subscription_plan_id"`
	CommissionRate     pgtype.Numeric  `json:"commission_rate"`
	Settings           json.RawMessage `json:"settings"`
	CustomDomain       sql.NullString  `json:"custom_domain"`
	LogoUrl            sql.NullString  `json:"logo_url"`
	FaviconUrl         sql.NullString  `json:"favicon_url"`
	PrimaryColor       string          `json:"primary_color"`
	SecondaryColor     string          `json:"secondary_color"`
	ContactEmail       string          `json:"contact_email"`
	ContactPhone       sql.NullString  `json:"contact_phone"`
	Address            []byte          `json:"address"`
	Timezone           string          `json:"timezone"`
	Currency           string          `json:"currency"`
	Locale             string          `json:"locale"`
	CreatedAt          time.Time       `json:"created_at"`
	UpdatedAt          time.Time       `json:"updated_at"`
	BillingDay         int32           `json:"billing_day"`
}

type CashCollectionRecord struct {
	ID          uuid.UUID          `json:"id"`
	TenantID    uuid.UUID          `json:"tenant_id"`
	RiderID     uuid.UUID          `json:"rider_id"`
	OrderID     uuid.UUID          `json:"order_id"`
	Amount      pgtype.Numeric     `json:"amount"`
	Status      string             `json:"status"`
	CollectedAt time.Time          `json:"collected_at"`
	RemittedAt  pgtype.Timestamptz `json:"remitted_at"`
}

type ReconciliationAlert struct {
	ID                   uuid.UUID          `json:"id"`
	TenantID             pgtype.UUID        `json:"tenant_id"`
	PaymentTransactionID pgtype.UUID        `json:"payment_transaction_id"`
	AlertType            string             `json:"alert_type"`
	Status               string             `json:"status"`
	ResolutionNotes      sql.NullString     `json:"resolution_notes"`
	ResolvedBy           pgtype.UUID        `json:"resolved_by"`
	ResolvedAt           pgtype.Timestamptz `json:"resolved_at"`
	CreatedAt            time.Time          `json:"created_at"`
}

type SubscriptionInvoice struct {
	ID                 uuid.UUID          `json:"id"`
	TenantID           uuid.UUID          `json:"tenant_id"`
	Amount             pgtype.Numeric     `json:"amount"`
	Status             string             `json:"status"`
	BillingPeriodStart pgtype.Date        `json:"billing_period_start"`
	BillingPeriodEnd   pgtype.Date        `json:"billing_period_end"`
	DueDate            pgtype.Date        `json:"due_date"`
	PaidAt             pgtype.Timestamptz `json:"paid_at"`
	CreatedAt          time.Time          `json:"created_at"`
}

type TenantPaymentGateway struct {
	ID         uuid.UUID       `json:"id"`
	TenantID   uuid.UUID       `json:"tenant_id"`
	Gateway    string          `json:"gateway"`
	IsEnabled  bool            `json:"is_enabled"`
	IsTestMode bool            `json:"is_test_mode"`
	Config     json.RawMessage `json:"config"`
	CreatedAt  time.Time       `json:"created_at"`
	UpdatedAt  time.Time       `json:"updated_at"`
}

type TenantSubscription struct {
	ID                 uuid.UUID          `json:"id"`
	TenantID           uuid.UUID          `json:"tenant_id"`
	PlanID             uuid.UUID          `json:"plan_id"`
	BillingCycle       BillingCycle       `json:"billing_cycle"`
	Status             SubscriptionStatus `json:"status"`
	TrialEndsAt        pgtype.Timestamptz `json:"trial_ends_at"`
	CurrentPeriodStart pgtype.Date        `json:"current_period_start"`
	CurrentPeriodEnd   pgtype.Date        `json:"current_period_end"`
	NextBillingDate    pgtype.Date        `json:"next_billing_date"`
	CancelledAt        pgtype.Timestamptz `json:"cancelled_at"`
	CancellationReason sql.NullString     `json:"cancellation_reason"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
}

type User struct {
	ID               uuid.UUID          `json:"id"`
	TenantID         pgtype.UUID        `json:"tenant_id"`
	Phone            sql.NullString     `json:"phone"`
	Email            sql.NullString     `json:"email"`
	Name             string             `json:"name"`
	PasswordHash     sql.NullString     `json:"password_hash"`
	Role             UserRole           `json:"role"`
	Status           UserStatus         `json:"status"`
	Gender           NullGenderType     `json:"gender"`
	DateOfBirth      pgtype.Date        `json:"date_of_birth"`
	AvatarUrl        sql.NullString     `json:"avatar_url"`
	DevicePushToken  sql.NullString     `json:"device_push_token"`
	DevicePlatform   sql.NullString     `json:"device_platform"`
	DeviceModel      sql.NullString     `json:"device_model"`
	DeviceAppVersion sql.NullString     `json:"device_app_version"`
	LastLoginAt      pgtype.Timestamptz `json:"last_login_at"`
	LastLoginIp      *netip.Addr        `json:"last_login_ip"`
	EmailVerifiedAt  pgtype.Timestamptz `json:"email_verified_at"`
	PhoneVerifiedAt  pgtype.Timestamptz `json:"phone_verified_at"`
	TwoFactorEnabled bool               `json:"two_factor_enabled"`
	TwoFactorSecret  sql.NullString     `json:"two_factor_secret"`
	ReferralCode     sql.NullString     `json:"referral_code"`
	ReferredByID     pgtype.UUID        `json:"referred_by_id"`
	WalletBalance    pgtype.Numeric     `json:"wallet_balance"`
	TotalOrderCount  int32              `json:"total_order_count"`
	TotalSpentAmount pgtype.Numeric     `json:"total_spent_amount"`
	LastOrderAt      pgtype.Timestamptz `json:"last_order_at"`
	Metadata         json.RawMessage    `json:"metadata"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

type UserAddress struct {
	ID             uuid.UUID      `json:"id"`
	UserID         uuid.UUID      `json:"user_id"`
	TenantID       uuid.UUID      `json:"tenant_id"`
	Label          string         `json:"label"`
	RecipientName  sql.NullString `json:"recipient_name"`
	RecipientPhone sql.NullString `json:"recipient_phone"`
	AddressLine1   string         `json:"address_line1"`
	AddressLine2   sql.NullString `json:"address_line2"`
	Area           string         `json:"area"`
	City           string         `json:"city"`
	GeoLat         pgtype.Numeric `json:"geo_lat"`
	GeoLng         pgtype.Numeric `json:"geo_lng"`
	GeoDisplayAddr sql.NullString `json:"geo_display_addr"`
	IsDefault      bool           `json:"is_default"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

type UserFavourite struct {
	UserID       uuid.UUID `json:"user_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
	CreatedAt    time.Time `json:"created_at"`
}

type WalletTransaction struct {
	ID           uuid.UUID          `json:"id"`
	UserID       uuid.UUID          `json:"user_id"`
	TenantID     uuid.UUID          `json:"tenant_id"`
	OrderID      pgtype.UUID        `json:"order_id"`
	Type         WalletType         `json:"type"`
	Source       WalletSource       `json:"source"`
	Amount       pgtype.Numeric     `json:"amount"`
	BalanceAfter pgtype.Numeric     `json:"balance_after"`
	Description  sql.NullString     `json:"description"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	CreatedAt    time.Time          `json:"created_at"`
}
