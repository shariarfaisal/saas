// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rider_locations.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const appendLocationHistory = `-- name: AppendLocationHistory :one
INSERT INTO rider_location_history (rider_id, tenant_id, order_id, geo_lat, geo_lng, event_type, distance_from_prev_km)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, rider_id, tenant_id, order_id, geo_lat, geo_lng, event_type, distance_from_prev_km, created_at
`

type AppendLocationHistoryParams struct {
	RiderID            uuid.UUID      `json:"rider_id"`
	TenantID           uuid.UUID      `json:"tenant_id"`
	OrderID            pgtype.UUID    `json:"order_id"`
	GeoLat             pgtype.Numeric `json:"geo_lat"`
	GeoLng             pgtype.Numeric `json:"geo_lng"`
	EventType          RiderSubject   `json:"event_type"`
	DistanceFromPrevKm pgtype.Numeric `json:"distance_from_prev_km"`
}

func (q *Queries) AppendLocationHistory(ctx context.Context, arg AppendLocationHistoryParams) (RiderLocationHistory, error) {
	row := q.db.QueryRow(ctx, appendLocationHistory,
		arg.RiderID,
		arg.TenantID,
		arg.OrderID,
		arg.GeoLat,
		arg.GeoLng,
		arg.EventType,
		arg.DistanceFromPrevKm,
	)
	var i RiderLocationHistory
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.TenantID,
		&i.OrderID,
		&i.GeoLat,
		&i.GeoLng,
		&i.EventType,
		&i.DistanceFromPrevKm,
		&i.CreatedAt,
	)
	return i, err
}

const getRiderLocation = `-- name: GetRiderLocation :one
SELECT rider_id, tenant_id, geo_lat, geo_lng, heading, speed_kmh, accuracy_meters, updated_at FROM rider_locations WHERE rider_id = $1 LIMIT 1
`

func (q *Queries) GetRiderLocation(ctx context.Context, riderID uuid.UUID) (RiderLocation, error) {
	row := q.db.QueryRow(ctx, getRiderLocation, riderID)
	var i RiderLocation
	err := row.Scan(
		&i.RiderID,
		&i.TenantID,
		&i.GeoLat,
		&i.GeoLng,
		&i.Heading,
		&i.SpeedKmh,
		&i.AccuracyMeters,
		&i.UpdatedAt,
	)
	return i, err
}

const listLocationHistoryByRider = `-- name: ListLocationHistoryByRider :many
SELECT id, rider_id, tenant_id, order_id, geo_lat, geo_lng, event_type, distance_from_prev_km, created_at FROM rider_location_history
WHERE rider_id = $1 AND created_at >= $3::timestamptz
ORDER BY created_at DESC
LIMIT $2
`

type ListLocationHistoryByRiderParams struct {
	RiderID uuid.UUID `json:"rider_id"`
	Limit   int32     `json:"limit"`
	Since   time.Time `json:"since"`
}

func (q *Queries) ListLocationHistoryByRider(ctx context.Context, arg ListLocationHistoryByRiderParams) ([]RiderLocationHistory, error) {
	rows, err := q.db.Query(ctx, listLocationHistoryByRider, arg.RiderID, arg.Limit, arg.Since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiderLocationHistory{}
	for rows.Next() {
		var i RiderLocationHistory
		if err := rows.Scan(
			&i.ID,
			&i.RiderID,
			&i.TenantID,
			&i.OrderID,
			&i.GeoLat,
			&i.GeoLng,
			&i.EventType,
			&i.DistanceFromPrevKm,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRiderLocationsByTenant = `-- name: ListRiderLocationsByTenant :many
SELECT rider_id, tenant_id, geo_lat, geo_lng, heading, speed_kmh, accuracy_meters, updated_at FROM rider_locations WHERE tenant_id = $1 ORDER BY updated_at DESC
`

func (q *Queries) ListRiderLocationsByTenant(ctx context.Context, tenantID uuid.UUID) ([]RiderLocation, error) {
	rows, err := q.db.Query(ctx, listRiderLocationsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiderLocation{}
	for rows.Next() {
		var i RiderLocation
		if err := rows.Scan(
			&i.RiderID,
			&i.TenantID,
			&i.GeoLat,
			&i.GeoLng,
			&i.Heading,
			&i.SpeedKmh,
			&i.AccuracyMeters,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRiderLocation = `-- name: UpsertRiderLocation :one
INSERT INTO rider_locations (rider_id, tenant_id, geo_lat, geo_lng, heading, speed_kmh, accuracy_meters)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (rider_id) DO UPDATE SET
  geo_lat = EXCLUDED.geo_lat,
  geo_lng = EXCLUDED.geo_lng,
  heading = EXCLUDED.heading,
  speed_kmh = EXCLUDED.speed_kmh,
  accuracy_meters = EXCLUDED.accuracy_meters,
  updated_at = NOW()
RETURNING rider_id, tenant_id, geo_lat, geo_lng, heading, speed_kmh, accuracy_meters, updated_at
`

type UpsertRiderLocationParams struct {
	RiderID        uuid.UUID      `json:"rider_id"`
	TenantID       uuid.UUID      `json:"tenant_id"`
	GeoLat         pgtype.Numeric `json:"geo_lat"`
	GeoLng         pgtype.Numeric `json:"geo_lng"`
	Heading        pgtype.Numeric `json:"heading"`
	SpeedKmh       pgtype.Numeric `json:"speed_kmh"`
	AccuracyMeters pgtype.Numeric `json:"accuracy_meters"`
}

func (q *Queries) UpsertRiderLocation(ctx context.Context, arg UpsertRiderLocationParams) (RiderLocation, error) {
	row := q.db.QueryRow(ctx, upsertRiderLocation,
		arg.RiderID,
		arg.TenantID,
		arg.GeoLat,
		arg.GeoLng,
		arg.Heading,
		arg.SpeedKmh,
		arg.AccuracyMeters,
	)
	var i RiderLocation
	err := row.Scan(
		&i.RiderID,
		&i.TenantID,
		&i.GeoLat,
		&i.GeoLng,
		&i.Heading,
		&i.SpeedKmh,
		&i.AccuracyMeters,
		&i.UpdatedAt,
	)
	return i, err
}
