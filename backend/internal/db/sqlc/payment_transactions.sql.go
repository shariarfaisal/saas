// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment_transactions.sql

package sqlc

import (
	"context"
	"database/sql"
	"net/netip"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO payment_transactions (
    tenant_id, order_id, user_id, payment_method, status, amount, currency,
    gateway_transaction_id, gateway_reference_id, gateway_response, gateway_fee,
    ip_address, user_agent
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, tenant_id, order_id, user_id, payment_method, status, amount, currency, gateway_transaction_id, gateway_reference_id, gateway_response, gateway_fee, ip_address, user_agent, callback_received_at, created_at, updated_at
`

type CreateTransactionParams struct {
	TenantID             uuid.UUID      `json:"tenant_id"`
	OrderID              uuid.UUID      `json:"order_id"`
	UserID               uuid.UUID      `json:"user_id"`
	PaymentMethod        PaymentMethod  `json:"payment_method"`
	Status               TxnStatus      `json:"status"`
	Amount               pgtype.Numeric `json:"amount"`
	Currency             string         `json:"currency"`
	GatewayTransactionID sql.NullString `json:"gateway_transaction_id"`
	GatewayReferenceID   sql.NullString `json:"gateway_reference_id"`
	GatewayResponse      []byte         `json:"gateway_response"`
	GatewayFee           pgtype.Numeric `json:"gateway_fee"`
	IpAddress            *netip.Addr    `json:"ip_address"`
	UserAgent            sql.NullString `json:"user_agent"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.TenantID,
		arg.OrderID,
		arg.UserID,
		arg.PaymentMethod,
		arg.Status,
		arg.Amount,
		arg.Currency,
		arg.GatewayTransactionID,
		arg.GatewayReferenceID,
		arg.GatewayResponse,
		arg.GatewayFee,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.UserID,
		&i.PaymentMethod,
		&i.Status,
		&i.Amount,
		&i.Currency,
		&i.GatewayTransactionID,
		&i.GatewayReferenceID,
		&i.GatewayResponse,
		&i.GatewayFee,
		&i.IpAddress,
		&i.UserAgent,
		&i.CallbackReceivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByGatewayID = `-- name: GetTransactionByGatewayID :one
SELECT id, tenant_id, order_id, user_id, payment_method, status, amount, currency, gateway_transaction_id, gateway_reference_id, gateway_response, gateway_fee, ip_address, user_agent, callback_received_at, created_at, updated_at FROM payment_transactions
WHERE gateway_transaction_id = $1 AND tenant_id = $2
LIMIT 1
`

type GetTransactionByGatewayIDParams struct {
	GatewayTransactionID sql.NullString `json:"gateway_transaction_id"`
	TenantID             uuid.UUID      `json:"tenant_id"`
}

func (q *Queries) GetTransactionByGatewayID(ctx context.Context, arg GetTransactionByGatewayIDParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByGatewayID, arg.GatewayTransactionID, arg.TenantID)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.UserID,
		&i.PaymentMethod,
		&i.Status,
		&i.Amount,
		&i.Currency,
		&i.GatewayTransactionID,
		&i.GatewayReferenceID,
		&i.GatewayResponse,
		&i.GatewayFee,
		&i.IpAddress,
		&i.UserAgent,
		&i.CallbackReceivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, tenant_id, order_id, user_id, payment_method, status, amount, currency, gateway_transaction_id, gateway_reference_id, gateway_response, gateway_fee, ip_address, user_agent, callback_received_at, created_at, updated_at FROM payment_transactions
WHERE id = $1 AND tenant_id = $2
LIMIT 1
`

type GetTransactionByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetTransactionByID(ctx context.Context, arg GetTransactionByIDParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, arg.ID, arg.TenantID)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.UserID,
		&i.PaymentMethod,
		&i.Status,
		&i.Amount,
		&i.Currency,
		&i.GatewayTransactionID,
		&i.GatewayReferenceID,
		&i.GatewayResponse,
		&i.GatewayFee,
		&i.IpAddress,
		&i.UserAgent,
		&i.CallbackReceivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByOrderID = `-- name: GetTransactionByOrderID :one
SELECT id, tenant_id, order_id, user_id, payment_method, status, amount, currency, gateway_transaction_id, gateway_reference_id, gateway_response, gateway_fee, ip_address, user_agent, callback_received_at, created_at, updated_at FROM payment_transactions
WHERE order_id = $1 AND tenant_id = $2 AND status = 'success'
LIMIT 1
`

type GetTransactionByOrderIDParams struct {
	OrderID  uuid.UUID `json:"order_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetTransactionByOrderID(ctx context.Context, arg GetTransactionByOrderIDParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByOrderID, arg.OrderID, arg.TenantID)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.UserID,
		&i.PaymentMethod,
		&i.Status,
		&i.Amount,
		&i.Currency,
		&i.GatewayTransactionID,
		&i.GatewayReferenceID,
		&i.GatewayResponse,
		&i.GatewayFee,
		&i.IpAddress,
		&i.UserAgent,
		&i.CallbackReceivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPendingTransactions = `-- name: ListPendingTransactions :many
SELECT id, tenant_id, order_id, user_id, payment_method, status, amount, currency, gateway_transaction_id, gateway_reference_id, gateway_response, gateway_fee, ip_address, user_agent, callback_received_at, created_at, updated_at FROM payment_transactions
WHERE status = 'pending' AND created_at < $2::timestamptz
ORDER BY created_at ASC
LIMIT $1
`

type ListPendingTransactionsParams struct {
	Limit     int32     `json:"limit"`
	OlderThan time.Time `json:"older_than"`
}

func (q *Queries) ListPendingTransactions(ctx context.Context, arg ListPendingTransactionsParams) ([]PaymentTransaction, error) {
	rows, err := q.db.Query(ctx, listPendingTransactions, arg.Limit, arg.OlderThan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentTransaction{}
	for rows.Next() {
		var i PaymentTransaction
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderID,
			&i.UserID,
			&i.PaymentMethod,
			&i.Status,
			&i.Amount,
			&i.Currency,
			&i.GatewayTransactionID,
			&i.GatewayReferenceID,
			&i.GatewayResponse,
			&i.GatewayFee,
			&i.IpAddress,
			&i.UserAgent,
			&i.CallbackReceivedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByOrder = `-- name: ListTransactionsByOrder :many
SELECT id, tenant_id, order_id, user_id, payment_method, status, amount, currency, gateway_transaction_id, gateway_reference_id, gateway_response, gateway_fee, ip_address, user_agent, callback_received_at, created_at, updated_at FROM payment_transactions
WHERE order_id = $1 AND tenant_id = $2
ORDER BY created_at DESC
`

type ListTransactionsByOrderParams struct {
	OrderID  uuid.UUID `json:"order_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ListTransactionsByOrder(ctx context.Context, arg ListTransactionsByOrderParams) ([]PaymentTransaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByOrder, arg.OrderID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentTransaction{}
	for rows.Next() {
		var i PaymentTransaction
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.OrderID,
			&i.UserID,
			&i.PaymentMethod,
			&i.Status,
			&i.Amount,
			&i.Currency,
			&i.GatewayTransactionID,
			&i.GatewayReferenceID,
			&i.GatewayResponse,
			&i.GatewayFee,
			&i.IpAddress,
			&i.UserAgent,
			&i.CallbackReceivedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE payment_transactions SET
    status = COALESCE($3, status),
    gateway_transaction_id = COALESCE($4, gateway_transaction_id),
    gateway_reference_id = COALESCE($5, gateway_reference_id),
    gateway_response = COALESCE($6, gateway_response),
    gateway_fee = COALESCE($7, gateway_fee),
    callback_received_at = COALESCE($8, callback_received_at)
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, order_id, user_id, payment_method, status, amount, currency, gateway_transaction_id, gateway_reference_id, gateway_response, gateway_fee, ip_address, user_agent, callback_received_at, created_at, updated_at
`

type UpdateTransactionStatusParams struct {
	ID                   uuid.UUID          `json:"id"`
	TenantID             uuid.UUID          `json:"tenant_id"`
	Status               NullTxnStatus      `json:"status"`
	GatewayTransactionID sql.NullString     `json:"gateway_transaction_id"`
	GatewayReferenceID   sql.NullString     `json:"gateway_reference_id"`
	GatewayResponse      []byte             `json:"gateway_response"`
	GatewayFee           pgtype.Numeric     `json:"gateway_fee"`
	CallbackReceivedAt   pgtype.Timestamptz `json:"callback_received_at"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (PaymentTransaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionStatus,
		arg.ID,
		arg.TenantID,
		arg.Status,
		arg.GatewayTransactionID,
		arg.GatewayReferenceID,
		arg.GatewayResponse,
		arg.GatewayFee,
		arg.CallbackReceivedAt,
	)
	var i PaymentTransaction
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.UserID,
		&i.PaymentMethod,
		&i.Status,
		&i.Amount,
		&i.Currency,
		&i.GatewayTransactionID,
		&i.GatewayReferenceID,
		&i.GatewayResponse,
		&i.GatewayFee,
		&i.IpAddress,
		&i.UserAgent,
		&i.CallbackReceivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
