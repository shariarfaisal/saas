// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invoices.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countInvoicesByRestaurant = `-- name: CountInvoicesByRestaurant :one
SELECT COUNT(*) FROM invoices WHERE restaurant_id = $1 AND tenant_id = $2
`

type CountInvoicesByRestaurantParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
}

func (q *Queries) CountInvoicesByRestaurant(ctx context.Context, arg CountInvoicesByRestaurantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByRestaurant, arg.RestaurantID, arg.TenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInvoicesByTenant = `-- name: CountInvoicesByTenant :one
SELECT COUNT(*) FROM invoices WHERE tenant_id = $1
`

func (q *Queries) CountInvoicesByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoicesByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrdersByRestaurantAndPeriod = `-- name: CountOrdersByRestaurantAndPeriod :one
SELECT
    COUNT(*)::INT AS total_orders,
    COUNT(CASE WHEN status = 'delivered' THEN 1 END)::INT AS delivered_orders,
    COUNT(CASE WHEN status = 'cancelled' THEN 1 END)::INT AS cancelled_orders,
    COUNT(CASE WHEN status = 'rejected' THEN 1 END)::INT AS rejected_orders
FROM orders
WHERE tenant_id = $1
  AND deleted_at IS NULL
  AND created_at >= $2::timestamptz
  AND created_at < $3::timestamptz
`

type CountOrdersByRestaurantAndPeriodParams struct {
	TenantID    uuid.UUID `json:"tenant_id"`
	PeriodStart time.Time `json:"period_start"`
	PeriodEnd   time.Time `json:"period_end"`
}

type CountOrdersByRestaurantAndPeriodRow struct {
	TotalOrders     int32 `json:"total_orders"`
	DeliveredOrders int32 `json:"delivered_orders"`
	CancelledOrders int32 `json:"cancelled_orders"`
	RejectedOrders  int32 `json:"rejected_orders"`
}

func (q *Queries) CountOrdersByRestaurantAndPeriod(ctx context.Context, arg CountOrdersByRestaurantAndPeriodParams) (CountOrdersByRestaurantAndPeriodRow, error) {
	row := q.db.QueryRow(ctx, countOrdersByRestaurantAndPeriod, arg.TenantID, arg.PeriodStart, arg.PeriodEnd)
	var i CountOrdersByRestaurantAndPeriodRow
	err := row.Scan(
		&i.TotalOrders,
		&i.DeliveredOrders,
		&i.CancelledOrders,
		&i.RejectedOrders,
	)
	return i, err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (
    tenant_id, restaurant_id, invoice_number, period_start, period_end,
    gross_sales, item_discounts, vendor_promo_discounts, net_sales, vat_collected,
    commission_rate, commission_amount, penalty_amount, adjustment_amount, adjustment_note,
    net_payable, total_orders, delivered_orders, cancelled_orders, rejected_orders,
    status, generated_by, notes, delivery_charge_total
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24
) RETURNING id, tenant_id, restaurant_id, invoice_number, period_start, period_end, gross_sales, item_discounts, vendor_promo_discounts, net_sales, vat_collected, commission_rate, commission_amount, penalty_amount, adjustment_amount, adjustment_note, net_payable, total_orders, delivered_orders, cancelled_orders, rejected_orders, status, generated_by, finalized_by, finalized_at, paid_by, paid_at, payment_reference, notes, created_at, updated_at, delivery_charge_total
`

type CreateInvoiceParams struct {
	TenantID             uuid.UUID      `json:"tenant_id"`
	RestaurantID         uuid.UUID      `json:"restaurant_id"`
	InvoiceNumber        string         `json:"invoice_number"`
	PeriodStart          pgtype.Date    `json:"period_start"`
	PeriodEnd            pgtype.Date    `json:"period_end"`
	GrossSales           pgtype.Numeric `json:"gross_sales"`
	ItemDiscounts        pgtype.Numeric `json:"item_discounts"`
	VendorPromoDiscounts pgtype.Numeric `json:"vendor_promo_discounts"`
	NetSales             pgtype.Numeric `json:"net_sales"`
	VatCollected         pgtype.Numeric `json:"vat_collected"`
	CommissionRate       pgtype.Numeric `json:"commission_rate"`
	CommissionAmount     pgtype.Numeric `json:"commission_amount"`
	PenaltyAmount        pgtype.Numeric `json:"penalty_amount"`
	AdjustmentAmount     pgtype.Numeric `json:"adjustment_amount"`
	AdjustmentNote       sql.NullString `json:"adjustment_note"`
	NetPayable           pgtype.Numeric `json:"net_payable"`
	TotalOrders          int32          `json:"total_orders"`
	DeliveredOrders      int32          `json:"delivered_orders"`
	CancelledOrders      int32          `json:"cancelled_orders"`
	RejectedOrders       int32          `json:"rejected_orders"`
	Status               InvoiceStatus  `json:"status"`
	GeneratedBy          pgtype.UUID    `json:"generated_by"`
	Notes                sql.NullString `json:"notes"`
	DeliveryChargeTotal  pgtype.Numeric `json:"delivery_charge_total"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.TenantID,
		arg.RestaurantID,
		arg.InvoiceNumber,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.GrossSales,
		arg.ItemDiscounts,
		arg.VendorPromoDiscounts,
		arg.NetSales,
		arg.VatCollected,
		arg.CommissionRate,
		arg.CommissionAmount,
		arg.PenaltyAmount,
		arg.AdjustmentAmount,
		arg.AdjustmentNote,
		arg.NetPayable,
		arg.TotalOrders,
		arg.DeliveredOrders,
		arg.CancelledOrders,
		arg.RejectedOrders,
		arg.Status,
		arg.GeneratedBy,
		arg.Notes,
		arg.DeliveryChargeTotal,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RestaurantID,
		&i.InvoiceNumber,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.GrossSales,
		&i.ItemDiscounts,
		&i.VendorPromoDiscounts,
		&i.NetSales,
		&i.VatCollected,
		&i.CommissionRate,
		&i.CommissionAmount,
		&i.PenaltyAmount,
		&i.AdjustmentAmount,
		&i.AdjustmentNote,
		&i.NetPayable,
		&i.TotalOrders,
		&i.DeliveredOrders,
		&i.CancelledOrders,
		&i.RejectedOrders,
		&i.Status,
		&i.GeneratedBy,
		&i.FinalizedBy,
		&i.FinalizedAt,
		&i.PaidBy,
		&i.PaidAt,
		&i.PaymentReference,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeliveryChargeTotal,
	)
	return i, err
}

const finalizeInvoice = `-- name: FinalizeInvoice :one
UPDATE invoices SET status = 'finalized', finalized_by = $3, finalized_at = NOW(), notes = COALESCE($4, notes)
WHERE id = $1 AND tenant_id = $2 AND status = 'draft'
RETURNING id, tenant_id, restaurant_id, invoice_number, period_start, period_end, gross_sales, item_discounts, vendor_promo_discounts, net_sales, vat_collected, commission_rate, commission_amount, penalty_amount, adjustment_amount, adjustment_note, net_payable, total_orders, delivered_orders, cancelled_orders, rejected_orders, status, generated_by, finalized_by, finalized_at, paid_by, paid_at, payment_reference, notes, created_at, updated_at, delivery_charge_total
`

type FinalizeInvoiceParams struct {
	ID          uuid.UUID      `json:"id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
	FinalizedBy pgtype.UUID    `json:"finalized_by"`
	Notes       sql.NullString `json:"notes"`
}

func (q *Queries) FinalizeInvoice(ctx context.Context, arg FinalizeInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, finalizeInvoice,
		arg.ID,
		arg.TenantID,
		arg.FinalizedBy,
		arg.Notes,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RestaurantID,
		&i.InvoiceNumber,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.GrossSales,
		&i.ItemDiscounts,
		&i.VendorPromoDiscounts,
		&i.NetSales,
		&i.VatCollected,
		&i.CommissionRate,
		&i.CommissionAmount,
		&i.PenaltyAmount,
		&i.AdjustmentAmount,
		&i.AdjustmentNote,
		&i.NetPayable,
		&i.TotalOrders,
		&i.DeliveredOrders,
		&i.CancelledOrders,
		&i.RejectedOrders,
		&i.Status,
		&i.GeneratedBy,
		&i.FinalizedBy,
		&i.FinalizedAt,
		&i.PaidBy,
		&i.PaidAt,
		&i.PaymentReference,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeliveryChargeTotal,
	)
	return i, err
}

const getFinanceSummary = `-- name: GetFinanceSummary :one
SELECT
    COALESCE(SUM(CASE WHEN status = 'draft' THEN net_payable ELSE 0 END), 0)::NUMERIC(14,2) AS pending_amount,
    COALESCE(SUM(CASE WHEN status = 'finalized' THEN net_payable ELSE 0 END), 0)::NUMERIC(14,2) AS finalized_amount,
    COALESCE(SUM(CASE WHEN status = 'paid' THEN net_payable ELSE 0 END), 0)::NUMERIC(14,2) AS paid_amount,
    COUNT(CASE WHEN status = 'draft' THEN 1 END)::INT AS draft_count,
    COUNT(CASE WHEN status = 'finalized' THEN 1 END)::INT AS finalized_count,
    COUNT(CASE WHEN status = 'paid' THEN 1 END)::INT AS paid_count
FROM invoices WHERE tenant_id = $1
`

type GetFinanceSummaryRow struct {
	PendingAmount   pgtype.Numeric `json:"pending_amount"`
	FinalizedAmount pgtype.Numeric `json:"finalized_amount"`
	PaidAmount      pgtype.Numeric `json:"paid_amount"`
	DraftCount      int32          `json:"draft_count"`
	FinalizedCount  int32          `json:"finalized_count"`
	PaidCount       int32          `json:"paid_count"`
}

func (q *Queries) GetFinanceSummary(ctx context.Context, tenantID uuid.UUID) (GetFinanceSummaryRow, error) {
	row := q.db.QueryRow(ctx, getFinanceSummary, tenantID)
	var i GetFinanceSummaryRow
	err := row.Scan(
		&i.PendingAmount,
		&i.FinalizedAmount,
		&i.PaidAmount,
		&i.DraftCount,
		&i.FinalizedCount,
		&i.PaidCount,
	)
	return i, err
}

const getInvoiceByID = `-- name: GetInvoiceByID :one
SELECT id, tenant_id, restaurant_id, invoice_number, period_start, period_end, gross_sales, item_discounts, vendor_promo_discounts, net_sales, vat_collected, commission_rate, commission_amount, penalty_amount, adjustment_amount, adjustment_note, net_payable, total_orders, delivered_orders, cancelled_orders, rejected_orders, status, generated_by, finalized_by, finalized_at, paid_by, paid_at, payment_reference, notes, created_at, updated_at, delivery_charge_total FROM invoices WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetInvoiceByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetInvoiceByID(ctx context.Context, arg GetInvoiceByIDParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByID, arg.ID, arg.TenantID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RestaurantID,
		&i.InvoiceNumber,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.GrossSales,
		&i.ItemDiscounts,
		&i.VendorPromoDiscounts,
		&i.NetSales,
		&i.VatCollected,
		&i.CommissionRate,
		&i.CommissionAmount,
		&i.PenaltyAmount,
		&i.AdjustmentAmount,
		&i.AdjustmentNote,
		&i.NetPayable,
		&i.TotalOrders,
		&i.DeliveredOrders,
		&i.CancelledOrders,
		&i.RejectedOrders,
		&i.Status,
		&i.GeneratedBy,
		&i.FinalizedBy,
		&i.FinalizedAt,
		&i.PaidBy,
		&i.PaidAt,
		&i.PaymentReference,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeliveryChargeTotal,
	)
	return i, err
}

const getInvoiceByPeriod = `-- name: GetInvoiceByPeriod :one
SELECT id, tenant_id, restaurant_id, invoice_number, period_start, period_end, gross_sales, item_discounts, vendor_promo_discounts, net_sales, vat_collected, commission_rate, commission_amount, penalty_amount, adjustment_amount, adjustment_note, net_payable, total_orders, delivered_orders, cancelled_orders, rejected_orders, status, generated_by, finalized_by, finalized_at, paid_by, paid_at, payment_reference, notes, created_at, updated_at, delivery_charge_total FROM invoices
WHERE tenant_id = $1 AND restaurant_id = $2 AND period_start = $3 AND period_end = $4
LIMIT 1
`

type GetInvoiceByPeriodParams struct {
	TenantID     uuid.UUID   `json:"tenant_id"`
	RestaurantID uuid.UUID   `json:"restaurant_id"`
	PeriodStart  pgtype.Date `json:"period_start"`
	PeriodEnd    pgtype.Date `json:"period_end"`
}

func (q *Queries) GetInvoiceByPeriod(ctx context.Context, arg GetInvoiceByPeriodParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByPeriod,
		arg.TenantID,
		arg.RestaurantID,
		arg.PeriodStart,
		arg.PeriodEnd,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RestaurantID,
		&i.InvoiceNumber,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.GrossSales,
		&i.ItemDiscounts,
		&i.VendorPromoDiscounts,
		&i.NetSales,
		&i.VatCollected,
		&i.CommissionRate,
		&i.CommissionAmount,
		&i.PenaltyAmount,
		&i.AdjustmentAmount,
		&i.AdjustmentNote,
		&i.NetPayable,
		&i.TotalOrders,
		&i.DeliveredOrders,
		&i.CancelledOrders,
		&i.RejectedOrders,
		&i.Status,
		&i.GeneratedBy,
		&i.FinalizedBy,
		&i.FinalizedAt,
		&i.PaidBy,
		&i.PaidAt,
		&i.PaymentReference,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeliveryChargeTotal,
	)
	return i, err
}

const getOrderPickupsByRestaurantAndPeriod = `-- name: GetOrderPickupsByRestaurantAndPeriod :many
SELECT op.id, op.order_id, op.restaurant_id, op.tenant_id, op.pickup_number, op.status, op.items_subtotal, op.items_discount, op.items_vat, op.items_total, op.commission_rate, op.commission_amount, op.confirmed_at, op.preparing_at, op.ready_at, op.picked_at, op.rejected_at, op.rejection_reason, op.created_at, op.updated_at FROM order_pickups op
JOIN orders o ON op.order_id = o.id
WHERE o.tenant_id = $1
  AND op.restaurant_id = $2
  AND o.status = 'delivered'
  AND o.deleted_at IS NULL
  AND o.delivered_at >= $3::timestamptz
  AND o.delivered_at < $4::timestamptz
`

type GetOrderPickupsByRestaurantAndPeriodParams struct {
	TenantID     uuid.UUID `json:"tenant_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
	PeriodStart  time.Time `json:"period_start"`
	PeriodEnd    time.Time `json:"period_end"`
}

func (q *Queries) GetOrderPickupsByRestaurantAndPeriod(ctx context.Context, arg GetOrderPickupsByRestaurantAndPeriodParams) ([]OrderPickup, error) {
	rows, err := q.db.Query(ctx, getOrderPickupsByRestaurantAndPeriod,
		arg.TenantID,
		arg.RestaurantID,
		arg.PeriodStart,
		arg.PeriodEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderPickup{}
	for rows.Next() {
		var i OrderPickup
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.RestaurantID,
			&i.TenantID,
			&i.PickupNumber,
			&i.Status,
			&i.ItemsSubtotal,
			&i.ItemsDiscount,
			&i.ItemsVat,
			&i.ItemsTotal,
			&i.CommissionRate,
			&i.CommissionAmount,
			&i.ConfirmedAt,
			&i.PreparingAt,
			&i.ReadyAt,
			&i.PickedAt,
			&i.RejectedAt,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveRestaurantsByTenant = `-- name: ListActiveRestaurantsByTenant :many
SELECT id, tenant_id, name FROM restaurants
WHERE tenant_id = $1 AND deleted_at IS NULL AND is_active = true
`

type ListActiveRestaurantsByTenantRow struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
	Name     string    `json:"name"`
}

func (q *Queries) ListActiveRestaurantsByTenant(ctx context.Context, tenantID uuid.UUID) ([]ListActiveRestaurantsByTenantRow, error) {
	rows, err := q.db.Query(ctx, listActiveRestaurantsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveRestaurantsByTenantRow{}
	for rows.Next() {
		var i ListActiveRestaurantsByTenantRow
		if err := rows.Scan(&i.ID, &i.TenantID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByRestaurant = `-- name: ListInvoicesByRestaurant :many
SELECT id, tenant_id, restaurant_id, invoice_number, period_start, period_end, gross_sales, item_discounts, vendor_promo_discounts, net_sales, vat_collected, commission_rate, commission_amount, penalty_amount, adjustment_amount, adjustment_note, net_payable, total_orders, delivered_orders, cancelled_orders, rejected_orders, status, generated_by, finalized_by, finalized_at, paid_by, paid_at, payment_reference, notes, created_at, updated_at, delivery_charge_total FROM invoices
WHERE restaurant_id = $1 AND tenant_id = $2
ORDER BY period_end DESC
LIMIT $3 OFFSET $4
`

type ListInvoicesByRestaurantParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListInvoicesByRestaurant(ctx context.Context, arg ListInvoicesByRestaurantParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByRestaurant,
		arg.RestaurantID,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RestaurantID,
			&i.InvoiceNumber,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.GrossSales,
			&i.ItemDiscounts,
			&i.VendorPromoDiscounts,
			&i.NetSales,
			&i.VatCollected,
			&i.CommissionRate,
			&i.CommissionAmount,
			&i.PenaltyAmount,
			&i.AdjustmentAmount,
			&i.AdjustmentNote,
			&i.NetPayable,
			&i.TotalOrders,
			&i.DeliveredOrders,
			&i.CancelledOrders,
			&i.RejectedOrders,
			&i.Status,
			&i.GeneratedBy,
			&i.FinalizedBy,
			&i.FinalizedAt,
			&i.PaidBy,
			&i.PaidAt,
			&i.PaymentReference,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeliveryChargeTotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesByTenant = `-- name: ListInvoicesByTenant :many
SELECT id, tenant_id, restaurant_id, invoice_number, period_start, period_end, gross_sales, item_discounts, vendor_promo_discounts, net_sales, vat_collected, commission_rate, commission_amount, penalty_amount, adjustment_amount, adjustment_note, net_payable, total_orders, delivered_orders, cancelled_orders, rejected_orders, status, generated_by, finalized_by, finalized_at, paid_by, paid_at, payment_reference, notes, created_at, updated_at, delivery_charge_total FROM invoices
WHERE tenant_id = $1
ORDER BY period_end DESC
LIMIT $2 OFFSET $3
`

type ListInvoicesByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListInvoicesByTenant(ctx context.Context, arg ListInvoicesByTenantParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RestaurantID,
			&i.InvoiceNumber,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.GrossSales,
			&i.ItemDiscounts,
			&i.VendorPromoDiscounts,
			&i.NetSales,
			&i.VatCollected,
			&i.CommissionRate,
			&i.CommissionAmount,
			&i.PenaltyAmount,
			&i.AdjustmentAmount,
			&i.AdjustmentNote,
			&i.NetPayable,
			&i.TotalOrders,
			&i.DeliveredOrders,
			&i.CancelledOrders,
			&i.RejectedOrders,
			&i.Status,
			&i.GeneratedBy,
			&i.FinalizedBy,
			&i.FinalizedAt,
			&i.PaidBy,
			&i.PaidAt,
			&i.PaymentReference,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeliveryChargeTotal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItemsByOrderIDs = `-- name: ListOrderItemsByOrderIDs :many
SELECT id, order_id, restaurant_id, product_id, tenant_id, product_name, product_snapshot, quantity, unit_price, modifier_price, item_subtotal, item_discount, item_vat, promo_discount, item_total, selected_modifiers, special_instructions, created_at FROM order_items
WHERE order_id = ANY($2::uuid[])
  AND restaurant_id = $1
`

type ListOrderItemsByOrderIDsParams struct {
	RestaurantID uuid.UUID   `json:"restaurant_id"`
	OrderIds     []uuid.UUID `json:"order_ids"`
}

func (q *Queries) ListOrderItemsByOrderIDs(ctx context.Context, arg ListOrderItemsByOrderIDsParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItemsByOrderIDs, arg.RestaurantID, arg.OrderIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.RestaurantID,
			&i.ProductID,
			&i.TenantID,
			&i.ProductName,
			&i.ProductSnapshot,
			&i.Quantity,
			&i.UnitPrice,
			&i.ModifierPrice,
			&i.ItemSubtotal,
			&i.ItemDiscount,
			&i.ItemVat,
			&i.PromoDiscount,
			&i.ItemTotal,
			&i.SelectedModifiers,
			&i.SpecialInstructions,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItemsByRestaurantAndPeriod = `-- name: ListOrderItemsByRestaurantAndPeriod :many
SELECT oi.id, oi.order_id, oi.restaurant_id, oi.product_id, oi.tenant_id, oi.product_name, oi.product_snapshot, oi.quantity, oi.unit_price, oi.modifier_price, oi.item_subtotal, oi.item_discount, oi.item_vat, oi.promo_discount, oi.item_total, oi.selected_modifiers, oi.special_instructions, oi.created_at FROM order_items oi
JOIN orders o ON oi.order_id = o.id
WHERE o.tenant_id = $1
  AND oi.restaurant_id = $2
  AND o.status = 'delivered'
  AND o.deleted_at IS NULL
  AND o.delivered_at >= $3::timestamptz
  AND o.delivered_at < $4::timestamptz
`

type ListOrderItemsByRestaurantAndPeriodParams struct {
	TenantID     uuid.UUID `json:"tenant_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
	PeriodStart  time.Time `json:"period_start"`
	PeriodEnd    time.Time `json:"period_end"`
}

func (q *Queries) ListOrderItemsByRestaurantAndPeriod(ctx context.Context, arg ListOrderItemsByRestaurantAndPeriodParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItemsByRestaurantAndPeriod,
		arg.TenantID,
		arg.RestaurantID,
		arg.PeriodStart,
		arg.PeriodEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.RestaurantID,
			&i.ProductID,
			&i.TenantID,
			&i.ProductName,
			&i.ProductSnapshot,
			&i.Quantity,
			&i.UnitPrice,
			&i.ModifierPrice,
			&i.ItemSubtotal,
			&i.ItemDiscount,
			&i.ItemVat,
			&i.PromoDiscount,
			&i.ItemTotal,
			&i.SelectedModifiers,
			&i.SpecialInstructions,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInvoicePaid = `-- name: MarkInvoicePaid :one
UPDATE invoices SET status = 'paid', paid_by = $3, paid_at = NOW(), payment_reference = $4, notes = COALESCE($5, notes)
WHERE id = $1 AND tenant_id = $2 AND status = 'finalized'
RETURNING id, tenant_id, restaurant_id, invoice_number, period_start, period_end, gross_sales, item_discounts, vendor_promo_discounts, net_sales, vat_collected, commission_rate, commission_amount, penalty_amount, adjustment_amount, adjustment_note, net_payable, total_orders, delivered_orders, cancelled_orders, rejected_orders, status, generated_by, finalized_by, finalized_at, paid_by, paid_at, payment_reference, notes, created_at, updated_at, delivery_charge_total
`

type MarkInvoicePaidParams struct {
	ID               uuid.UUID      `json:"id"`
	TenantID         uuid.UUID      `json:"tenant_id"`
	PaidBy           pgtype.UUID    `json:"paid_by"`
	PaymentReference sql.NullString `json:"payment_reference"`
	Notes            sql.NullString `json:"notes"`
}

func (q *Queries) MarkInvoicePaid(ctx context.Context, arg MarkInvoicePaidParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, markInvoicePaid,
		arg.ID,
		arg.TenantID,
		arg.PaidBy,
		arg.PaymentReference,
		arg.Notes,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RestaurantID,
		&i.InvoiceNumber,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.GrossSales,
		&i.ItemDiscounts,
		&i.VendorPromoDiscounts,
		&i.NetSales,
		&i.VatCollected,
		&i.CommissionRate,
		&i.CommissionAmount,
		&i.PenaltyAmount,
		&i.AdjustmentAmount,
		&i.AdjustmentNote,
		&i.NetPayable,
		&i.TotalOrders,
		&i.DeliveredOrders,
		&i.CancelledOrders,
		&i.RejectedOrders,
		&i.Status,
		&i.GeneratedBy,
		&i.FinalizedBy,
		&i.FinalizedAt,
		&i.PaidBy,
		&i.PaidAt,
		&i.PaymentReference,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeliveryChargeTotal,
	)
	return i, err
}
