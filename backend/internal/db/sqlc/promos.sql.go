// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: promos.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPromoCategoryRestriction = `-- name: AddPromoCategoryRestriction :exec
INSERT INTO promo_category_restrictions (promo_id, category_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddPromoCategoryRestrictionParams struct {
	PromoID    uuid.UUID `json:"promo_id"`
	CategoryID uuid.UUID `json:"category_id"`
}

func (q *Queries) AddPromoCategoryRestriction(ctx context.Context, arg AddPromoCategoryRestrictionParams) error {
	_, err := q.db.Exec(ctx, addPromoCategoryRestriction, arg.PromoID, arg.CategoryID)
	return err
}

const addPromoRestaurantRestriction = `-- name: AddPromoRestaurantRestriction :exec
INSERT INTO promo_restaurant_restrictions (promo_id, restaurant_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddPromoRestaurantRestrictionParams struct {
	PromoID      uuid.UUID `json:"promo_id"`
	RestaurantID uuid.UUID `json:"restaurant_id"`
}

func (q *Queries) AddPromoRestaurantRestriction(ctx context.Context, arg AddPromoRestaurantRestrictionParams) error {
	_, err := q.db.Exec(ctx, addPromoRestaurantRestriction, arg.PromoID, arg.RestaurantID)
	return err
}

const addPromoUserEligibility = `-- name: AddPromoUserEligibility :exec
INSERT INTO promo_user_eligibility (promo_id, user_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddPromoUserEligibilityParams struct {
	PromoID uuid.UUID `json:"promo_id"`
	UserID  uuid.UUID `json:"user_id"`
}

func (q *Queries) AddPromoUserEligibility(ctx context.Context, arg AddPromoUserEligibilityParams) error {
	_, err := q.db.Exec(ctx, addPromoUserEligibility, arg.PromoID, arg.UserID)
	return err
}

const checkPromoUserEligibility = `-- name: CheckPromoUserEligibility :one
SELECT COUNT(*) FROM promo_user_eligibility
WHERE promo_id = $1 AND user_id = $2
`

type CheckPromoUserEligibilityParams struct {
	PromoID uuid.UUID `json:"promo_id"`
	UserID  uuid.UUID `json:"user_id"`
}

func (q *Queries) CheckPromoUserEligibility(ctx context.Context, arg CheckPromoUserEligibilityParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkPromoUserEligibility, arg.PromoID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPromos = `-- name: CountPromos :one
SELECT COUNT(*) FROM promos
WHERE tenant_id = $1
`

func (q *Queries) CountPromos(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPromos, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPromo = `-- name: CreatePromo :one

INSERT INTO promos (
    tenant_id, code, title, description, promo_type,
    discount_amount, max_discount_cap, cashback_amount, funded_by,
    applies_to, min_order_amount, max_total_uses, max_uses_per_user,
    include_stores, is_active, starts_at, ends_at, created_by
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
RETURNING id, tenant_id, code, title, description, promo_type, discount_amount, max_discount_cap, cashback_amount, funded_by, applies_to, min_order_amount, max_total_uses, max_uses_per_user, include_stores, is_active, starts_at, ends_at, total_uses, total_discount_given, created_by, created_at, updated_at
`

type CreatePromoParams struct {
	TenantID       uuid.UUID          `json:"tenant_id"`
	Code           string             `json:"code"`
	Title          string             `json:"title"`
	Description    sql.NullString     `json:"description"`
	PromoType      PromoType          `json:"promo_type"`
	DiscountAmount pgtype.Numeric     `json:"discount_amount"`
	MaxDiscountCap pgtype.Numeric     `json:"max_discount_cap"`
	CashbackAmount pgtype.Numeric     `json:"cashback_amount"`
	FundedBy       PromoFunder        `json:"funded_by"`
	AppliesTo      PromoApplyOn       `json:"applies_to"`
	MinOrderAmount pgtype.Numeric     `json:"min_order_amount"`
	MaxTotalUses   *int32             `json:"max_total_uses"`
	MaxUsesPerUser int32              `json:"max_uses_per_user"`
	IncludeStores  bool               `json:"include_stores"`
	IsActive       bool               `json:"is_active"`
	StartsAt       time.Time          `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
	CreatedBy      pgtype.UUID        `json:"created_by"`
}

// ============================================================
// Promos SQLC Queries
// ============================================================
func (q *Queries) CreatePromo(ctx context.Context, arg CreatePromoParams) (Promo, error) {
	row := q.db.QueryRow(ctx, createPromo,
		arg.TenantID,
		arg.Code,
		arg.Title,
		arg.Description,
		arg.PromoType,
		arg.DiscountAmount,
		arg.MaxDiscountCap,
		arg.CashbackAmount,
		arg.FundedBy,
		arg.AppliesTo,
		arg.MinOrderAmount,
		arg.MaxTotalUses,
		arg.MaxUsesPerUser,
		arg.IncludeStores,
		arg.IsActive,
		arg.StartsAt,
		arg.EndsAt,
		arg.CreatedBy,
	)
	var i Promo
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.PromoType,
		&i.DiscountAmount,
		&i.MaxDiscountCap,
		&i.CashbackAmount,
		&i.FundedBy,
		&i.AppliesTo,
		&i.MinOrderAmount,
		&i.MaxTotalUses,
		&i.MaxUsesPerUser,
		&i.IncludeStores,
		&i.IsActive,
		&i.StartsAt,
		&i.EndsAt,
		&i.TotalUses,
		&i.TotalDiscountGiven,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPromoUsage = `-- name: CreatePromoUsage :one
INSERT INTO promo_usages (
    promo_id, user_id, order_id, tenant_id,
    discount_amount, cashback_amount
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, promo_id, user_id, order_id, tenant_id, discount_amount, cashback_amount, created_at
`

type CreatePromoUsageParams struct {
	PromoID        uuid.UUID      `json:"promo_id"`
	UserID         uuid.UUID      `json:"user_id"`
	OrderID        uuid.UUID      `json:"order_id"`
	TenantID       uuid.UUID      `json:"tenant_id"`
	DiscountAmount pgtype.Numeric `json:"discount_amount"`
	CashbackAmount pgtype.Numeric `json:"cashback_amount"`
}

func (q *Queries) CreatePromoUsage(ctx context.Context, arg CreatePromoUsageParams) (PromoUsage, error) {
	row := q.db.QueryRow(ctx, createPromoUsage,
		arg.PromoID,
		arg.UserID,
		arg.OrderID,
		arg.TenantID,
		arg.DiscountAmount,
		arg.CashbackAmount,
	)
	var i PromoUsage
	err := row.Scan(
		&i.ID,
		&i.PromoID,
		&i.UserID,
		&i.OrderID,
		&i.TenantID,
		&i.DiscountAmount,
		&i.CashbackAmount,
		&i.CreatedAt,
	)
	return i, err
}

const deactivatePromo = `-- name: DeactivatePromo :one
UPDATE promos
SET is_active = false
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, code, title, description, promo_type, discount_amount, max_discount_cap, cashback_amount, funded_by, applies_to, min_order_amount, max_total_uses, max_uses_per_user, include_stores, is_active, starts_at, ends_at, total_uses, total_discount_given, created_by, created_at, updated_at
`

type DeactivatePromoParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeactivatePromo(ctx context.Context, arg DeactivatePromoParams) (Promo, error) {
	row := q.db.QueryRow(ctx, deactivatePromo, arg.ID, arg.TenantID)
	var i Promo
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.PromoType,
		&i.DiscountAmount,
		&i.MaxDiscountCap,
		&i.CashbackAmount,
		&i.FundedBy,
		&i.AppliesTo,
		&i.MinOrderAmount,
		&i.MaxTotalUses,
		&i.MaxUsesPerUser,
		&i.IncludeStores,
		&i.IsActive,
		&i.StartsAt,
		&i.EndsAt,
		&i.TotalUses,
		&i.TotalDiscountGiven,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActivePromoByCode = `-- name: GetActivePromoByCode :one
SELECT id, tenant_id, code, title, description, promo_type, discount_amount, max_discount_cap, cashback_amount, funded_by, applies_to, min_order_amount, max_total_uses, max_uses_per_user, include_stores, is_active, starts_at, ends_at, total_uses, total_discount_given, created_by, created_at, updated_at FROM promos
WHERE code = $1 AND tenant_id = $2
  AND is_active = true
  AND starts_at <= NOW()
  AND (ends_at IS NULL OR ends_at > NOW())
`

type GetActivePromoByCodeParams struct {
	Code     string    `json:"code"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetActivePromoByCode(ctx context.Context, arg GetActivePromoByCodeParams) (Promo, error) {
	row := q.db.QueryRow(ctx, getActivePromoByCode, arg.Code, arg.TenantID)
	var i Promo
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.PromoType,
		&i.DiscountAmount,
		&i.MaxDiscountCap,
		&i.CashbackAmount,
		&i.FundedBy,
		&i.AppliesTo,
		&i.MinOrderAmount,
		&i.MaxTotalUses,
		&i.MaxUsesPerUser,
		&i.IncludeStores,
		&i.IsActive,
		&i.StartsAt,
		&i.EndsAt,
		&i.TotalUses,
		&i.TotalDiscountGiven,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPromoByCode = `-- name: GetPromoByCode :one
SELECT id, tenant_id, code, title, description, promo_type, discount_amount, max_discount_cap, cashback_amount, funded_by, applies_to, min_order_amount, max_total_uses, max_uses_per_user, include_stores, is_active, starts_at, ends_at, total_uses, total_discount_given, created_by, created_at, updated_at FROM promos
WHERE code = $1 AND tenant_id = $2
`

type GetPromoByCodeParams struct {
	Code     string    `json:"code"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetPromoByCode(ctx context.Context, arg GetPromoByCodeParams) (Promo, error) {
	row := q.db.QueryRow(ctx, getPromoByCode, arg.Code, arg.TenantID)
	var i Promo
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.PromoType,
		&i.DiscountAmount,
		&i.MaxDiscountCap,
		&i.CashbackAmount,
		&i.FundedBy,
		&i.AppliesTo,
		&i.MinOrderAmount,
		&i.MaxTotalUses,
		&i.MaxUsesPerUser,
		&i.IncludeStores,
		&i.IsActive,
		&i.StartsAt,
		&i.EndsAt,
		&i.TotalUses,
		&i.TotalDiscountGiven,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPromoByID = `-- name: GetPromoByID :one
SELECT id, tenant_id, code, title, description, promo_type, discount_amount, max_discount_cap, cashback_amount, funded_by, applies_to, min_order_amount, max_total_uses, max_uses_per_user, include_stores, is_active, starts_at, ends_at, total_uses, total_discount_given, created_by, created_at, updated_at FROM promos
WHERE id = $1 AND tenant_id = $2
`

type GetPromoByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetPromoByID(ctx context.Context, arg GetPromoByIDParams) (Promo, error) {
	row := q.db.QueryRow(ctx, getPromoByID, arg.ID, arg.TenantID)
	var i Promo
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.PromoType,
		&i.DiscountAmount,
		&i.MaxDiscountCap,
		&i.CashbackAmount,
		&i.FundedBy,
		&i.AppliesTo,
		&i.MinOrderAmount,
		&i.MaxTotalUses,
		&i.MaxUsesPerUser,
		&i.IncludeStores,
		&i.IsActive,
		&i.StartsAt,
		&i.EndsAt,
		&i.TotalUses,
		&i.TotalDiscountGiven,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUsageCountByUserAndPromo = `-- name: GetUsageCountByUserAndPromo :one
SELECT COUNT(*) FROM promo_usages
WHERE user_id = $1 AND promo_id = $2
`

type GetUsageCountByUserAndPromoParams struct {
	UserID  uuid.UUID `json:"user_id"`
	PromoID uuid.UUID `json:"promo_id"`
}

func (q *Queries) GetUsageCountByUserAndPromo(ctx context.Context, arg GetUsageCountByUserAndPromoParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUsageCountByUserAndPromo, arg.UserID, arg.PromoID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const incrementPromoUsage = `-- name: IncrementPromoUsage :exec
UPDATE promos
SET total_uses = total_uses + 1,
    total_discount_given = total_discount_given + $1
WHERE id = $2 AND tenant_id = $3
`

type IncrementPromoUsageParams struct {
	DiscountAmount pgtype.Numeric `json:"discount_amount"`
	ID             uuid.UUID      `json:"id"`
	TenantID       uuid.UUID      `json:"tenant_id"`
}

func (q *Queries) IncrementPromoUsage(ctx context.Context, arg IncrementPromoUsageParams) error {
	_, err := q.db.Exec(ctx, incrementPromoUsage, arg.DiscountAmount, arg.ID, arg.TenantID)
	return err
}

const listPromoCategoryRestrictions = `-- name: ListPromoCategoryRestrictions :many
SELECT category_id FROM promo_category_restrictions
WHERE promo_id = $1
`

func (q *Queries) ListPromoCategoryRestrictions(ctx context.Context, promoID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, listPromoCategoryRestrictions, promoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var category_id uuid.UUID
		if err := rows.Scan(&category_id); err != nil {
			return nil, err
		}
		items = append(items, category_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPromoRestaurantRestrictions = `-- name: ListPromoRestaurantRestrictions :many
SELECT restaurant_id FROM promo_restaurant_restrictions
WHERE promo_id = $1
`

func (q *Queries) ListPromoRestaurantRestrictions(ctx context.Context, promoID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, listPromoRestaurantRestrictions, promoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var restaurant_id uuid.UUID
		if err := rows.Scan(&restaurant_id); err != nil {
			return nil, err
		}
		items = append(items, restaurant_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPromoUserEligibility = `-- name: ListPromoUserEligibility :many
SELECT user_id FROM promo_user_eligibility
WHERE promo_id = $1
`

func (q *Queries) ListPromoUserEligibility(ctx context.Context, promoID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, listPromoUserEligibility, promoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var user_id uuid.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPromos = `-- name: ListPromos :many
SELECT id, tenant_id, code, title, description, promo_type, discount_amount, max_discount_cap, cashback_amount, funded_by, applies_to, min_order_amount, max_total_uses, max_uses_per_user, include_stores, is_active, starts_at, ends_at, total_uses, total_discount_given, created_by, created_at, updated_at FROM promos
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPromosParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListPromos(ctx context.Context, arg ListPromosParams) ([]Promo, error) {
	rows, err := q.db.Query(ctx, listPromos, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Promo{}
	for rows.Next() {
		var i Promo
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Code,
			&i.Title,
			&i.Description,
			&i.PromoType,
			&i.DiscountAmount,
			&i.MaxDiscountCap,
			&i.CashbackAmount,
			&i.FundedBy,
			&i.AppliesTo,
			&i.MinOrderAmount,
			&i.MaxTotalUses,
			&i.MaxUsesPerUser,
			&i.IncludeStores,
			&i.IsActive,
			&i.StartsAt,
			&i.EndsAt,
			&i.TotalUses,
			&i.TotalDiscountGiven,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePromoCategoryRestrictions = `-- name: RemovePromoCategoryRestrictions :exec
DELETE FROM promo_category_restrictions
WHERE promo_id = $1
`

func (q *Queries) RemovePromoCategoryRestrictions(ctx context.Context, promoID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removePromoCategoryRestrictions, promoID)
	return err
}

const removePromoRestaurantRestrictions = `-- name: RemovePromoRestaurantRestrictions :exec
DELETE FROM promo_restaurant_restrictions
WHERE promo_id = $1
`

func (q *Queries) RemovePromoRestaurantRestrictions(ctx context.Context, promoID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removePromoRestaurantRestrictions, promoID)
	return err
}

const removePromoUserEligibility = `-- name: RemovePromoUserEligibility :exec
DELETE FROM promo_user_eligibility
WHERE promo_id = $1
`

func (q *Queries) RemovePromoUserEligibility(ctx context.Context, promoID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removePromoUserEligibility, promoID)
	return err
}

const updatePromo = `-- name: UpdatePromo :one
UPDATE promos SET
    title = COALESCE($1, title),
    description = COALESCE($2, description),
    discount_amount = COALESCE($3, discount_amount),
    max_discount_cap = COALESCE($4, max_discount_cap),
    cashback_amount = COALESCE($5, cashback_amount),
    min_order_amount = COALESCE($6, min_order_amount),
    max_total_uses = COALESCE($7, max_total_uses),
    max_uses_per_user = COALESCE($8, max_uses_per_user),
    starts_at = COALESCE($9, starts_at),
    ends_at = COALESCE($10, ends_at)
WHERE id = $11 AND tenant_id = $12
RETURNING id, tenant_id, code, title, description, promo_type, discount_amount, max_discount_cap, cashback_amount, funded_by, applies_to, min_order_amount, max_total_uses, max_uses_per_user, include_stores, is_active, starts_at, ends_at, total_uses, total_discount_given, created_by, created_at, updated_at
`

type UpdatePromoParams struct {
	Title          sql.NullString     `json:"title"`
	Description    sql.NullString     `json:"description"`
	DiscountAmount pgtype.Numeric     `json:"discount_amount"`
	MaxDiscountCap pgtype.Numeric     `json:"max_discount_cap"`
	CashbackAmount pgtype.Numeric     `json:"cashback_amount"`
	MinOrderAmount pgtype.Numeric     `json:"min_order_amount"`
	MaxTotalUses   *int32             `json:"max_total_uses"`
	MaxUsesPerUser *int32             `json:"max_uses_per_user"`
	StartsAt       pgtype.Timestamptz `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
	ID             uuid.UUID          `json:"id"`
	TenantID       uuid.UUID          `json:"tenant_id"`
}

func (q *Queries) UpdatePromo(ctx context.Context, arg UpdatePromoParams) (Promo, error) {
	row := q.db.QueryRow(ctx, updatePromo,
		arg.Title,
		arg.Description,
		arg.DiscountAmount,
		arg.MaxDiscountCap,
		arg.CashbackAmount,
		arg.MinOrderAmount,
		arg.MaxTotalUses,
		arg.MaxUsesPerUser,
		arg.StartsAt,
		arg.EndsAt,
		arg.ID,
		arg.TenantID,
	)
	var i Promo
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.PromoType,
		&i.DiscountAmount,
		&i.MaxDiscountCap,
		&i.CashbackAmount,
		&i.FundedBy,
		&i.AppliesTo,
		&i.MinOrderAmount,
		&i.MaxTotalUses,
		&i.MaxUsesPerUser,
		&i.IncludeStores,
		&i.IsActive,
		&i.StartsAt,
		&i.EndsAt,
		&i.TotalUses,
		&i.TotalDiscountGiven,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
