// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: content.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countBannersByTenant = `-- name: CountBannersByTenant :one
SELECT COUNT(*) FROM banners WHERE tenant_id = $1
`

func (q *Queries) CountBannersByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countBannersByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStoriesByTenant = `-- name: CountStoriesByTenant :one
SELECT COUNT(*) FROM stories WHERE tenant_id = $1
`

func (q *Queries) CountStoriesByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countStoriesByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBanner = `-- name: CreateBanner :one
INSERT INTO banners (
    tenant_id, title, subtitle, image_url, mobile_image_url,
    link_type, link_value, platform, sort_order, is_active, hub_ids, starts_at, ends_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, tenant_id, title, subtitle, image_url, mobile_image_url, link_type, link_value, platform, sort_order, is_active, hub_ids, starts_at, ends_at, created_at, updated_at
`

type CreateBannerParams struct {
	TenantID       uuid.UUID          `json:"tenant_id"`
	Title          string             `json:"title"`
	Subtitle       sql.NullString     `json:"subtitle"`
	ImageUrl       string             `json:"image_url"`
	MobileImageUrl sql.NullString     `json:"mobile_image_url"`
	LinkType       NullLinkTargetType `json:"link_type"`
	LinkValue      sql.NullString     `json:"link_value"`
	Platform       string             `json:"platform"`
	SortOrder      int32              `json:"sort_order"`
	IsActive       bool               `json:"is_active"`
	HubIds         []uuid.UUID        `json:"hub_ids"`
	StartsAt       pgtype.Timestamptz `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
}

func (q *Queries) CreateBanner(ctx context.Context, arg CreateBannerParams) (Banner, error) {
	row := q.db.QueryRow(ctx, createBanner,
		arg.TenantID,
		arg.Title,
		arg.Subtitle,
		arg.ImageUrl,
		arg.MobileImageUrl,
		arg.LinkType,
		arg.LinkValue,
		arg.Platform,
		arg.SortOrder,
		arg.IsActive,
		arg.HubIds,
		arg.StartsAt,
		arg.EndsAt,
	)
	var i Banner
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Subtitle,
		&i.ImageUrl,
		&i.MobileImageUrl,
		&i.LinkType,
		&i.LinkValue,
		&i.Platform,
		&i.SortOrder,
		&i.IsActive,
		&i.HubIds,
		&i.StartsAt,
		&i.EndsAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStory = `-- name: CreateStory :one
INSERT INTO stories (
    tenant_id, restaurant_id, title, media_url, media_type,
    thumbnail_url, link_type, link_value, expires_at, sort_order, is_active
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, tenant_id, restaurant_id, title, media_url, media_type, thumbnail_url, link_type, link_value, expires_at, sort_order, view_count, is_active, created_at
`

type CreateStoryParams struct {
	TenantID     uuid.UUID          `json:"tenant_id"`
	RestaurantID pgtype.UUID        `json:"restaurant_id"`
	Title        sql.NullString     `json:"title"`
	MediaUrl     string             `json:"media_url"`
	MediaType    MediaType          `json:"media_type"`
	ThumbnailUrl sql.NullString     `json:"thumbnail_url"`
	LinkType     NullLinkTargetType `json:"link_type"`
	LinkValue    sql.NullString     `json:"link_value"`
	ExpiresAt    time.Time          `json:"expires_at"`
	SortOrder    int32              `json:"sort_order"`
	IsActive     bool               `json:"is_active"`
}

func (q *Queries) CreateStory(ctx context.Context, arg CreateStoryParams) (Story, error) {
	row := q.db.QueryRow(ctx, createStory,
		arg.TenantID,
		arg.RestaurantID,
		arg.Title,
		arg.MediaUrl,
		arg.MediaType,
		arg.ThumbnailUrl,
		arg.LinkType,
		arg.LinkValue,
		arg.ExpiresAt,
		arg.SortOrder,
		arg.IsActive,
	)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RestaurantID,
		&i.Title,
		&i.MediaUrl,
		&i.MediaType,
		&i.ThumbnailUrl,
		&i.LinkType,
		&i.LinkValue,
		&i.ExpiresAt,
		&i.SortOrder,
		&i.ViewCount,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBanner = `-- name: DeleteBanner :exec
DELETE FROM banners WHERE id = $1 AND tenant_id = $2
`

type DeleteBannerParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteBanner(ctx context.Context, arg DeleteBannerParams) error {
	_, err := q.db.Exec(ctx, deleteBanner, arg.ID, arg.TenantID)
	return err
}

const deleteStory = `-- name: DeleteStory :exec
DELETE FROM stories WHERE id = $1 AND tenant_id = $2
`

type DeleteStoryParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteStory(ctx context.Context, arg DeleteStoryParams) error {
	_, err := q.db.Exec(ctx, deleteStory, arg.ID, arg.TenantID)
	return err
}

const getBannerByID = `-- name: GetBannerByID :one
SELECT id, tenant_id, title, subtitle, image_url, mobile_image_url, link_type, link_value, platform, sort_order, is_active, hub_ids, starts_at, ends_at, created_at, updated_at FROM banners WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetBannerByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetBannerByID(ctx context.Context, arg GetBannerByIDParams) (Banner, error) {
	row := q.db.QueryRow(ctx, getBannerByID, arg.ID, arg.TenantID)
	var i Banner
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Subtitle,
		&i.ImageUrl,
		&i.MobileImageUrl,
		&i.LinkType,
		&i.LinkValue,
		&i.Platform,
		&i.SortOrder,
		&i.IsActive,
		&i.HubIds,
		&i.StartsAt,
		&i.EndsAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSectionByID = `-- name: GetSectionByID :one
SELECT id, tenant_id, title, subtitle, content_type, item_ids, filter_rule, sort_order, is_active, hub_ids, created_at, updated_at FROM homepage_sections WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetSectionByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetSectionByID(ctx context.Context, arg GetSectionByIDParams) (HomepageSection, error) {
	row := q.db.QueryRow(ctx, getSectionByID, arg.ID, arg.TenantID)
	var i HomepageSection
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Subtitle,
		&i.ContentType,
		&i.ItemIds,
		&i.FilterRule,
		&i.SortOrder,
		&i.IsActive,
		&i.HubIds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStoryByID = `-- name: GetStoryByID :one
SELECT id, tenant_id, restaurant_id, title, media_url, media_type, thumbnail_url, link_type, link_value, expires_at, sort_order, view_count, is_active, created_at FROM stories WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetStoryByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetStoryByID(ctx context.Context, arg GetStoryByIDParams) (Story, error) {
	row := q.db.QueryRow(ctx, getStoryByID, arg.ID, arg.TenantID)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.RestaurantID,
		&i.Title,
		&i.MediaUrl,
		&i.MediaType,
		&i.ThumbnailUrl,
		&i.LinkType,
		&i.LinkValue,
		&i.ExpiresAt,
		&i.SortOrder,
		&i.ViewCount,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const listActiveBanners = `-- name: ListActiveBanners :many
SELECT id, tenant_id, title, subtitle, image_url, mobile_image_url, link_type, link_value, platform, sort_order, is_active, hub_ids, starts_at, ends_at, created_at, updated_at FROM banners
WHERE tenant_id = $1 AND is_active = true
  AND (starts_at IS NULL OR starts_at <= NOW())
  AND (ends_at IS NULL OR ends_at >= NOW())
ORDER BY sort_order ASC
`

func (q *Queries) ListActiveBanners(ctx context.Context, tenantID uuid.UUID) ([]Banner, error) {
	rows, err := q.db.Query(ctx, listActiveBanners, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Banner{}
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Subtitle,
			&i.ImageUrl,
			&i.MobileImageUrl,
			&i.LinkType,
			&i.LinkValue,
			&i.Platform,
			&i.SortOrder,
			&i.IsActive,
			&i.HubIds,
			&i.StartsAt,
			&i.EndsAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveSections = `-- name: ListActiveSections :many
SELECT id, tenant_id, title, subtitle, content_type, item_ids, filter_rule, sort_order, is_active, hub_ids, created_at, updated_at FROM homepage_sections
WHERE tenant_id = $1 AND is_active = true
ORDER BY sort_order ASC
`

func (q *Queries) ListActiveSections(ctx context.Context, tenantID uuid.UUID) ([]HomepageSection, error) {
	rows, err := q.db.Query(ctx, listActiveSections, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HomepageSection{}
	for rows.Next() {
		var i HomepageSection
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Subtitle,
			&i.ContentType,
			&i.ItemIds,
			&i.FilterRule,
			&i.SortOrder,
			&i.IsActive,
			&i.HubIds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveStories = `-- name: ListActiveStories :many
SELECT id, tenant_id, restaurant_id, title, media_url, media_type, thumbnail_url, link_type, link_value, expires_at, sort_order, view_count, is_active, created_at FROM stories
WHERE tenant_id = $1 AND is_active = true AND expires_at > NOW()
ORDER BY sort_order ASC
`

func (q *Queries) ListActiveStories(ctx context.Context, tenantID uuid.UUID) ([]Story, error) {
	rows, err := q.db.Query(ctx, listActiveStories, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Story{}
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RestaurantID,
			&i.Title,
			&i.MediaUrl,
			&i.MediaType,
			&i.ThumbnailUrl,
			&i.LinkType,
			&i.LinkValue,
			&i.ExpiresAt,
			&i.SortOrder,
			&i.ViewCount,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBannersByTenant = `-- name: ListBannersByTenant :many
SELECT id, tenant_id, title, subtitle, image_url, mobile_image_url, link_type, link_value, platform, sort_order, is_active, hub_ids, starts_at, ends_at, created_at, updated_at FROM banners WHERE tenant_id = $1
ORDER BY sort_order ASC, created_at DESC
LIMIT $2 OFFSET $3
`

type ListBannersByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListBannersByTenant(ctx context.Context, arg ListBannersByTenantParams) ([]Banner, error) {
	rows, err := q.db.Query(ctx, listBannersByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Banner{}
	for rows.Next() {
		var i Banner
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Subtitle,
			&i.ImageUrl,
			&i.MobileImageUrl,
			&i.LinkType,
			&i.LinkValue,
			&i.Platform,
			&i.SortOrder,
			&i.IsActive,
			&i.HubIds,
			&i.StartsAt,
			&i.EndsAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSectionsByTenant = `-- name: ListSectionsByTenant :many
SELECT id, tenant_id, title, subtitle, content_type, item_ids, filter_rule, sort_order, is_active, hub_ids, created_at, updated_at FROM homepage_sections WHERE tenant_id = $1
ORDER BY sort_order ASC
`

func (q *Queries) ListSectionsByTenant(ctx context.Context, tenantID uuid.UUID) ([]HomepageSection, error) {
	rows, err := q.db.Query(ctx, listSectionsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HomepageSection{}
	for rows.Next() {
		var i HomepageSection
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Title,
			&i.Subtitle,
			&i.ContentType,
			&i.ItemIds,
			&i.FilterRule,
			&i.SortOrder,
			&i.IsActive,
			&i.HubIds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoriesByTenant = `-- name: ListStoriesByTenant :many
SELECT id, tenant_id, restaurant_id, title, media_url, media_type, thumbnail_url, link_type, link_value, expires_at, sort_order, view_count, is_active, created_at FROM stories WHERE tenant_id = $1
ORDER BY sort_order ASC, created_at DESC
LIMIT $2 OFFSET $3
`

type ListStoriesByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListStoriesByTenant(ctx context.Context, arg ListStoriesByTenantParams) ([]Story, error) {
	rows, err := q.db.Query(ctx, listStoriesByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Story{}
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.RestaurantID,
			&i.Title,
			&i.MediaUrl,
			&i.MediaType,
			&i.ThumbnailUrl,
			&i.LinkType,
			&i.LinkValue,
			&i.ExpiresAt,
			&i.SortOrder,
			&i.ViewCount,
			&i.IsActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBanner = `-- name: UpdateBanner :one
UPDATE banners SET
    title = $3, subtitle = $4, image_url = $5, mobile_image_url = $6,
    link_type = $7, link_value = $8, platform = $9, sort_order = $10,
    is_active = $11, hub_ids = $12, starts_at = $13, ends_at = $14
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, title, subtitle, image_url, mobile_image_url, link_type, link_value, platform, sort_order, is_active, hub_ids, starts_at, ends_at, created_at, updated_at
`

type UpdateBannerParams struct {
	ID             uuid.UUID          `json:"id"`
	TenantID       uuid.UUID          `json:"tenant_id"`
	Title          string             `json:"title"`
	Subtitle       sql.NullString     `json:"subtitle"`
	ImageUrl       string             `json:"image_url"`
	MobileImageUrl sql.NullString     `json:"mobile_image_url"`
	LinkType       NullLinkTargetType `json:"link_type"`
	LinkValue      sql.NullString     `json:"link_value"`
	Platform       string             `json:"platform"`
	SortOrder      int32              `json:"sort_order"`
	IsActive       bool               `json:"is_active"`
	HubIds         []uuid.UUID        `json:"hub_ids"`
	StartsAt       pgtype.Timestamptz `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
}

func (q *Queries) UpdateBanner(ctx context.Context, arg UpdateBannerParams) (Banner, error) {
	row := q.db.QueryRow(ctx, updateBanner,
		arg.ID,
		arg.TenantID,
		arg.Title,
		arg.Subtitle,
		arg.ImageUrl,
		arg.MobileImageUrl,
		arg.LinkType,
		arg.LinkValue,
		arg.Platform,
		arg.SortOrder,
		arg.IsActive,
		arg.HubIds,
		arg.StartsAt,
		arg.EndsAt,
	)
	var i Banner
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Subtitle,
		&i.ImageUrl,
		&i.MobileImageUrl,
		&i.LinkType,
		&i.LinkValue,
		&i.Platform,
		&i.SortOrder,
		&i.IsActive,
		&i.HubIds,
		&i.StartsAt,
		&i.EndsAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSection = `-- name: UpdateSection :one
UPDATE homepage_sections SET
    title = $3, subtitle = $4, content_type = $5, item_ids = $6,
    filter_rule = $7, sort_order = $8, is_active = $9, hub_ids = $10
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, title, subtitle, content_type, item_ids, filter_rule, sort_order, is_active, hub_ids, created_at, updated_at
`

type UpdateSectionParams struct {
	ID          uuid.UUID      `json:"id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
	Title       string         `json:"title"`
	Subtitle    sql.NullString `json:"subtitle"`
	ContentType string         `json:"content_type"`
	ItemIds     []uuid.UUID    `json:"item_ids"`
	FilterRule  []byte         `json:"filter_rule"`
	SortOrder   int32          `json:"sort_order"`
	IsActive    bool           `json:"is_active"`
	HubIds      []uuid.UUID    `json:"hub_ids"`
}

func (q *Queries) UpdateSection(ctx context.Context, arg UpdateSectionParams) (HomepageSection, error) {
	row := q.db.QueryRow(ctx, updateSection,
		arg.ID,
		arg.TenantID,
		arg.Title,
		arg.Subtitle,
		arg.ContentType,
		arg.ItemIds,
		arg.FilterRule,
		arg.SortOrder,
		arg.IsActive,
		arg.HubIds,
	)
	var i HomepageSection
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Title,
		&i.Subtitle,
		&i.ContentType,
		&i.ItemIds,
		&i.FilterRule,
		&i.SortOrder,
		&i.IsActive,
		&i.HubIds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
