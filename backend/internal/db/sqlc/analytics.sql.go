// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrderAnalytics = `-- name: CreateOrderAnalytics :one
INSERT INTO order_analytics (
    tenant_id, order_id, restaurant_ids, customer_id, rider_id, hub_id,
    delivery_area, payment_method, platform, promo_code,
    subtotal, item_discount, promo_discount, delivery_charge, vat_total, total_amount, commission_total,
    confirmation_duration_s, preparation_duration_s, pickup_to_delivery_s, total_fulfillment_s,
    final_status, cancellation_reason,
    order_date, order_hour, order_day_of_week, order_week, order_month, order_year,
    completed_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,
    $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30
) RETURNING id, tenant_id, order_id, restaurant_ids, customer_id, rider_id, hub_id, delivery_area, payment_method, platform, promo_code, subtotal, item_discount, promo_discount, delivery_charge, vat_total, total_amount, commission_total, confirmation_duration_s, preparation_duration_s, pickup_to_delivery_s, total_fulfillment_s, final_status, cancellation_reason, order_date, order_hour, order_day_of_week, order_week, order_month, order_year, completed_at, created_at
`

type CreateOrderAnalyticsParams struct {
	TenantID              uuid.UUID          `json:"tenant_id"`
	OrderID               uuid.UUID          `json:"order_id"`
	RestaurantIds         []uuid.UUID        `json:"restaurant_ids"`
	CustomerID            uuid.UUID          `json:"customer_id"`
	RiderID               pgtype.UUID        `json:"rider_id"`
	HubID                 pgtype.UUID        `json:"hub_id"`
	DeliveryArea          sql.NullString     `json:"delivery_area"`
	PaymentMethod         string             `json:"payment_method"`
	Platform              string             `json:"platform"`
	PromoCode             sql.NullString     `json:"promo_code"`
	Subtotal              pgtype.Numeric     `json:"subtotal"`
	ItemDiscount          pgtype.Numeric     `json:"item_discount"`
	PromoDiscount         pgtype.Numeric     `json:"promo_discount"`
	DeliveryCharge        pgtype.Numeric     `json:"delivery_charge"`
	VatTotal              pgtype.Numeric     `json:"vat_total"`
	TotalAmount           pgtype.Numeric     `json:"total_amount"`
	CommissionTotal       pgtype.Numeric     `json:"commission_total"`
	ConfirmationDurationS *int32             `json:"confirmation_duration_s"`
	PreparationDurationS  *int32             `json:"preparation_duration_s"`
	PickupToDeliveryS     *int32             `json:"pickup_to_delivery_s"`
	TotalFulfillmentS     *int32             `json:"total_fulfillment_s"`
	FinalStatus           string             `json:"final_status"`
	CancellationReason    sql.NullString     `json:"cancellation_reason"`
	OrderDate             pgtype.Date        `json:"order_date"`
	OrderHour             int16              `json:"order_hour"`
	OrderDayOfWeek        int16              `json:"order_day_of_week"`
	OrderWeek             int32              `json:"order_week"`
	OrderMonth            int16              `json:"order_month"`
	OrderYear             int16              `json:"order_year"`
	CompletedAt           pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) CreateOrderAnalytics(ctx context.Context, arg CreateOrderAnalyticsParams) (OrderAnalytic, error) {
	row := q.db.QueryRow(ctx, createOrderAnalytics,
		arg.TenantID,
		arg.OrderID,
		arg.RestaurantIds,
		arg.CustomerID,
		arg.RiderID,
		arg.HubID,
		arg.DeliveryArea,
		arg.PaymentMethod,
		arg.Platform,
		arg.PromoCode,
		arg.Subtotal,
		arg.ItemDiscount,
		arg.PromoDiscount,
		arg.DeliveryCharge,
		arg.VatTotal,
		arg.TotalAmount,
		arg.CommissionTotal,
		arg.ConfirmationDurationS,
		arg.PreparationDurationS,
		arg.PickupToDeliveryS,
		arg.TotalFulfillmentS,
		arg.FinalStatus,
		arg.CancellationReason,
		arg.OrderDate,
		arg.OrderHour,
		arg.OrderDayOfWeek,
		arg.OrderWeek,
		arg.OrderMonth,
		arg.OrderYear,
		arg.CompletedAt,
	)
	var i OrderAnalytic
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.RestaurantIds,
		&i.CustomerID,
		&i.RiderID,
		&i.HubID,
		&i.DeliveryArea,
		&i.PaymentMethod,
		&i.Platform,
		&i.PromoCode,
		&i.Subtotal,
		&i.ItemDiscount,
		&i.PromoDiscount,
		&i.DeliveryCharge,
		&i.VatTotal,
		&i.TotalAmount,
		&i.CommissionTotal,
		&i.ConfirmationDurationS,
		&i.PreparationDurationS,
		&i.PickupToDeliveryS,
		&i.TotalFulfillmentS,
		&i.FinalStatus,
		&i.CancellationReason,
		&i.OrderDate,
		&i.OrderHour,
		&i.OrderDayOfWeek,
		&i.OrderWeek,
		&i.OrderMonth,
		&i.OrderYear,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAdminOrderVolume = `-- name: GetAdminOrderVolume :many
SELECT
    order_date,
    COUNT(*)::INT AS order_count,
    COUNT(CASE WHEN final_status = 'delivered' THEN 1 END)::INT AS delivered_count,
    COUNT(CASE WHEN final_status = 'cancelled' THEN 1 END)::INT AS cancelled_count
FROM order_analytics
WHERE order_date >= $1::date AND order_date <= $2::date
GROUP BY order_date
ORDER BY order_date ASC
`

type GetAdminOrderVolumeParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetAdminOrderVolumeRow struct {
	OrderDate      pgtype.Date `json:"order_date"`
	OrderCount     int32       `json:"order_count"`
	DeliveredCount int32       `json:"delivered_count"`
	CancelledCount int32       `json:"cancelled_count"`
}

func (q *Queries) GetAdminOrderVolume(ctx context.Context, arg GetAdminOrderVolumeParams) ([]GetAdminOrderVolumeRow, error) {
	rows, err := q.db.Query(ctx, getAdminOrderVolume, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAdminOrderVolumeRow{}
	for rows.Next() {
		var i GetAdminOrderVolumeRow
		if err := rows.Scan(
			&i.OrderDate,
			&i.OrderCount,
			&i.DeliveredCount,
			&i.CancelledCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminOverview = `-- name: GetAdminOverview :one
SELECT
    COUNT(*)::INT AS total_orders,
    COALESCE(SUM(CASE WHEN final_status = 'delivered' THEN total_amount ELSE 0 END), 0)::NUMERIC(14,2) AS total_revenue,
    COALESCE(SUM(commission_total), 0)::NUMERIC(14,2) AS total_commission,
    COUNT(DISTINCT tenant_id)::INT AS active_tenants,
    COUNT(DISTINCT customer_id)::INT AS unique_customers
FROM order_analytics
WHERE order_date >= $1::date AND order_date <= $2::date
`

type GetAdminOverviewParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetAdminOverviewRow struct {
	TotalOrders     int32          `json:"total_orders"`
	TotalRevenue    pgtype.Numeric `json:"total_revenue"`
	TotalCommission pgtype.Numeric `json:"total_commission"`
	ActiveTenants   int32          `json:"active_tenants"`
	UniqueCustomers int32          `json:"unique_customers"`
}

func (q *Queries) GetAdminOverview(ctx context.Context, arg GetAdminOverviewParams) (GetAdminOverviewRow, error) {
	row := q.db.QueryRow(ctx, getAdminOverview, arg.StartDate, arg.EndDate)
	var i GetAdminOverviewRow
	err := row.Scan(
		&i.TotalOrders,
		&i.TotalRevenue,
		&i.TotalCommission,
		&i.ActiveTenants,
		&i.UniqueCustomers,
	)
	return i, err
}

const getAdminRevenueByPeriod = `-- name: GetAdminRevenueByPeriod :many
SELECT
    order_date,
    COALESCE(SUM(commission_total), 0)::NUMERIC(14,2) AS commission_revenue,
    COALESCE(SUM(total_amount), 0)::NUMERIC(14,2) AS gross_revenue,
    COUNT(*)::INT AS order_count
FROM order_analytics
WHERE order_date >= $1::date AND order_date <= $2::date
GROUP BY order_date
ORDER BY order_date ASC
`

type GetAdminRevenueByPeriodParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetAdminRevenueByPeriodRow struct {
	OrderDate         pgtype.Date    `json:"order_date"`
	CommissionRevenue pgtype.Numeric `json:"commission_revenue"`
	GrossRevenue      pgtype.Numeric `json:"gross_revenue"`
	OrderCount        int32          `json:"order_count"`
}

func (q *Queries) GetAdminRevenueByPeriod(ctx context.Context, arg GetAdminRevenueByPeriodParams) ([]GetAdminRevenueByPeriodRow, error) {
	rows, err := q.db.Query(ctx, getAdminRevenueByPeriod, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAdminRevenueByPeriodRow{}
	for rows.Next() {
		var i GetAdminRevenueByPeriodRow
		if err := rows.Scan(
			&i.OrderDate,
			&i.CommissionRevenue,
			&i.GrossRevenue,
			&i.OrderCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardToday = `-- name: GetDashboardToday :one
SELECT
    COUNT(*)::INT AS total_orders,
    COUNT(CASE WHEN final_status = 'delivered' THEN 1 END)::INT AS delivered_orders,
    COUNT(CASE WHEN final_status = 'cancelled' THEN 1 END)::INT AS cancelled_orders,
    COUNT(CASE WHEN final_status = 'rejected' THEN 1 END)::INT AS rejected_orders,
    COALESCE(SUM(CASE WHEN final_status = 'delivered' THEN total_amount ELSE 0 END), 0)::NUMERIC(14,2) AS today_revenue,
    COALESCE(AVG(CASE WHEN final_status = 'delivered' THEN total_fulfillment_s END), 0)::INT AS avg_delivery_time_s
FROM order_analytics
WHERE tenant_id = $1 AND order_date = CURRENT_DATE
`

type GetDashboardTodayRow struct {
	TotalOrders      int32          `json:"total_orders"`
	DeliveredOrders  int32          `json:"delivered_orders"`
	CancelledOrders  int32          `json:"cancelled_orders"`
	RejectedOrders   int32          `json:"rejected_orders"`
	TodayRevenue     pgtype.Numeric `json:"today_revenue"`
	AvgDeliveryTimeS int32          `json:"avg_delivery_time_s"`
}

func (q *Queries) GetDashboardToday(ctx context.Context, tenantID uuid.UUID) (GetDashboardTodayRow, error) {
	row := q.db.QueryRow(ctx, getDashboardToday, tenantID)
	var i GetDashboardTodayRow
	err := row.Scan(
		&i.TotalOrders,
		&i.DeliveredOrders,
		&i.CancelledOrders,
		&i.RejectedOrders,
		&i.TodayRevenue,
		&i.AvgDeliveryTimeS,
	)
	return i, err
}

const getDashboardTrend = `-- name: GetDashboardTrend :many
SELECT
    order_date,
    COUNT(*)::INT AS order_count,
    COALESCE(SUM(CASE WHEN final_status = 'delivered' THEN total_amount ELSE 0 END), 0)::NUMERIC(14,2) AS revenue
FROM order_analytics
WHERE tenant_id = $1 AND order_date >= $2::date AND order_date <= $3::date
GROUP BY order_date
ORDER BY order_date ASC
`

type GetDashboardTrendParams struct {
	TenantID  uuid.UUID   `json:"tenant_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetDashboardTrendRow struct {
	OrderDate  pgtype.Date    `json:"order_date"`
	OrderCount int32          `json:"order_count"`
	Revenue    pgtype.Numeric `json:"revenue"`
}

func (q *Queries) GetDashboardTrend(ctx context.Context, arg GetDashboardTrendParams) ([]GetDashboardTrendRow, error) {
	rows, err := q.db.Query(ctx, getDashboardTrend, arg.TenantID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDashboardTrendRow{}
	for rows.Next() {
		var i GetDashboardTrendRow
		if err := rows.Scan(&i.OrderDate, &i.OrderCount, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderAnalyticsByOrderID = `-- name: GetOrderAnalyticsByOrderID :one
SELECT id, tenant_id, order_id, restaurant_ids, customer_id, rider_id, hub_id, delivery_area, payment_method, platform, promo_code, subtotal, item_discount, promo_discount, delivery_charge, vat_total, total_amount, commission_total, confirmation_duration_s, preparation_duration_s, pickup_to_delivery_s, total_fulfillment_s, final_status, cancellation_reason, order_date, order_hour, order_day_of_week, order_week, order_month, order_year, completed_at, created_at FROM order_analytics WHERE order_id = $1 AND tenant_id = $2 LIMIT 1
`

type GetOrderAnalyticsByOrderIDParams struct {
	OrderID  uuid.UUID `json:"order_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetOrderAnalyticsByOrderID(ctx context.Context, arg GetOrderAnalyticsByOrderIDParams) (OrderAnalytic, error) {
	row := q.db.QueryRow(ctx, getOrderAnalyticsByOrderID, arg.OrderID, arg.TenantID)
	var i OrderAnalytic
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.OrderID,
		&i.RestaurantIds,
		&i.CustomerID,
		&i.RiderID,
		&i.HubID,
		&i.DeliveryArea,
		&i.PaymentMethod,
		&i.Platform,
		&i.PromoCode,
		&i.Subtotal,
		&i.ItemDiscount,
		&i.PromoDiscount,
		&i.DeliveryCharge,
		&i.VatTotal,
		&i.TotalAmount,
		&i.CommissionTotal,
		&i.ConfirmationDurationS,
		&i.PreparationDurationS,
		&i.PickupToDeliveryS,
		&i.TotalFulfillmentS,
		&i.FinalStatus,
		&i.CancellationReason,
		&i.OrderDate,
		&i.OrderHour,
		&i.OrderDayOfWeek,
		&i.OrderWeek,
		&i.OrderMonth,
		&i.OrderYear,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderStatusBreakdown = `-- name: GetOrderStatusBreakdown :many
SELECT
    final_status,
    COUNT(*)::INT AS order_count
FROM order_analytics
WHERE tenant_id = $1
  AND order_date >= $2::date
  AND order_date <= $3::date
GROUP BY final_status
`

type GetOrderStatusBreakdownParams struct {
	TenantID  uuid.UUID   `json:"tenant_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetOrderStatusBreakdownRow struct {
	FinalStatus string `json:"final_status"`
	OrderCount  int32  `json:"order_count"`
}

func (q *Queries) GetOrderStatusBreakdown(ctx context.Context, arg GetOrderStatusBreakdownParams) ([]GetOrderStatusBreakdownRow, error) {
	rows, err := q.db.Query(ctx, getOrderStatusBreakdown, arg.TenantID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderStatusBreakdownRow{}
	for rows.Next() {
		var i GetOrderStatusBreakdownRow
		if err := rows.Scan(&i.FinalStatus, &i.OrderCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPeakHours = `-- name: GetPeakHours :many
SELECT
    order_hour,
    COUNT(*)::INT AS order_count
FROM order_analytics
WHERE tenant_id = $1
  AND order_date >= $2::date
  AND order_date <= $3::date
GROUP BY order_hour
ORDER BY order_hour ASC
`

type GetPeakHoursParams struct {
	TenantID  uuid.UUID   `json:"tenant_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetPeakHoursRow struct {
	OrderHour  int16 `json:"order_hour"`
	OrderCount int32 `json:"order_count"`
}

func (q *Queries) GetPeakHours(ctx context.Context, arg GetPeakHoursParams) ([]GetPeakHoursRow, error) {
	rows, err := q.db.Query(ctx, getPeakHours, arg.TenantID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPeakHoursRow{}
	for rows.Next() {
		var i GetPeakHoursRow
		if err := rows.Scan(&i.OrderHour, &i.OrderCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingOrderCount = `-- name: GetPendingOrderCount :one
SELECT COUNT(*)::INT FROM orders
WHERE tenant_id = $1 AND status IN ('pending', 'created') AND deleted_at IS NULL
`

func (q *Queries) GetPendingOrderCount(ctx context.Context, tenantID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getPendingOrderCount, tenantID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getRiderAnalytics = `-- name: GetRiderAnalytics :many
SELECT
    rider_id,
    COUNT(*)::INT AS total_orders,
    COALESCE(AVG(total_fulfillment_s), 0)::INT AS avg_delivery_time_s,
    COALESCE(SUM(delivery_charge), 0)::NUMERIC(14,2) AS total_delivery_revenue
FROM order_analytics
WHERE tenant_id = $1
  AND rider_id IS NOT NULL
  AND order_date >= $2::date
  AND order_date <= $3::date
GROUP BY rider_id
ORDER BY total_orders DESC
`

type GetRiderAnalyticsParams struct {
	TenantID  uuid.UUID   `json:"tenant_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetRiderAnalyticsRow struct {
	RiderID              pgtype.UUID    `json:"rider_id"`
	TotalOrders          int32          `json:"total_orders"`
	AvgDeliveryTimeS     int32          `json:"avg_delivery_time_s"`
	TotalDeliveryRevenue pgtype.Numeric `json:"total_delivery_revenue"`
}

func (q *Queries) GetRiderAnalytics(ctx context.Context, arg GetRiderAnalyticsParams) ([]GetRiderAnalyticsRow, error) {
	rows, err := q.db.Query(ctx, getRiderAnalytics, arg.TenantID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRiderAnalyticsRow{}
	for rows.Next() {
		var i GetRiderAnalyticsRow
		if err := rows.Scan(
			&i.RiderID,
			&i.TotalOrders,
			&i.AvgDeliveryTimeS,
			&i.TotalDeliveryRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesReport = `-- name: GetSalesReport :many
SELECT
    order_date,
    COUNT(*)::INT AS order_count,
    COALESCE(SUM(subtotal), 0)::NUMERIC(14,2) AS gross_sales,
    COALESCE(SUM(item_discount), 0)::NUMERIC(14,2) AS item_discounts,
    COALESCE(SUM(promo_discount), 0)::NUMERIC(14,2) AS promo_discounts,
    COALESCE(SUM(subtotal - item_discount - promo_discount), 0)::NUMERIC(14,2) AS net_sales,
    COALESCE(SUM(vat_total), 0)::NUMERIC(14,2) AS vat_total,
    COALESCE(SUM(commission_total), 0)::NUMERIC(14,2) AS commission,
    COALESCE(SUM(total_amount), 0)::NUMERIC(14,2) AS total_revenue,
    COALESCE(AVG(total_amount), 0)::NUMERIC(14,2) AS avg_order_value,
    COALESCE(AVG(total_fulfillment_s), 0)::INT AS avg_delivery_time_s
FROM order_analytics
WHERE tenant_id = $1
  AND order_date >= $2::date
  AND order_date <= $3::date
  AND final_status = 'delivered'
GROUP BY order_date
ORDER BY order_date ASC
`

type GetSalesReportParams struct {
	TenantID  uuid.UUID   `json:"tenant_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetSalesReportRow struct {
	OrderDate        pgtype.Date    `json:"order_date"`
	OrderCount       int32          `json:"order_count"`
	GrossSales       pgtype.Numeric `json:"gross_sales"`
	ItemDiscounts    pgtype.Numeric `json:"item_discounts"`
	PromoDiscounts   pgtype.Numeric `json:"promo_discounts"`
	NetSales         pgtype.Numeric `json:"net_sales"`
	VatTotal         pgtype.Numeric `json:"vat_total"`
	Commission       pgtype.Numeric `json:"commission"`
	TotalRevenue     pgtype.Numeric `json:"total_revenue"`
	AvgOrderValue    pgtype.Numeric `json:"avg_order_value"`
	AvgDeliveryTimeS int32          `json:"avg_delivery_time_s"`
}

func (q *Queries) GetSalesReport(ctx context.Context, arg GetSalesReportParams) ([]GetSalesReportRow, error) {
	rows, err := q.db.Query(ctx, getSalesReport, arg.TenantID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSalesReportRow{}
	for rows.Next() {
		var i GetSalesReportRow
		if err := rows.Scan(
			&i.OrderDate,
			&i.OrderCount,
			&i.GrossSales,
			&i.ItemDiscounts,
			&i.PromoDiscounts,
			&i.NetSales,
			&i.VatTotal,
			&i.Commission,
			&i.TotalRevenue,
			&i.AvgOrderValue,
			&i.AvgDeliveryTimeS,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenantAnalytics = `-- name: GetTenantAnalytics :one
SELECT
    COUNT(*)::INT AS total_orders,
    COALESCE(SUM(CASE WHEN final_status = 'delivered' THEN total_amount ELSE 0 END), 0)::NUMERIC(14,2) AS total_revenue,
    COALESCE(SUM(commission_total), 0)::NUMERIC(14,2) AS total_commission,
    COUNT(DISTINCT customer_id)::INT AS unique_customers,
    COALESCE(AVG(CASE WHEN final_status = 'delivered' THEN total_fulfillment_s END), 0)::INT AS avg_delivery_time_s
FROM order_analytics
WHERE tenant_id = $1
  AND order_date >= $2::date
  AND order_date <= $3::date
`

type GetTenantAnalyticsParams struct {
	TenantID  uuid.UUID   `json:"tenant_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetTenantAnalyticsRow struct {
	TotalOrders      int32          `json:"total_orders"`
	TotalRevenue     pgtype.Numeric `json:"total_revenue"`
	TotalCommission  pgtype.Numeric `json:"total_commission"`
	UniqueCustomers  int32          `json:"unique_customers"`
	AvgDeliveryTimeS int32          `json:"avg_delivery_time_s"`
}

func (q *Queries) GetTenantAnalytics(ctx context.Context, arg GetTenantAnalyticsParams) (GetTenantAnalyticsRow, error) {
	row := q.db.QueryRow(ctx, getTenantAnalytics, arg.TenantID, arg.StartDate, arg.EndDate)
	var i GetTenantAnalyticsRow
	err := row.Scan(
		&i.TotalOrders,
		&i.TotalRevenue,
		&i.TotalCommission,
		&i.UniqueCustomers,
		&i.AvgDeliveryTimeS,
	)
	return i, err
}

const getTopProducts = `-- name: GetTopProducts :many
SELECT
    oi.product_name,
    oi.product_id,
    SUM(oi.quantity)::INT AS total_quantity,
    SUM(oi.item_total)::NUMERIC(14,2) AS total_revenue
FROM order_items oi
JOIN orders o ON oi.order_id = o.id
WHERE o.tenant_id = $1
  AND o.status = 'delivered'
  AND o.delivered_at >= $3::timestamptz
  AND o.delivered_at < $4::timestamptz
GROUP BY oi.product_id, oi.product_name
ORDER BY total_quantity DESC
LIMIT $2
`

type GetTopProductsParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	Limit     int32     `json:"limit"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

type GetTopProductsRow struct {
	ProductName   string         `json:"product_name"`
	ProductID     uuid.UUID      `json:"product_id"`
	TotalQuantity int32          `json:"total_quantity"`
	TotalRevenue  pgtype.Numeric `json:"total_revenue"`
}

func (q *Queries) GetTopProducts(ctx context.Context, arg GetTopProductsParams) ([]GetTopProductsRow, error) {
	rows, err := q.db.Query(ctx, getTopProducts,
		arg.TenantID,
		arg.Limit,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopProductsRow{}
	for rows.Next() {
		var i GetTopProductsRow
		if err := rows.Scan(
			&i.ProductName,
			&i.ProductID,
			&i.TotalQuantity,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
