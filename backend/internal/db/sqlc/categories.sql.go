// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: categories.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (tenant_id, restaurant_id, parent_id, name, slug, description, image_url, icon_url, extra_prep_time_minutes, is_tobacco, is_active, sort_order)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, tenant_id, restaurant_id, parent_id, name, slug, description, image_url, icon_url, extra_prep_time_minutes, is_tobacco, is_active, sort_order, created_at, updated_at
`

type CreateCategoryParams struct {
	TenantID             uuid.UUID      `json:"tenant_id"`
	RestaurantID         pgtype.UUID    `json:"restaurant_id"`
	ParentID             pgtype.UUID    `json:"parent_id"`
	Name                 string         `json:"name"`
	Slug                 string         `json:"slug"`
	Description          sql.NullString `json:"description"`
	ImageUrl             sql.NullString `json:"image_url"`
	IconUrl              sql.NullString `json:"icon_url"`
	ExtraPrepTimeMinutes int32          `json:"extra_prep_time_minutes"`
	IsTobacco            bool           `json:"is_tobacco"`
	IsActive             bool           `json:"is_active"`
	SortOrder            int32          `json:"sort_order"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.TenantID, arg.RestaurantID, arg.ParentID,
		arg.Name, arg.Slug, arg.Description,
		arg.ImageUrl, arg.IconUrl,
		arg.ExtraPrepTimeMinutes, arg.IsTobacco, arg.IsActive, arg.SortOrder,
	)
	var i Category
	err := row.Scan(
		&i.ID, &i.TenantID, &i.RestaurantID, &i.ParentID,
		&i.Name, &i.Slug, &i.Description,
		&i.ImageUrl, &i.IconUrl,
		&i.ExtraPrepTimeMinutes, &i.IsTobacco, &i.IsActive, &i.SortOrder,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, tenant_id, restaurant_id, parent_id, name, slug, description, image_url, icon_url, extra_prep_time_minutes, is_tobacco, is_active, sort_order, created_at, updated_at FROM categories WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetCategoryByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetCategoryByID(ctx context.Context, arg GetCategoryByIDParams) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryByID, arg.ID, arg.TenantID)
	var i Category
	err := row.Scan(
		&i.ID, &i.TenantID, &i.RestaurantID, &i.ParentID,
		&i.Name, &i.Slug, &i.Description,
		&i.ImageUrl, &i.IconUrl,
		&i.ExtraPrepTimeMinutes, &i.IsTobacco, &i.IsActive, &i.SortOrder,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const listCategoriesByRestaurant = `-- name: ListCategoriesByRestaurant :many
SELECT id, tenant_id, restaurant_id, parent_id, name, slug, description, image_url, icon_url, extra_prep_time_minutes, is_tobacco, is_active, sort_order, created_at, updated_at FROM categories WHERE restaurant_id = $1 AND tenant_id = $2 AND is_active = true ORDER BY sort_order, name
`

type ListCategoriesByRestaurantParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
}

func (q *Queries) ListCategoriesByRestaurant(ctx context.Context, arg ListCategoriesByRestaurantParams) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategoriesByRestaurant, arg.RestaurantID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID, &i.TenantID, &i.RestaurantID, &i.ParentID,
			&i.Name, &i.Slug, &i.Description,
			&i.ImageUrl, &i.IconUrl,
			&i.ExtraPrepTimeMinutes, &i.IsTobacco, &i.IsActive, &i.SortOrder,
			&i.CreatedAt, &i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories SET
  name = COALESCE($1, name),
  description = COALESCE($2, description),
  image_url = COALESCE($3, image_url),
  sort_order = COALESCE($4, sort_order),
  is_active = COALESCE($5, is_active)
WHERE id = $6 AND tenant_id = $7
RETURNING id, tenant_id, restaurant_id, parent_id, name, slug, description, image_url, icon_url, extra_prep_time_minutes, is_tobacco, is_active, sort_order, created_at, updated_at
`

type UpdateCategoryParams struct {
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	ImageUrl    sql.NullString `json:"image_url"`
	SortOrder   *int32         `json:"sort_order"`
	IsActive    *bool          `json:"is_active"`
	ID          uuid.UUID      `json:"id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.Name, arg.Description, arg.ImageUrl, arg.SortOrder, arg.IsActive,
		arg.ID, arg.TenantID,
	)
	var i Category
	err := row.Scan(
		&i.ID, &i.TenantID, &i.RestaurantID, &i.ParentID,
		&i.Name, &i.Slug, &i.Description,
		&i.ImageUrl, &i.IconUrl,
		&i.ExtraPrepTimeMinutes, &i.IsTobacco, &i.IsActive, &i.SortOrder,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
UPDATE categories SET is_active = false WHERE id = $1 AND tenant_id = $2
`

type DeleteCategoryParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteCategory(ctx context.Context, arg DeleteCategoryParams) error {
	_, err := q.db.Exec(ctx, deleteCategory, arg.ID, arg.TenantID)
	return err
}

const updateCategorySortOrder = `-- name: UpdateCategorySortOrder :exec
UPDATE categories SET sort_order = $2 WHERE id = $1 AND tenant_id = $3
`

type UpdateCategorySortOrderParams struct {
	ID        uuid.UUID `json:"id"`
	SortOrder int32     `json:"sort_order"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

func (q *Queries) UpdateCategorySortOrder(ctx context.Context, arg UpdateCategorySortOrderParams) error {
	_, err := q.db.Exec(ctx, updateCategorySortOrder, arg.ID, arg.SortOrder, arg.TenantID)
	return err
}
