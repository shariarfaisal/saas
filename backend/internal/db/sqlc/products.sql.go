// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (tenant_id, restaurant_id, category_id, name, slug, description, base_price, vat_rate, availability, images, tags, is_featured, is_inv_tracked, sort_order)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, tenant_id, restaurant_id, category_id, name, slug, description, base_price, vat_rate, has_modifiers, availability, images, tags, is_featured, is_inv_tracked, sort_order, meta_title, meta_description, rating_avg, rating_count, order_count, created_at, updated_at
`

type CreateProductParams struct {
	TenantID     uuid.UUID      `json:"tenant_id"`
	RestaurantID uuid.UUID      `json:"restaurant_id"`
	CategoryID   pgtype.UUID    `json:"category_id"`
	Name         string         `json:"name"`
	Slug         string         `json:"slug"`
	Description  sql.NullString `json:"description"`
	BasePrice    pgtype.Numeric `json:"base_price"`
	VatRate      pgtype.Numeric `json:"vat_rate"`
	Availability ProductAvail   `json:"availability"`
	Images       []string       `json:"images"`
	Tags         []string       `json:"tags"`
	IsFeatured   bool           `json:"is_featured"`
	IsInvTracked bool           `json:"is_inv_tracked"`
	SortOrder    int32          `json:"sort_order"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.TenantID, arg.RestaurantID, arg.CategoryID,
		arg.Name, arg.Slug, arg.Description,
		arg.BasePrice, arg.VatRate, arg.Availability,
		arg.Images, arg.Tags, arg.IsFeatured, arg.IsInvTracked, arg.SortOrder,
	)
	var i Product
	err := row.Scan(
		&i.ID, &i.TenantID, &i.RestaurantID, &i.CategoryID,
		&i.Name, &i.Slug, &i.Description,
		&i.BasePrice, &i.VatRate, &i.HasModifiers, &i.Availability,
		&i.Images, &i.Tags, &i.IsFeatured, &i.IsInvTracked, &i.SortOrder,
		&i.MetaTitle, &i.MetaDescription,
		&i.RatingAvg, &i.RatingCount, &i.OrderCount,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, tenant_id, restaurant_id, category_id, name, slug, description, base_price, vat_rate, has_modifiers, availability, images, tags, is_featured, is_inv_tracked, sort_order, meta_title, meta_description, rating_avg, rating_count, order_count, created_at, updated_at FROM products WHERE id = $1 AND tenant_id = $2 LIMIT 1
`

type GetProductByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetProductByID(ctx context.Context, arg GetProductByIDParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, arg.ID, arg.TenantID)
	var i Product
	err := row.Scan(
		&i.ID, &i.TenantID, &i.RestaurantID, &i.CategoryID,
		&i.Name, &i.Slug, &i.Description,
		&i.BasePrice, &i.VatRate, &i.HasModifiers, &i.Availability,
		&i.Images, &i.Tags, &i.IsFeatured, &i.IsInvTracked, &i.SortOrder,
		&i.MetaTitle, &i.MetaDescription,
		&i.RatingAvg, &i.RatingCount, &i.OrderCount,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const getProductByIDPublic = `-- name: GetProductByIDPublic :one
SELECT id, tenant_id, restaurant_id, category_id, name, slug, description, base_price, vat_rate, has_modifiers, availability, images, tags, is_featured, is_inv_tracked, sort_order, meta_title, meta_description, rating_avg, rating_count, order_count, created_at, updated_at FROM products WHERE id = $1 AND availability = 'available' LIMIT 1
`

func (q *Queries) GetProductByIDPublic(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByIDPublic, id)
	var i Product
	err := row.Scan(
		&i.ID, &i.TenantID, &i.RestaurantID, &i.CategoryID,
		&i.Name, &i.Slug, &i.Description,
		&i.BasePrice, &i.VatRate, &i.HasModifiers, &i.Availability,
		&i.Images, &i.Tags, &i.IsFeatured, &i.IsInvTracked, &i.SortOrder,
		&i.MetaTitle, &i.MetaDescription,
		&i.RatingAvg, &i.RatingCount, &i.OrderCount,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const listProductsByRestaurant = `-- name: ListProductsByRestaurant :many
SELECT id, tenant_id, restaurant_id, category_id, name, slug, description, base_price, vat_rate, has_modifiers, availability, images, tags, is_featured, is_inv_tracked, sort_order, meta_title, meta_description, rating_avg, rating_count, order_count, created_at, updated_at FROM products WHERE restaurant_id = $1 AND tenant_id = $2 ORDER BY sort_order, name LIMIT $3 OFFSET $4
`

type ListProductsByRestaurantParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
	Limit        int32     `json:"limit"`
	Offset       int32     `json:"offset"`
}

func (q *Queries) ListProductsByRestaurant(ctx context.Context, arg ListProductsByRestaurantParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProductsByRestaurant, arg.RestaurantID, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID, &i.TenantID, &i.RestaurantID, &i.CategoryID,
			&i.Name, &i.Slug, &i.Description,
			&i.BasePrice, &i.VatRate, &i.HasModifiers, &i.Availability,
			&i.Images, &i.Tags, &i.IsFeatured, &i.IsInvTracked, &i.SortOrder,
			&i.MetaTitle, &i.MetaDescription,
			&i.RatingAvg, &i.RatingCount, &i.OrderCount,
			&i.CreatedAt, &i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countProductsByRestaurant = `-- name: CountProductsByRestaurant :one
SELECT COUNT(*) FROM products WHERE restaurant_id = $1 AND tenant_id = $2
`

type CountProductsByRestaurantParams struct {
	RestaurantID uuid.UUID `json:"restaurant_id"`
	TenantID     uuid.UUID `json:"tenant_id"`
}

func (q *Queries) CountProductsByRestaurant(ctx context.Context, arg CountProductsByRestaurantParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsByRestaurant, arg.RestaurantID, arg.TenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listAvailableProductsByRestaurant = `-- name: ListAvailableProductsByRestaurant :many
SELECT id, tenant_id, restaurant_id, category_id, name, slug, description, base_price, vat_rate, has_modifiers, availability, images, tags, is_featured, is_inv_tracked, sort_order, meta_title, meta_description, rating_avg, rating_count, order_count, created_at, updated_at FROM products WHERE restaurant_id = $1 AND availability = 'available' ORDER BY sort_order, name
`

func (q *Queries) ListAvailableProductsByRestaurant(ctx context.Context, restaurantID uuid.UUID) ([]Product, error) {
	rows, err := q.db.Query(ctx, listAvailableProductsByRestaurant, restaurantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID, &i.TenantID, &i.RestaurantID, &i.CategoryID,
			&i.Name, &i.Slug, &i.Description,
			&i.BasePrice, &i.VatRate, &i.HasModifiers, &i.Availability,
			&i.Images, &i.Tags, &i.IsFeatured, &i.IsInvTracked, &i.SortOrder,
			&i.MetaTitle, &i.MetaDescription,
			&i.RatingAvg, &i.RatingCount, &i.OrderCount,
			&i.CreatedAt, &i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products SET
  name = COALESCE($1, name),
  description = COALESCE($2, description),
  category_id = COALESCE($3, category_id),
  base_price = COALESCE($4, base_price),
  vat_rate = COALESCE($5, vat_rate),
  images = COALESCE($6, images),
  tags = COALESCE($7, tags),
  is_featured = COALESCE($8, is_featured),
  sort_order = COALESCE($9, sort_order)
WHERE id = $10 AND tenant_id = $11
RETURNING id, tenant_id, restaurant_id, category_id, name, slug, description, base_price, vat_rate, has_modifiers, availability, images, tags, is_featured, is_inv_tracked, sort_order, meta_title, meta_description, rating_avg, rating_count, order_count, created_at, updated_at
`

type UpdateProductParams struct {
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	CategoryID  pgtype.UUID    `json:"category_id"`
	BasePrice   pgtype.Numeric `json:"base_price"`
	VatRate     pgtype.Numeric `json:"vat_rate"`
	Images      []string       `json:"images"`
	Tags        []string       `json:"tags"`
	IsFeatured  *bool          `json:"is_featured"`
	SortOrder   *int32         `json:"sort_order"`
	ID          uuid.UUID      `json:"id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name, arg.Description, arg.CategoryID,
		arg.BasePrice, arg.VatRate, arg.Images, arg.Tags,
		arg.IsFeatured, arg.SortOrder,
		arg.ID, arg.TenantID,
	)
	var i Product
	err := row.Scan(
		&i.ID, &i.TenantID, &i.RestaurantID, &i.CategoryID,
		&i.Name, &i.Slug, &i.Description,
		&i.BasePrice, &i.VatRate, &i.HasModifiers, &i.Availability,
		&i.Images, &i.Tags, &i.IsFeatured, &i.IsInvTracked, &i.SortOrder,
		&i.MetaTitle, &i.MetaDescription,
		&i.RatingAvg, &i.RatingCount, &i.OrderCount,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const updateProductAvailability = `-- name: UpdateProductAvailability :one
UPDATE products SET availability = $2 WHERE id = $1 AND tenant_id = $3 RETURNING id, tenant_id, restaurant_id, category_id, name, slug, description, base_price, vat_rate, has_modifiers, availability, images, tags, is_featured, is_inv_tracked, sort_order, meta_title, meta_description, rating_avg, rating_count, order_count, created_at, updated_at
`

type UpdateProductAvailabilityParams struct {
	ID           uuid.UUID    `json:"id"`
	Availability ProductAvail `json:"availability"`
	TenantID     uuid.UUID    `json:"tenant_id"`
}

func (q *Queries) UpdateProductAvailability(ctx context.Context, arg UpdateProductAvailabilityParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProductAvailability, arg.ID, arg.Availability, arg.TenantID)
	var i Product
	err := row.Scan(
		&i.ID, &i.TenantID, &i.RestaurantID, &i.CategoryID,
		&i.Name, &i.Slug, &i.Description,
		&i.BasePrice, &i.VatRate, &i.HasModifiers, &i.Availability,
		&i.Images, &i.Tags, &i.IsFeatured, &i.IsInvTracked, &i.SortOrder,
		&i.MetaTitle, &i.MetaDescription,
		&i.RatingAvg, &i.RatingCount, &i.OrderCount,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const updateProductHasModifiers = `-- name: UpdateProductHasModifiers :exec
UPDATE products SET has_modifiers = $2 WHERE id = $1
`

type UpdateProductHasModifiersParams struct {
	ID           uuid.UUID `json:"id"`
	HasModifiers bool      `json:"has_modifiers"`
}

func (q *Queries) UpdateProductHasModifiers(ctx context.Context, arg UpdateProductHasModifiersParams) error {
	_, err := q.db.Exec(ctx, updateProductHasModifiers, arg.ID, arg.HasModifiers)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1 AND tenant_id = $2
`

type DeleteProductParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) error {
	_, err := q.db.Exec(ctx, deleteProduct, arg.ID, arg.TenantID)
	return err
}

const createModifierGroup = `-- name: CreateModifierGroup :one
INSERT INTO product_modifier_groups (product_id, tenant_id, name, description, min_required, max_allowed, sort_order)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, product_id, tenant_id, name, description, min_required, max_allowed, sort_order
`

type CreateModifierGroupParams struct {
	ProductID   uuid.UUID      `json:"product_id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	MinRequired int32          `json:"min_required"`
	MaxAllowed  int32          `json:"max_allowed"`
	SortOrder   int32          `json:"sort_order"`
}

func (q *Queries) CreateModifierGroup(ctx context.Context, arg CreateModifierGroupParams) (ProductModifierGroup, error) {
	row := q.db.QueryRow(ctx, createModifierGroup,
		arg.ProductID, arg.TenantID, arg.Name, arg.Description,
		arg.MinRequired, arg.MaxAllowed, arg.SortOrder,
	)
	var i ProductModifierGroup
	err := row.Scan(
		&i.ID, &i.ProductID, &i.TenantID,
		&i.Name, &i.Description, &i.MinRequired, &i.MaxAllowed, &i.SortOrder,
	)
	return i, err
}

const getModifierGroupByID = `-- name: GetModifierGroupByID :one
SELECT id, product_id, tenant_id, name, description, min_required, max_allowed, sort_order FROM product_modifier_groups WHERE id = $1 LIMIT 1
`

func (q *Queries) GetModifierGroupByID(ctx context.Context, id uuid.UUID) (ProductModifierGroup, error) {
	row := q.db.QueryRow(ctx, getModifierGroupByID, id)
	var i ProductModifierGroup
	err := row.Scan(
		&i.ID, &i.ProductID, &i.TenantID,
		&i.Name, &i.Description, &i.MinRequired, &i.MaxAllowed, &i.SortOrder,
	)
	return i, err
}

const listModifierGroupsByProduct = `-- name: ListModifierGroupsByProduct :many
SELECT id, product_id, tenant_id, name, description, min_required, max_allowed, sort_order FROM product_modifier_groups WHERE product_id = $1 ORDER BY sort_order, name
`

func (q *Queries) ListModifierGroupsByProduct(ctx context.Context, productID uuid.UUID) ([]ProductModifierGroup, error) {
	rows, err := q.db.Query(ctx, listModifierGroupsByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductModifierGroup{}
	for rows.Next() {
		var i ProductModifierGroup
		if err := rows.Scan(
			&i.ID, &i.ProductID, &i.TenantID,
			&i.Name, &i.Description, &i.MinRequired, &i.MaxAllowed, &i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateModifierGroup = `-- name: UpdateModifierGroup :one
UPDATE product_modifier_groups SET
  name = COALESCE($1, name),
  description = COALESCE($2, description),
  min_required = COALESCE($3, min_required),
  max_allowed = COALESCE($4, max_allowed),
  sort_order = COALESCE($5, sort_order)
WHERE id = $6
RETURNING id, product_id, tenant_id, name, description, min_required, max_allowed, sort_order
`

type UpdateModifierGroupParams struct {
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
	MinRequired *int32         `json:"min_required"`
	MaxAllowed  *int32         `json:"max_allowed"`
	SortOrder   *int32         `json:"sort_order"`
	ID          uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateModifierGroup(ctx context.Context, arg UpdateModifierGroupParams) (ProductModifierGroup, error) {
	row := q.db.QueryRow(ctx, updateModifierGroup,
		arg.Name, arg.Description, arg.MinRequired, arg.MaxAllowed, arg.SortOrder, arg.ID,
	)
	var i ProductModifierGroup
	err := row.Scan(
		&i.ID, &i.ProductID, &i.TenantID,
		&i.Name, &i.Description, &i.MinRequired, &i.MaxAllowed, &i.SortOrder,
	)
	return i, err
}

const deleteModifierGroup = `-- name: DeleteModifierGroup :exec
DELETE FROM product_modifier_groups WHERE id = $1
`

func (q *Queries) DeleteModifierGroup(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteModifierGroup, id)
	return err
}

const createModifierOption = `-- name: CreateModifierOption :one
INSERT INTO product_modifier_options (modifier_group_id, product_id, tenant_id, name, additional_price, is_available, sort_order)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, modifier_group_id, product_id, tenant_id, name, additional_price, is_available, sort_order
`

type CreateModifierOptionParams struct {
	ModifierGroupID uuid.UUID      `json:"modifier_group_id"`
	ProductID       uuid.UUID      `json:"product_id"`
	TenantID        uuid.UUID      `json:"tenant_id"`
	Name            string         `json:"name"`
	AdditionalPrice pgtype.Numeric `json:"additional_price"`
	IsAvailable     bool           `json:"is_available"`
	SortOrder       int32          `json:"sort_order"`
}

func (q *Queries) CreateModifierOption(ctx context.Context, arg CreateModifierOptionParams) (ProductModifierOption, error) {
	row := q.db.QueryRow(ctx, createModifierOption,
		arg.ModifierGroupID, arg.ProductID, arg.TenantID,
		arg.Name, arg.AdditionalPrice, arg.IsAvailable, arg.SortOrder,
	)
	var i ProductModifierOption
	err := row.Scan(
		&i.ID, &i.ModifierGroupID, &i.ProductID, &i.TenantID,
		&i.Name, &i.AdditionalPrice, &i.IsAvailable, &i.SortOrder,
	)
	return i, err
}

const listModifierOptionsByGroup = `-- name: ListModifierOptionsByGroup :many
SELECT id, modifier_group_id, product_id, tenant_id, name, additional_price, is_available, sort_order FROM product_modifier_options WHERE modifier_group_id = $1 ORDER BY sort_order, name
`

func (q *Queries) ListModifierOptionsByGroup(ctx context.Context, modifierGroupID uuid.UUID) ([]ProductModifierOption, error) {
	rows, err := q.db.Query(ctx, listModifierOptionsByGroup, modifierGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductModifierOption{}
	for rows.Next() {
		var i ProductModifierOption
		if err := rows.Scan(
			&i.ID, &i.ModifierGroupID, &i.ProductID, &i.TenantID,
			&i.Name, &i.AdditionalPrice, &i.IsAvailable, &i.SortOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateModifierOption = `-- name: UpdateModifierOption :one
UPDATE product_modifier_options SET
  name = COALESCE($1, name),
  additional_price = COALESCE($2, additional_price),
  is_available = COALESCE($3, is_available),
  sort_order = COALESCE($4, sort_order)
WHERE id = $5
RETURNING id, modifier_group_id, product_id, tenant_id, name, additional_price, is_available, sort_order
`

type UpdateModifierOptionParams struct {
	Name            sql.NullString `json:"name"`
	AdditionalPrice pgtype.Numeric `json:"additional_price"`
	IsAvailable     *bool          `json:"is_available"`
	SortOrder       *int32         `json:"sort_order"`
	ID              uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateModifierOption(ctx context.Context, arg UpdateModifierOptionParams) (ProductModifierOption, error) {
	row := q.db.QueryRow(ctx, updateModifierOption,
		arg.Name, arg.AdditionalPrice, arg.IsAvailable, arg.SortOrder, arg.ID,
	)
	var i ProductModifierOption
	err := row.Scan(
		&i.ID, &i.ModifierGroupID, &i.ProductID, &i.TenantID,
		&i.Name, &i.AdditionalPrice, &i.IsAvailable, &i.SortOrder,
	)
	return i, err
}

const deleteModifierOption = `-- name: DeleteModifierOption :exec
DELETE FROM product_modifier_options WHERE id = $1
`

func (q *Queries) DeleteModifierOption(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteModifierOption, id)
	return err
}

const deleteModifierOptionsByGroup = `-- name: DeleteModifierOptionsByGroup :exec
DELETE FROM product_modifier_options WHERE modifier_group_id = $1
`

func (q *Queries) DeleteModifierOptionsByGroup(ctx context.Context, modifierGroupID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteModifierOptionsByGroup, modifierGroupID)
	return err
}

const upsertProductDiscount = `-- name: UpsertProductDiscount :one
INSERT INTO product_discounts (product_id, restaurant_id, tenant_id, discount_type, amount, max_discount_cap, starts_at, ends_at, is_active, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT (product_id) WHERE is_active = true DO UPDATE SET
  discount_type = EXCLUDED.discount_type,
  amount = EXCLUDED.amount,
  max_discount_cap = EXCLUDED.max_discount_cap,
  starts_at = EXCLUDED.starts_at,
  ends_at = EXCLUDED.ends_at,
  is_active = EXCLUDED.is_active
RETURNING id, product_id, restaurant_id, tenant_id, discount_type, amount, max_discount_cap, starts_at, ends_at, is_active, created_by, created_at, updated_at
`

type UpsertProductDiscountParams struct {
	ProductID      uuid.UUID          `json:"product_id"`
	RestaurantID   uuid.UUID          `json:"restaurant_id"`
	TenantID       uuid.UUID          `json:"tenant_id"`
	DiscountType   DiscountType       `json:"discount_type"`
	Amount         pgtype.Numeric     `json:"amount"`
	MaxDiscountCap pgtype.Numeric     `json:"max_discount_cap"`
	StartsAt       time.Time          `json:"starts_at"`
	EndsAt         pgtype.Timestamptz `json:"ends_at"`
	IsActive       bool               `json:"is_active"`
	CreatedBy      pgtype.UUID        `json:"created_by"`
}

func (q *Queries) UpsertProductDiscount(ctx context.Context, arg UpsertProductDiscountParams) (ProductDiscount, error) {
	row := q.db.QueryRow(ctx, upsertProductDiscount,
		arg.ProductID, arg.RestaurantID, arg.TenantID,
		arg.DiscountType, arg.Amount, arg.MaxDiscountCap,
		arg.StartsAt, arg.EndsAt, arg.IsActive, arg.CreatedBy,
	)
	var i ProductDiscount
	err := row.Scan(
		&i.ID, &i.ProductID, &i.RestaurantID, &i.TenantID,
		&i.DiscountType, &i.Amount, &i.MaxDiscountCap,
		&i.StartsAt, &i.EndsAt, &i.IsActive, &i.CreatedBy,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const getActiveDiscount = `-- name: GetActiveDiscount :one
SELECT id, product_id, restaurant_id, tenant_id, discount_type, amount, max_discount_cap, starts_at, ends_at, is_active, created_by, created_at, updated_at FROM product_discounts
WHERE product_id = $1 AND is_active = true
  AND starts_at <= NOW()
  AND (ends_at IS NULL OR ends_at > NOW())
LIMIT 1
`

func (q *Queries) GetActiveDiscount(ctx context.Context, productID uuid.UUID) (ProductDiscount, error) {
	row := q.db.QueryRow(ctx, getActiveDiscount, productID)
	var i ProductDiscount
	err := row.Scan(
		&i.ID, &i.ProductID, &i.RestaurantID, &i.TenantID,
		&i.DiscountType, &i.Amount, &i.MaxDiscountCap,
		&i.StartsAt, &i.EndsAt, &i.IsActive, &i.CreatedBy,
		&i.CreatedAt, &i.UpdatedAt,
	)
	return i, err
}

const deactivateProductDiscount = `-- name: DeactivateProductDiscount :exec
UPDATE product_discounts SET is_active = false WHERE product_id = $1 AND is_active = true
`

func (q *Queries) DeactivateProductDiscount(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateProductDiscount, productID)
	return err
}

const expireDiscounts = `-- name: ExpireDiscounts :exec
UPDATE product_discounts SET is_active = false WHERE ends_at IS NOT NULL AND ends_at < NOW() AND is_active = true
`

func (q *Queries) ExpireDiscounts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, expireDiscounts)
	return err
}
