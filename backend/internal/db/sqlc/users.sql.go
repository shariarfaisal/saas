// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (tenant_id, phone, email, name, password_hash, role, status, gender, date_of_birth, avatar_url, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, tenant_id, phone, email, name, password_hash, role, status, gender, date_of_birth, avatar_url, device_push_token, device_platform, device_model, device_app_version, last_login_at, last_login_ip, email_verified_at, phone_verified_at, two_factor_enabled, two_factor_secret, referral_code, referred_by_id, wallet_balance, total_order_count, total_spent_amount, last_order_at, metadata, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	TenantID     pgtype.UUID     `json:"tenant_id"`
	Phone        sql.NullString  `json:"phone"`
	Email        sql.NullString  `json:"email"`
	Name         string          `json:"name"`
	PasswordHash sql.NullString  `json:"password_hash"`
	Role         UserRole        `json:"role"`
	Status       UserStatus      `json:"status"`
	Gender       NullGenderType  `json:"gender"`
	DateOfBirth  pgtype.Date     `json:"date_of_birth"`
	AvatarUrl    sql.NullString  `json:"avatar_url"`
	Metadata     json.RawMessage `json:"metadata"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.TenantID,
		arg.Phone,
		arg.Email,
		arg.Name,
		arg.PasswordHash,
		arg.Role,
		arg.Status,
		arg.Gender,
		arg.DateOfBirth,
		arg.AvatarUrl,
		arg.Metadata,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.Gender,
		&i.DateOfBirth,
		&i.AvatarUrl,
		&i.DevicePushToken,
		&i.DevicePlatform,
		&i.DeviceModel,
		&i.DeviceAppVersion,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.EmailVerifiedAt,
		&i.PhoneVerifiedAt,
		&i.TwoFactorEnabled,
		&i.TwoFactorSecret,
		&i.ReferralCode,
		&i.ReferredByID,
		&i.WalletBalance,
		&i.TotalOrderCount,
		&i.TotalSpentAmount,
		&i.LastOrderAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, tenant_id, phone, email, name, password_hash, role, status, gender, date_of_birth, avatar_url, device_push_token, device_platform, device_model, device_app_version, last_login_at, last_login_ip, email_verified_at, phone_verified_at, two_factor_enabled, two_factor_secret, referral_code, referred_by_id, wallet_balance, total_order_count, total_spent_amount, last_order_at, metadata, created_at, updated_at, deleted_at FROM users WHERE tenant_id IS NOT DISTINCT FROM $1 AND email = $2 AND deleted_at IS NULL LIMIT 1
`

type GetUserByEmailParams struct {
	TenantID pgtype.UUID    `json:"tenant_id"`
	Email    sql.NullString `json:"email"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, arg GetUserByEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, arg.TenantID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.Gender,
		&i.DateOfBirth,
		&i.AvatarUrl,
		&i.DevicePushToken,
		&i.DevicePlatform,
		&i.DeviceModel,
		&i.DeviceAppVersion,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.EmailVerifiedAt,
		&i.PhoneVerifiedAt,
		&i.TwoFactorEnabled,
		&i.TwoFactorSecret,
		&i.ReferralCode,
		&i.ReferredByID,
		&i.WalletBalance,
		&i.TotalOrderCount,
		&i.TotalSpentAmount,
		&i.LastOrderAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, tenant_id, phone, email, name, password_hash, role, status, gender, date_of_birth, avatar_url, device_push_token, device_platform, device_model, device_app_version, last_login_at, last_login_ip, email_verified_at, phone_verified_at, two_factor_enabled, two_factor_secret, referral_code, referred_by_id, wallet_balance, total_order_count, total_spent_amount, last_order_at, metadata, created_at, updated_at, deleted_at FROM users WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.Gender,
		&i.DateOfBirth,
		&i.AvatarUrl,
		&i.DevicePushToken,
		&i.DevicePlatform,
		&i.DeviceModel,
		&i.DeviceAppVersion,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.EmailVerifiedAt,
		&i.PhoneVerifiedAt,
		&i.TwoFactorEnabled,
		&i.TwoFactorSecret,
		&i.ReferralCode,
		&i.ReferredByID,
		&i.WalletBalance,
		&i.TotalOrderCount,
		&i.TotalSpentAmount,
		&i.LastOrderAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, tenant_id, phone, email, name, password_hash, role, status, gender, date_of_birth, avatar_url, device_push_token, device_platform, device_model, device_app_version, last_login_at, last_login_ip, email_verified_at, phone_verified_at, two_factor_enabled, two_factor_secret, referral_code, referred_by_id, wallet_balance, total_order_count, total_spent_amount, last_order_at, metadata, created_at, updated_at, deleted_at FROM users WHERE tenant_id = $1 AND phone = $2 AND deleted_at IS NULL LIMIT 1
`

type GetUserByPhoneParams struct {
	TenantID pgtype.UUID    `json:"tenant_id"`
	Phone    sql.NullString `json:"phone"`
}

func (q *Queries) GetUserByPhone(ctx context.Context, arg GetUserByPhoneParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPhone, arg.TenantID, arg.Phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.Gender,
		&i.DateOfBirth,
		&i.AvatarUrl,
		&i.DevicePushToken,
		&i.DevicePlatform,
		&i.DeviceModel,
		&i.DeviceAppVersion,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.EmailVerifiedAt,
		&i.PhoneVerifiedAt,
		&i.TwoFactorEnabled,
		&i.TwoFactorSecret,
		&i.ReferralCode,
		&i.ReferredByID,
		&i.WalletBalance,
		&i.TotalOrderCount,
		&i.TotalSpentAmount,
		&i.LastOrderAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users SET deleted_at = NOW() WHERE id = $1
`

func (q *Queries) SoftDeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteUser, id)
	return err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
  name = COALESCE($1, name),
  email = COALESCE($2, email),
  avatar_url = COALESCE($3, avatar_url),
  date_of_birth = COALESCE($4, date_of_birth),
  gender = COALESCE($5, gender),
  device_push_token = COALESCE($6, device_push_token),
  device_platform = COALESCE($7, device_platform),
  last_login_at = COALESCE($8, last_login_at),
  last_login_ip = COALESCE($9, last_login_ip)
WHERE id = $10 AND deleted_at IS NULL
RETURNING id, tenant_id, phone, email, name, password_hash, role, status, gender, date_of_birth, avatar_url, device_push_token, device_platform, device_model, device_app_version, last_login_at, last_login_ip, email_verified_at, phone_verified_at, two_factor_enabled, two_factor_secret, referral_code, referred_by_id, wallet_balance, total_order_count, total_spent_amount, last_order_at, metadata, created_at, updated_at, deleted_at
`

type UpdateUserParams struct {
	Name            sql.NullString     `json:"name"`
	Email           sql.NullString     `json:"email"`
	AvatarUrl       sql.NullString     `json:"avatar_url"`
	DateOfBirth     pgtype.Date        `json:"date_of_birth"`
	Gender          NullGenderType     `json:"gender"`
	DevicePushToken sql.NullString     `json:"device_push_token"`
	DevicePlatform  sql.NullString     `json:"device_platform"`
	LastLoginAt     pgtype.Timestamptz `json:"last_login_at"`
	LastLoginIp     *netip.Addr        `json:"last_login_ip"`
	ID              uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Name,
		arg.Email,
		arg.AvatarUrl,
		arg.DateOfBirth,
		arg.Gender,
		arg.DevicePushToken,
		arg.DevicePlatform,
		arg.LastLoginAt,
		arg.LastLoginIp,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.Role,
		&i.Status,
		&i.Gender,
		&i.DateOfBirth,
		&i.AvatarUrl,
		&i.DevicePushToken,
		&i.DevicePlatform,
		&i.DeviceModel,
		&i.DeviceAppVersion,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.EmailVerifiedAt,
		&i.PhoneVerifiedAt,
		&i.TwoFactorEnabled,
		&i.TwoFactorSecret,
		&i.ReferralCode,
		&i.ReferredByID,
		&i.WalletBalance,
		&i.TotalOrderCount,
		&i.TotalSpentAmount,
		&i.LastOrderAt,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password_hash = $2 WHERE id = $1 AND deleted_at IS NULL
`

type UpdateUserPasswordParams struct {
	ID           uuid.UUID      `json:"id"`
	PasswordHash sql.NullString `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}
